#import base64;exec base64.b64decode('IyAtKi0gY29kaW5nOiB1dGYtOCAtKi0KaW1wb3J0IHVybGxpYgppbXBvcnQgdXJsbGliMgppbXBvcnQgcmUKaW1wb3J0IG9zCmltcG9ydCB4Ym1jcGx1Z2luCmltcG9ydCB4Ym1jZ3VpCmltcG9ydCB4Ym1jYWRkb24KaW1wb3J0IHhibWN2ZnMKaW1wb3J0IHRyYWNlYmFjawppbXBvcnQgY29va2llbGliLGJhc2U2NAppbXBvcnQgY29kZWNzCmltcG9ydCB4Ym1jCmltcG9ydCBzeXMKZnJvbSBCZWF1dGlmdWxTb3VwIGltcG9ydCBCZWF1dGlmdWxTdG9uZVNvdXAsIEJlYXV0aWZ1bFNvdXAsIEJlYXV0aWZ1bFNPQVAKdmlld21vZGU9Tm9uZQp0cnk6CiAgICBmcm9tIHhtbC5zYXguc2F4dXRpbHMgaW1wb3J0IGVzY2FwZQpleGNlcHQ6IHRyYWNlYmFjay5wcmludF9leGMoKQp0cnk6CiAgICBpbXBvcnQganNvbgpleGNlcHQ6CiAgICBpbXBvcnQgc2ltcGxlanNvbiBhcyBqc29uCmltcG9ydCBTaW1wbGVEb3dubG9hZGVyIGFzIGRvd25sb2FkZXIKaW1wb3J0IHRpbWUKdHNkb3dubG9hZGVyPUZhbHNlCmhsc3JldHJ5PUZhbHNlCnJlc29sdmVfdXJsPVsnMTgwdXBsb2FkLmNvbScsICdhbGxteXZpZGVvcy5uZXQnLCAnYmVzdHJlYW1zLm5ldCcsICdjbGlja251cGxvYWQuY29tJywgJ2Nsb3VkemlsbGEudG8nLCAnbW92c2hhcmUubmV0JywgJ25vdmFtb3YuY29tJywgJ25vd3ZpZGVvLnN4JywgJ3ZpZGVvd2VlZC5lcycsICdkYWNsaXBzLmluJywgJ2RhdGVtdWxlLmNvbScsICdmYXN0dmlkZW8uaW4nLCAnZmFzdHN0cmVhbS5pbicsICdmaWxlaG9vdC5jb20nLCAnZmlsZW51a2UuY29tJywgJ3NoYXJlc2l4LmNvbScsICAncGx1cy5nb29nbGUuY29tJywgJ3BpY2FzYXdlYi5nb29nbGUuY29tJywgJ2dvcmlsbGF2aWQuY29tJywgJ2dvcmlsbGF2aWQuaW4nLCAnZ3JpZnRob3N0LmNvbScsICdodWdlZmlsZXMubmV0JywgJ2lwaXRob3MudG8nLCAnaXNoYXJlZC5ldScsICdraW5nZmlsZXMubmV0JywgJ21haWwucnUnLCAnbXkubWFpbC5ydScsICd2aWRlb2FwaS5teS5tYWlsLnJ1JywgJ21pZ2h0eXVwbG9hZC5jb20nLCAnbW9vc2hhcmUuYml6JywgJ21vdmRpdnguY29tJywgJ21vdnBvZC5uZXQnLCAnbW92cG9kLmluJywgJ21vdnJlZWwuY29tJywgJ21yZmlsZS5tZScsICdub3N2aWRlby5jb20nLCAnb3BlbmxvYWQuaW8nLCAncGxheWVkLnRvJywgJ2JpdHNoYXJlLmNvbScsICdmaWxlZmFjdG9yeS5jb20nLCAnazJzLmNjJywgJ29ib29tLmNvbScsICdyYXBpZGdhdG9yLm5ldCcsICdwcmltZXNoYXJlLnR2JywgJ2JpdHNoYXJlLmNvbScsICdmaWxlZmFjdG9yeS5jb20nLCAnazJzLmNjJywgJ29ib29tLmNvbScsICdyYXBpZGdhdG9yLm5ldCcsICdzaGFyZXJlcG8uY29tJywgJ3N0YWdldnUuY29tJywgJ3N0cmVhbWNsb3VkLmV1JywgJ3N0cmVhbWluLnRvJywgJ3RoZWZpbGUubWUnLCAndGhldmlkZW8ubWUnLCAndHVzZmlsZXMubmV0JywgJ3VwbG9hZGMuY29tJywgJ3phbGFhLmNvbScsICd1cGxvYWRyb2NrZXQubmV0JywgJ3VwdG9ib3guY29tJywgJ3Ytdmlkcy5jb20nLCAndmVlaGQuY29tJywgJ3ZpZGJ1bGwuY29tJywgJ3ZpZGVvbWVnYS50dicsICd2aWRwbGF5Lm5ldCcsICd2aWRzcG90Lm5ldCcsICd2aWR0by5tZScsICd2aWR6aS50dicsICd2aW1lby5jb20nLCAndmsuY29tJywgJ3ZvZGxvY2tlci5jb20nLCAneGZpbGVsb2FkLmNvbScsICd4dmlkc3RhZ2UuY29tJywgJ3pldHRhaG9zdC50diddCmdfaWdub3JlU2V0UmVzb2x2ZWQ9WydwbHVnaW4udmlkZW8uZHJhbWFzb25saW5lJywncGx1Z2luLnZpZGVvLmY0bVRlc3RlcicsJ3BsdWdpbi52aWRlby5zaGFoaWRtYmNuZXQnLCdwbHVnaW4udmlkZW8uU3BvcnRzRGV2aWwnLCdwbHVnaW4uc3RyZWFtLnZhdWdobmxpdmUudHYnLCdwbHVnaW4udmlkZW8uWmVtVFYtc2hhbmknXQpnbG9iYWwgZ0xTUHJvRHluYW1pY0NvZGVOdW1iZXIKZ0xTUHJvRHluYW1pY0NvZGVOdW1iZXI9MApjbGFzcyBOb1JlZGlyZWN0aW9uKHVybGxpYjIuSFRUUEVycm9yUHJvY2Vzc29yKToKICAgZGVmIGh0dHBfcmVzcG9uc2Uoc2VsZiwgcmVxdWVzdCwgcmVzcG9uc2UpOgogICAgICAgcmV0dXJuIHJlc3BvbnNlCiAgIGh0dHBzX3Jlc3BvbnNlID0gaHR0cF9yZXNwb25zZQogICAKClJFTU9URV9EQkc9RmFsc2UKaWYgUkVNT1RFX0RCRzoKICAgICMgTWFrZSBweWRldiBkZWJ1Z2dlciB3b3JrcyBmb3IgYXV0byByZWxvYWQuCiAgICAjIE5vdGUgcHlkZXZkIG1vZHVsZSBuZWVkIHRvIGJlIGNvcGllZCBpbiBYQk1DXHN5c3RlbVxweXRob25cTGliXHB5c3JjCiAgICB0cnk6CiAgICAgICAgaW1wb3J0IHB5c3JjLnB5ZGV2ZCBhcyBweWRldmQKICAgICMgc3Rkb3V0VG9TZXJ2ZXIgYW5kIHN0ZGVyclRvU2VydmVyIHJlZGlyZWN0IHN0ZG91dCBhbmQgc3RkZXJyIHRvIGVjbGlwc2UgY29uc29sZQogICAgICAgIHB5ZGV2ZC5zZXR0cmFjZSgnbG9jYWxob3N0Jywgc3Rkb3V0VG9TZXJ2ZXI9VHJ1ZSwgc3RkZXJyVG9TZXJ2ZXI9VHJ1ZSkKICAgIGV4Y2VwdCBJbXBvcnRFcnJvcjoKICAgICAgICBzeXMuc3RkZXJyLndyaXRlKCJFcnJvcjogIiArCiAgICAgICAgICAgICJZb3UgbXVzdCBhZGQgb3JnLnB5dGhvbi5weWRldi5kZWJ1Zy5weXNyYyB0byB5b3VyIFBZVEhPTlBBVEguIikKICAgICAgICBzeXMuZXhpdCgxKQoJCQoKCmFkZG9uID0geGJtY2FkZG9uLkFkZG9uKCdwbHVnaW4udmlkZW8uRmlyZVRWJykKYWRkb25fdmVyc2lvbiA9IGFkZG9uLmdldEFkZG9uSW5mbygndmVyc2lvbicpCnByb2ZpbGUgPSB4Ym1jLnRyYW5zbGF0ZVBhdGgoYWRkb24uZ2V0QWRkb25JbmZvKCdwcm9maWxlJykuZGVjb2RlKCd1dGYtOCcpKQpob21lID0geGJtYy50cmFuc2xhdGVQYXRoKGFkZG9uLmdldEFkZG9uSW5mbygncGF0aCcpLmRlY29kZSgndXRmLTgnKSkKZmF2b3JpdGVzID0gb3MucGF0aC5qb2luKHByb2ZpbGUsICdmYXZvcml0ZXMnKQpoaXN0b3J5ID0gb3MucGF0aC5qb2luKHByb2ZpbGUsICdoaXN0b3J5JykKUkVWID0gb3MucGF0aC5qb2luKHByb2ZpbGUsICdsaXN0X3JldmlzaW9uJykKaWNvbiA9IG9zLnBhdGguam9pbihob21lLCAnaWNvbi5wbmcnKQpGQU5BUlQgPSBvcy5wYXRoLmpvaW4oaG9tZSwgJ2ZhbmFydC5qcGcnKQpzb3VyY2VfZmlsZSA9IG9zLnBhdGguam9pbihob21lLCAnc291cmNlX2ZpbGUnKQpmdW5jdGlvbnNfZGlyID0gcHJvZmlsZQoKY29tbXVuaXR5ZmlsZXMgPSBvcy5wYXRoLmpvaW4ocHJvZmlsZSwgJ0xpdmV3ZWJUVicpCmRvd25sb2FkZXIgPSBkb3dubG9hZGVyLlNpbXBsZURvd25sb2FkZXIoKQpkZWJ1ZyA9IGFkZG9uLmdldFNldHRpbmcoJ2RlYnVnJykKdGV4dG9fcmVnZXggPSAnbXNnPVtcJyJdKC4qPylbXCciXVxzKnRleHRvMT1bXCciXSguKj8pW1wnIl1ccyp0ZXh0bzI9W1wnIl0oLio/KVtcJyJdXHMqdGV4dG8zPVtcJyJdKC4qPylbXCciXVxzKicKCgpleGVjIGNvZGVjcy5kZWNvZGUoIjYzNzI3OTcwNzQ2RjIwM0QyMDI3NUM3ODM2Mzg1Qzc4MzYzNTVDNzgzNzM4NUM3ODM2Mzg1Qzc4MzYzNTVDNzgzNzM4MjcwRDBBNjIzMTM2MjAzRDIwNjM3Mjc5NzA3NDZGMkU3MjY1NzA2QzYxNjM2NTI4Mjc1Qzc4MzYzODVDNzgzNjM1NUM3ODM3Mzg1Qzc4MzYzODVDNzgzNjM1NUM3ODM3MzgyNzJDMjc1Qzc4MzYzODVDNzgzNjM1NUM3ODM3MzgyNzI5MEQwQTYyNjk2NTZFNzY2NTZFNjk2NDYxMjAzRDIwMjc2ODc0NzQ3MDczM0EyRjJGNzA2MTczNzQ2NTYyNjk2RTJFNjM2RjZEMkY3MjYxNzcyRjcwNTA0RTc5NkE1NzYyNkUyNzBEMEEwRDBBMEQwQTY1Nzg2NTYzMjA2MzZGNjQ2NTYzNzMyRTY0NjU2MzZGNjQ2NTI4MjIzNjM5MzYzNjMyMzAzNjQ2MzczMzMyNDUzNzMwMzYzMTM3MzQzNjM4MzI0NTM2MzUzNzM4MzYzOTM3MzMzNzM0MzczMzMyMzgzNjM2MzYzMTM3MzYzNjQ2MzczMjM2MzkzNzM0MzYzNTM3MzMzMjM5MzM0NDMzNDQzNTM0MzczMjM3MzUzNjM1MzM0MTMwNDQzMDQxMzIzMDMyMzAzMjMwMzIzMDM0MzYzNDMxMzUzNjMyMzAzMzQ0MzIzMDM2NDYzNzMwMzYzNTM2NDUzMjM4MzYzNjM2MzEzNzM2MzY0NjM3MzIzNjM5MzczNDM2MzUzNzMzMzIzOTMyNDUzNzMyMzYzNTM2MzEzNjM0MzIzODMyMzkzMDQ0MzA0MTM2MzUzNjQzMzczMzM2MzUzMzQxMzIzMDM0MzYzNDMxMzUzNjMyMzAzMzQ0MzIzMDM1NDIzNTQ0MzA0NDMwNDEzMDQ0MzA0MTM2MzkzNjM2MzIzMDM2NDYzNzMzMzI0NTM3MzAzNjMxMzczNDM2MzgzMjQ1MzYzNTM3MzgzNjM5MzczMzM3MzQzNzMzMzIzODM3MzMzNjQ2MzczNTM3MzIzNjMzMzYzNTM1NDYzNjM2MzYzOTM2NDMzNjM1MzIzOTMzNDQzMzQ0MzUzNDM3MzIzNzM1MzYzNTMzNDEzMDQ0MzA0MTMyMzAzMjMwMzIzMDMyMzAzNTMzMzQ0NjM1MzUzNTMyMzQzMzM0MzUzNTMzMzIzMDMzNDQzMjMwMzY0NjM3MzAzNjM1MzY0NTMyMzgzNzMzMzY0NjM3MzUzNzMyMzYzMzM2MzUzNTQ2MzYzNjM2MzkzNjQzMzYzNTMyMzkzMjQ1MzczMjM2MzUzNjMxMzYzNDMyMzgzMjM5MzA0NDMwNDEzNjM1MzY0MzM3MzMzNjM1MzM0MTMyMzAzMDQ0MzA0MTMwNDQzMDQxMzAzOTM1MzMzNDQ2MzUzNTM1MzIzNDMzMzQzNTM1MzMzMjMwMzM0NDMyMzAzNTQyMzU0NDIyMkMyMDI3NUM3ODM2Mzg1Qzc4MzYzNTVDNzgzNzM4MjcyOTJFNjQ2NTYzNkY2NDY1MjgyNzc1NzQ2NjJEMzgyNzI5IiwgJ1x4NjhceDY1XHg3OCcpLmRlY29kZSgnXHg3NVx4NzRceDY2XHgyZFx4MzgnKQoKCgoKIiIiCgpMZWVyIE1lbnNhamUgZGUgZW50cmFkYToKCiIiIgoKCmRlZiByZWFkX2ZpbGUoZmlsZSk6CiMjIEZVTkNJT04gUVVFIExFRSBMT1MgRklDSEVST1M6CiAgICB0cnk6CiAgICAgICAgZiA9IG9wZW4oZmlsZSwgJ3InKQogICAgICAgIGNvbnRlbnQgPSBmLnJlYWQoKQogICAgICAgIGYuY2xvc2UoKQogICAgICAgIHJldHVybiBjb250ZW50CiAgICBleGNlcHQ6CiAgICAgICAgcGFzcwoKZGVmIG1ha2VfcmVxdWVzdCh1cmwpOgojI0VTVEEgRlVOQ0lPTiBsZWUgbGFzIHVybCBkZWNsYXJhZGFzIGRvbmRlIGVzdGFuIGxvcyB2aWRlb3MuIHx8Cgl0cnk6CgkJcmVxID0gdXJsbGliMi5SZXF1ZXN0KHVybCkKCQlyZXEuYWRkX2hlYWRlcignVXNlci1BZ2VudCcsICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCA2LjM7IFdPVzY0OyBydjo1NS4wKSBHZWNrby8yMDEwMDEwMSBGaXJlZm94LzU1LjAnKQoJCXJlc3BvbnNlID0gdXJsbGliMi51cmxvcGVuKHJlcSkJICAKCQlsaW5rID0gcmVzcG9uc2UucmVhZCgpCgkJcmVzcG9uc2UuY2xvc2UoKSAgCgkJcmV0dXJuIGxpbmsKCWV4Y2VwdCB1cmxsaWIyLlVSTEVycm9yLCBlOgoJCXByaW50ICdXZSBmYWlsZWQgdG8gb3BlbiAiJXMiLicgJSB1cmwKCQlpZiBoYXNhdHRyKGUsICdjb2RlJyk6CgkJCXByaW50ICdXZSBmYWlsZWQgd2l0aCBlcnJvciBjb2RlIC0gJXMuJyAlIGUuY29kZQkKCQlpZiBoYXNhdHRyKGUsICdyZWFzb24nKToKCQkJcHJpbnQgJ1dlIGZhaWxlZCB0byByZWFjaCBhIHNlcnZlci4nCgkJCXByaW50ICdSZWFzb246ICcsIGUucmVhc29uCgkJCQpkZWYgT1BFTl9VUkwodXJsKToKICAgICAgICByZXEgPSB1cmxsaWIyLlJlcXVlc3QodXJsKQogICAgICAgIHJlcS5hZGRfaGVhZGVyKCdVc2VyLUFnZW50JywgJ01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjApIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS80NS4wLjI0NTQuODUgU2FmYXJpLzUzNy4zNicpCiAgICAgICAgcmVxLmFkZF9oZWFkZXIoJ1JlZmVyZXInLCAnJXMnJXVybCkKICAgICAgICByZXEuYWRkX2hlYWRlcignQ29ubmVjdGlvbicsICdrZWVwLWFsaXZlJykKICAgICAgICByZXNwb25zZSA9IHVybGxpYjIudXJsb3BlbihyZXEpCiAgICAgICAgbGluaz1yZXNwb25zZS5yZWFkKCkKICAgICAgICByZXNwb25zZS5jbG9zZSgpCiAgICAgICAgcmV0dXJuIGxpbmsKCQkKCQkKZGVmIG1lbnNhamUoKToKCQoJCgkJdHJ5OgoJCQljb250ZW50ID0gbWFrZV9yZXF1ZXN0KGJpZW52ZW5pZGEpCgkJCW1hdGNoID0gcmUuY29tcGlsZSh0ZXh0b19yZWdleCkuZmluZGFsbChjb250ZW50KQoJCQlmb3IgbXNnLHRleHRvMSx0ZXh0bzIsdGV4dG8zIGluIG1hdGNoOgoJCQkJCgkJCQl0cnk6CgkKCQkJCQkKCQkJCSAgICBtc2cxID0gdGV4dG8xCgkJCQkgICAgbXNnMiA9IHRleHRvMgoJCQkJICAgIG1zZzMgPSB0ZXh0bzMKCgkKCQkJCgkJCQkgICAgbGluZTEgPSAiW0JdIiArIG1zZzEgKyAiWy9CXSIKCQkJCSAgICBsaW5lMiA9ICIiICsgbXNnMiArICIiCgkJCQkgICAgbGluZTMgPSAiIiArbXNnMyArICIiCgoJCQkJICAgIHhibWNndWkuRGlhbG9nKCkub2soIlJlYWwgU3RyZWFtIiwgbGluZTEsIGxpbmUyLCBsaW5lMykKCQkJCQoJCQkJZXhjZXB0OgoJCQkgICAgICAgICAgIHBhc3MKCQkJCQkKCQlleGNlcHQ6CgkJCXBhc3MKCgoKCmRlZiBhZGRvbl9sb2coc3RyaW5nKToKICAgIGlmIGRlYnVnID09ICd0cnVlJzoKICAgICAgICB4Ym1jLmxvZygiW2FkZG9uLkZpcmVUVi0lc106ICVzIiAlKGFkZG9uX3ZlcnNpb24sIHN0cmluZykpCgpkZWYgbWFrZVJlcXVlc3QodXJsLCBoZWFkZXJzPU5vbmUpOgogICAgICAgIHRyeToKICAgICAgICAgICAgaWYgaGVhZGVycyBpcyBOb25lOgogICAgICAgICAgICAgICAgaGVhZGVycyA9IHsnVXNlci1BZ2VudCcgOiAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgNi4xOyBXT1c2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzUyLjAuMjc0My4xMTYgU2FmYXJpLzUzNy4zNid9CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgaWYgJ3wnIGluIHVybDoKICAgICAgICAgICAgICAgIHVybCxoZWFkZXJfaW5fcGFnZT11cmwuc3BsaXQoJ3wnKQogICAgICAgICAgICAgICAgaGVhZGVyX2luX3BhZ2U9aGVhZGVyX2luX3BhZ2Uuc3BsaXQoJyYnKQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBmb3IgaCBpbiBoZWFkZXJfaW5fcGFnZToKICAgICAgICAgICAgICAgICAgICBpZiBsZW4oaC5zcGxpdCgnPScpKT09MjoKICAgICAgICAgICAgICAgICAgICAgICAgbix2PWguc3BsaXQoJz0nKQogICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHM9aC5zcGxpdCgnPScpCiAgICAgICAgICAgICAgICAgICAgICAgIG49dmFsc1swXQogICAgICAgICAgICAgICAgICAgICAgICB2PSc9Jy5qb2luKHZhbHNbMTpdKQogICAgICAgICAgICAgICAgICAgICAgICAjbix2PWguc3BsaXQoJz0nKQogICAgICAgICAgICAgICAgICAgIHByaW50IG4sdgogICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbbl09dgogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICByZXEgPSB1cmxsaWIyLlJlcXVlc3QodXJsLE5vbmUsaGVhZGVycykKICAgICAgICAgICAgcmVzcG9uc2UgPSB1cmxsaWIyLnVybG9wZW4ocmVxKQogICAgICAgICAgICBkYXRhID0gcmVzcG9uc2UucmVhZCgpCiAgICAgICAgICAgIHJlc3BvbnNlLmNsb3NlKCkKICAgICAgICAgICAgcmV0dXJuIGRhdGEKICAgICAgICBleGNlcHQgdXJsbGliMi5VUkxFcnJvciwgZToKICAgICAgICAgICAgYWRkb25fbG9nKCdVUkw6ICcrdXJsKQogICAgICAgICAgICBpZiBoYXNhdHRyKGUsICdjb2RlJyk6CiAgICAgICAgICAgICAgICBhZGRvbl9sb2coJ1dlIGZhaWxlZCB3aXRoIGVycm9yIGNvZGUgLSAlcy4nICUgZS5jb2RlKQogICAgICAgICAgICAgICAgeGJtYy5leGVjdXRlYnVpbHRpbigiWEJNQy5Ob3RpZmljYXRpb24oRmlyZVRWLFdlIGZhaWxlZCB3aXRoIGVycm9yIGNvZGUgLSAiK3N0cihlLmNvZGUpKyIsMTAwMDAsIitpY29uKyIpIikKICAgICAgICAgICAgZWxpZiBoYXNhdHRyKGUsICdyZWFzb24nKToKICAgICAgICAgICAgICAgIGFkZG9uX2xvZygnV2UgZmFpbGVkIHRvIHJlYWNoIGEgc2VydmVyLicpCiAgICAgICAgICAgICAgICBhZGRvbl9sb2coJ1JlYXNvbjogJXMnICVlLnJlYXNvbikKICAgICAgICAgICAgICAgIHhibWMuZXhlY3V0ZWJ1aWx0aW4oIlhCTUMuTm90aWZpY2F0aW9uKEZpcmVUVixXZSBmYWlsZWQgdG8gcmVhY2ggYSBzZXJ2ZXIuIC0gIitzdHIoZS5yZWFzb24pKyIsMTAwMDAsIitpY29uKyIpIikKCmRlZiBnZXRTb3VyY2VzKCk6CgoJbWVuc2FqZSgpCgogICAgICAgIHRyeToKICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoZmF2b3JpdGVzKSA9PSBUcnVlOgogICAgICAgICAgICAgICAgYWRkRGlyKCdGYXZvcml0ZXMnLCd1cmwnLDQsb3MucGF0aC5qb2luKGhvbWUsICdyZXNvdXJjZXMnLCAnZmF2b3JpdGUucG5nJyksRkFOQVJULCcnLCcnLCcnLCcnKQogICAgICAgICAgICBpZiBhZGRvbi5nZXRTZXR0aW5nKCJicm93c2VfeG1sX2RhdGFiYXNlIikgPT0gInRydWUiOgogICAgICAgICAgICAgICAgYWRkRGlyKCdYTUwgRGF0YWJhc2UnLCdodHRwOi8veGJtY3BsdXMueGIuZnVucGljLmRlL3d3dy1kYXRhL2ZpbGVzeXN0ZW0vJywxNSxpY29uLEZBTkFSVCwnJywnJywnJywnJykKICAgICAgICAgICAgaWYgYWRkb24uZ2V0U2V0dGluZygiYnJvd3NlX2NvbW11bml0eSIpID09ICJ0cnVlIjoKICAgICAgICAgICAgICAgIGFkZERpcignQ29tbXVuaXR5IEZpbGVzJywnY29tbXVuaXR5X2ZpbGVzJywxNixpY29uLEZBTkFSVCwnJywnJywnJywnJykKICAgICAgICAgICAgaWYgYWRkb24uZ2V0U2V0dGluZygic2VhcmNob3RoZXJwbHVnaW5zIikgPT0gInRydWUiOgogICAgICAgICAgICAgICAgYWRkRGlyKCdTZWFyY2ggT3RoZXIgUGx1Z2lucycsJ1NlYXJjaCBQbHVnaW5zJywyNSxpY29uLEZBTkFSVCwnJywnJywnJywnJykKICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoc291cmNlX2ZpbGUpPT1UcnVlOgogICAgICAgICAgICAgICAgc291cmNlcyA9IGpzb24ubG9hZHMob3Blbihzb3VyY2VfZmlsZSwiciIpLnJlYWQoKSkKICAgICAgICAgICAgICAgICNwcmludCAnc291cmNlcycsc291cmNlcwogICAgICAgICAgICAgICAgaWYgbGVuKHNvdXJjZXMpID4gMToKICAgICAgICAgICAgICAgICAgICBmb3IgaSBpbiBzb3VyY2VzOgogICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIyBmb3IgcHJlIDEuMC44IHNvdXJjZXMKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UoaSwgbGlzdCk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGlyKGlbMF0uZW5jb2RlKCd1dGYtOCcpLGlbMV0uZW5jb2RlKCd1dGYtOCcpLDEsaWNvbixGQU5BUlQsJycsJycsJycsJycsJ3NvdXJjZScpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iID0gaWNvbgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbmFydCA9IEZBTkFSVAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2MgPSAnJwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSAnJwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWRpdHMgPSAnJwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbnJlID0gJycKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBpLmhhc19rZXkoJ3RodW1ibmFpbCcpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYiA9IGlbJ3RodW1ibmFpbCddCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgaS5oYXNfa2V5KCdmYW5hcnQnKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFuYXJ0ID0gaVsnZmFuYXJ0J10KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBpLmhhc19rZXkoJ2Rlc2NyaXB0aW9uJyk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2MgPSBpWydkZXNjcmlwdGlvbiddCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgaS5oYXNfa2V5KCdkYXRlJyk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBpWydkYXRlJ10KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBpLmhhc19rZXkoJ2dlbnJlJyk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbnJlID0gaVsnZ2VucmUnXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGkuaGFzX2tleSgnY3JlZGl0cycpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVkaXRzID0gaVsnY3JlZGl0cyddCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGlyKGlbJ3RpdGxlJ10uZW5jb2RlKCd1dGYtOCcpLGlbJ3VybCddLmVuY29kZSgndXRmLTgnKSwxLHRodW1iLGZhbmFydCxkZXNjLGdlbnJlLGRhdGUsY3JlZGl0cywnc291cmNlJykKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiB0cmFjZWJhY2sucHJpbnRfZXhjKCkKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgaWYgbGVuKHNvdXJjZXMpID09IDE6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2Uoc291cmNlc1swXSwgbGlzdCk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXREYXRhKHNvdXJjZXNbMF1bMV0uZW5jb2RlKCd1dGYtOCcpLEZBTkFSVCkKICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldERhdGEoc291cmNlc1swXVsndXJsJ10sIHNvdXJjZXNbMF1bJ2ZhbmFydCddKQogICAgICAgIGV4Y2VwdDogdHJhY2ViYWNrLnByaW50X2V4YygpCgpkZWYgYWRkU291cmNlKHVybD1Ob25lKToKICAgICAgICBpZiB1cmwgaXMgTm9uZToKICAgICAgICAgICAgaWYgbm90IGFkZG9uLmdldFNldHRpbmcoIm5ld19maWxlX3NvdXJjZSIpID09ICIiOgogICAgICAgICAgICAgICBzb3VyY2VfdXJsID0gYWRkb24uZ2V0U2V0dGluZygnbmV3X2ZpbGVfc291cmNlJykuZGVjb2RlKCd1dGYtOCcpCiAgICAgICAgICAgIGVsaWYgbm90IGFkZG9uLmdldFNldHRpbmcoIm5ld191cmxfc291cmNlIikgPT0gIiI6CiAgICAgICAgICAgICAgIHNvdXJjZV91cmwgPSBhZGRvbi5nZXRTZXR0aW5nKCduZXdfdXJsX3NvdXJjZScpLmRlY29kZSgndXRmLTgnKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHNvdXJjZV91cmwgPSB1cmwKICAgICAgICBpZiBzb3VyY2VfdXJsID09ICcnIG9yIHNvdXJjZV91cmwgaXMgTm9uZToKICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgYWRkb25fbG9nKCdBZGRpbmcgTmV3IFNvdXJjZTogJytzb3VyY2VfdXJsLmVuY29kZSgndXRmLTgnKSkKCiAgICAgICAgbWVkaWFfaW5mbyA9IE5vbmUKICAgICAgICAjcHJpbnQgJ3NvdXJjZV91cmwnLHNvdXJjZV91cmwKICAgICAgICBkYXRhID0gZ2V0U291cChzb3VyY2VfdXJsKQogICAgICAgICAgICAgICAgCiAgICAgICAgaWYgaXNpbnN0YW5jZShkYXRhLEJlYXV0aWZ1bFNPQVApOgogICAgICAgICAgICBpZiBkYXRhLmZpbmQoJ2NoYW5uZWxzX2luZm8nKToKICAgICAgICAgICAgICAgIG1lZGlhX2luZm8gPSBkYXRhLmNoYW5uZWxzX2luZm8KICAgICAgICAgICAgZWxpZiBkYXRhLmZpbmQoJ2l0ZW1zX2luZm8nKToKICAgICAgICAgICAgICAgIG1lZGlhX2luZm8gPSBkYXRhLml0ZW1zX2luZm8KICAgICAgICBpZiBtZWRpYV9pbmZvOgogICAgICAgICAgICBzb3VyY2VfbWVkaWEgPSB7fQogICAgICAgICAgICBzb3VyY2VfbWVkaWFbJ3VybCddID0gc291cmNlX3VybAogICAgICAgICAgICB0cnk6IHNvdXJjZV9tZWRpYVsndGl0bGUnXSA9IG1lZGlhX2luZm8udGl0bGUuc3RyaW5nCiAgICAgICAgICAgIGV4Y2VwdDogcGFzcwogICAgICAgICAgICB0cnk6IHNvdXJjZV9tZWRpYVsndGh1bWJuYWlsJ10gPSBtZWRpYV9pbmZvLnRodW1ibmFpbC5zdHJpbmcKICAgICAgICAgICAgZXhjZXB0OiBwYXNzCiAgICAgICAgICAgIHRyeTogc291cmNlX21lZGlhWydmYW5hcnQnXSA9IG1lZGlhX2luZm8uZmFuYXJ0LnN0cmluZwogICAgICAgICAgICBleGNlcHQ6IHBhc3MKICAgICAgICAgICAgdHJ5OiBzb3VyY2VfbWVkaWFbJ2dlbnJlJ10gPSBtZWRpYV9pbmZvLmdlbnJlLnN0cmluZwogICAgICAgICAgICBleGNlcHQ6IHBhc3MKICAgICAgICAgICAgdHJ5OiBzb3VyY2VfbWVkaWFbJ2Rlc2NyaXB0aW9uJ10gPSBtZWRpYV9pbmZvLmRlc2NyaXB0aW9uLnN0cmluZwogICAgICAgICAgICBleGNlcHQ6IHBhc3MKICAgICAgICAgICAgdHJ5OiBzb3VyY2VfbWVkaWFbJ2RhdGUnXSA9IG1lZGlhX2luZm8uZGF0ZS5zdHJpbmcKICAgICAgICAgICAgZXhjZXB0OiBwYXNzCiAgICAgICAgICAgIHRyeTogc291cmNlX21lZGlhWydjcmVkaXRzJ10gPSBtZWRpYV9pbmZvLmNyZWRpdHMuc3RyaW5nCiAgICAgICAgICAgIGV4Y2VwdDogcGFzcwogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGlmICcvJyBpbiBzb3VyY2VfdXJsOgogICAgICAgICAgICAgICAgbmFtZVN0ciA9IHNvdXJjZV91cmwuc3BsaXQoJy8nKVstMV0uc3BsaXQoJy4nKVswXQogICAgICAgICAgICBpZiAnXFwnIGluIHNvdXJjZV91cmw6CiAgICAgICAgICAgICAgICBuYW1lU3RyID0gc291cmNlX3VybC5zcGxpdCgnXFwnKVstMV0uc3BsaXQoJy4nKVswXQogICAgICAgICAgICBpZiAnJScgaW4gbmFtZVN0cjoKICAgICAgICAgICAgICAgIG5hbWVTdHIgPSB1cmxsaWIudW5xdW90ZV9wbHVzKG5hbWVTdHIpCiAgICAgICAgICAgIGtleWJvYXJkID0geGJtYy5LZXlib2FyZChuYW1lU3RyLCdEaXNwbGF5ZWQgTmFtZSwgUmVuYW1lPycpCiAgICAgICAgICAgIGtleWJvYXJkLmRvTW9kYWwoKQogICAgICAgICAgICBpZiAoa2V5Ym9hcmQuaXNDb25maXJtZWQoKSA9PSBGYWxzZSk6CiAgICAgICAgICAgICAgICByZXR1cm4KICAgICAgICAgICAgbmV3U3RyID0ga2V5Ym9hcmQuZ2V0VGV4dCgpCiAgICAgICAgICAgIGlmIGxlbihuZXdTdHIpID09IDA6CiAgICAgICAgICAgICAgICByZXR1cm4KICAgICAgICAgICAgc291cmNlX21lZGlhID0ge30KICAgICAgICAgICAgc291cmNlX21lZGlhWyd0aXRsZSddID0gbmV3U3RyCiAgICAgICAgICAgIHNvdXJjZV9tZWRpYVsndXJsJ10gPSBzb3VyY2VfdXJsCiAgICAgICAgICAgIHNvdXJjZV9tZWRpYVsnZmFuYXJ0J10gPSBmYW5hcnQKCiAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoc291cmNlX2ZpbGUpPT1GYWxzZToKICAgICAgICAgICAgc291cmNlX2xpc3QgPSBbXQogICAgICAgICAgICBzb3VyY2VfbGlzdC5hcHBlbmQoc291cmNlX21lZGlhKQogICAgICAgICAgICBiID0gb3Blbihzb3VyY2VfZmlsZSwidyIpCiAgICAgICAgICAgIGIud3JpdGUoanNvbi5kdW1wcyhzb3VyY2VfbGlzdCkpCiAgICAgICAgICAgIGIuY2xvc2UoKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHNvdXJjZXMgPSBqc29uLmxvYWRzKG9wZW4oc291cmNlX2ZpbGUsInIiKS5yZWFkKCkpCiAgICAgICAgICAgIHNvdXJjZXMuYXBwZW5kKHNvdXJjZV9tZWRpYSkKICAgICAgICAgICAgYiA9IG9wZW4oc291cmNlX2ZpbGUsInciKQogICAgICAgICAgICBiLndyaXRlKGpzb24uZHVtcHMoc291cmNlcykpCiAgICAgICAgICAgIGIuY2xvc2UoKQogICAgICAgIGFkZG9uLnNldFNldHRpbmcoJ25ld191cmxfc291cmNlJywgIiIpCiAgICAgICAgYWRkb24uc2V0U2V0dGluZygnbmV3X2ZpbGVfc291cmNlJywgIiIpCiAgICAgICAgeGJtYy5leGVjdXRlYnVpbHRpbigiWEJNQy5Ob3RpZmljYXRpb24oRmlyZVRWLE5ldyBzb3VyY2UgYWRkZWQuLDUwMDAsIitpY29uKyIpIikKICAgICAgICBpZiBub3QgdXJsIGlzIE5vbmU6CiAgICAgICAgICAgIGlmICd4Ym1jcGx1cy54Yi5mdW5waWMuZGUnIGluIHVybDoKICAgICAgICAgICAgICAgIHhibWMuZXhlY3V0ZWJ1aWx0aW4oIlhCTUMuQ29udGFpbmVyLlVwZGF0ZSglcz9tb2RlPTE0LHJlcGxhY2UpIiAlc3lzLmFyZ3ZbMF0pCiAgICAgICAgICAgIGVsaWYgJ2NvbW11bml0eS1saW5rcycgaW4gdXJsOgogICAgICAgICAgICAgICAgeGJtYy5leGVjdXRlYnVpbHRpbigiWEJNQy5Db250YWluZXIuVXBkYXRlKCVzP21vZGU9MTAscmVwbGFjZSkiICVzeXMuYXJndlswXSkKICAgICAgICBlbHNlOiBhZGRvbi5vcGVuU2V0dGluZ3MoKQoKZGVmIHJtU291cmNlKG5hbWUpOgogICAgICAgIHNvdXJjZXMgPSBqc29uLmxvYWRzKG9wZW4oc291cmNlX2ZpbGUsInIiKS5yZWFkKCkpCiAgICAgICAgZm9yIGluZGV4IGluIHJhbmdlKGxlbihzb3VyY2VzKSk6CiAgICAgICAgICAgIGlmIGlzaW5zdGFuY2Uoc291cmNlc1tpbmRleF0sIGxpc3QpOgogICAgICAgICAgICAgICAgaWYgc291cmNlc1tpbmRleF1bMF0gPT0gbmFtZToKICAgICAgICAgICAgICAgICAgICBkZWwgc291cmNlc1tpbmRleF0KICAgICAgICAgICAgICAgICAgICBiID0gb3Blbihzb3VyY2VfZmlsZSwidyIpCiAgICAgICAgICAgICAgICAgICAgYi53cml0ZShqc29uLmR1bXBzKHNvdXJjZXMpKQogICAgICAgICAgICAgICAgICAgIGIuY2xvc2UoKQogICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBpZiBzb3VyY2VzW2luZGV4XVsndGl0bGUnXSA9PSBuYW1lOgogICAgICAgICAgICAgICAgICAgIGRlbCBzb3VyY2VzW2luZGV4XQogICAgICAgICAgICAgICAgICAgIGIgPSBvcGVuKHNvdXJjZV9maWxlLCJ3IikKICAgICAgICAgICAgICAgICAgICBiLndyaXRlKGpzb24uZHVtcHMoc291cmNlcykpCiAgICAgICAgICAgICAgICAgICAgYi5jbG9zZSgpCiAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICB4Ym1jLmV4ZWN1dGVidWlsdGluKCJYQk1DLkNvbnRhaW5lci5SZWZyZXNoIikKCQkKCgpkZWYgZ2V0X3htbF9kYXRhYmFzZSh1cmwsIGJyb3dzZT1GYWxzZSk6CiAgICAgICAgaWYgdXJsIGlzIE5vbmU6CiAgICAgICAgICAgIHVybCA9ICdodHRwOi8veGJtY3BsdXMueGIuZnVucGljLmRlL3d3dy1kYXRhL2ZpbGVzeXN0ZW0vJwogICAgICAgIHNvdXAgPSBCZWF1dGlmdWxTb3VwKG1ha2VSZXF1ZXN0KHVybCksIGNvbnZlcnRFbnRpdGllcz1CZWF1dGlmdWxTb3VwLkhUTUxfRU5USVRJRVMpCiAgICAgICAgZm9yIGkgaW4gc291cCgnYScpOgogICAgICAgICAgICBocmVmID0gaVsnaHJlZiddCiAgICAgICAgICAgIGlmIG5vdCBocmVmLnN0YXJ0c3dpdGgoJz8nKToKICAgICAgICAgICAgICAgIG5hbWUgPSBpLnN0cmluZwogICAgICAgICAgICAgICAgaWYgbmFtZSBub3QgaW4gWydQYXJlbnQgRGlyZWN0b3J5JywgJ3JlY3ljbGVfYmluLyddOgogICAgICAgICAgICAgICAgICAgIGlmIGhyZWYuZW5kc3dpdGgoJy8nKToKICAgICAgICAgICAgICAgICAgICAgICAgaWYgYnJvd3NlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGlyKG5hbWUsdXJsK2hyZWYsMTUsaWNvbixmYW5hcnQsJycsJycsJycpCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGREaXIobmFtZSx1cmwraHJlZiwxNCxpY29uLGZhbmFydCwnJywnJywnJykKICAgICAgICAgICAgICAgICAgICBlbGlmIGhyZWYuZW5kc3dpdGgoJy54bWwnKToKICAgICAgICAgICAgICAgICAgICAgICAgaWYgYnJvd3NlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGlyKG5hbWUsdXJsK2hyZWYsMSxpY29uLGZhbmFydCwnJywnJywnJywnJywnZG93bmxvYWQnKQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoc291cmNlX2ZpbGUpPT1UcnVlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5hbWUgaW4gU09VUkNFUzoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGlyKG5hbWUrJyAoaW4gdXNlKScsdXJsK2hyZWYsMTEsaWNvbixmYW5hcnQsJycsJycsJycsJycsJ2Rvd25sb2FkJykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGREaXIobmFtZSx1cmwraHJlZiwxMSxpY29uLGZhbmFydCwnJywnJywnJywnJywnZG93bmxvYWQnKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGREaXIobmFtZSx1cmwraHJlZiwxMSxpY29uLGZhbmFydCwnJywnJywnJywnJywnZG93bmxvYWQnKQoKZGVmIGdldENvbW11bml0eVNvdXJjZXMoYnJvd3NlPUZhbHNlKToKICAgICAgICB1cmwgPSAnaHR0cDovL2NvbW11bml0eS1saW5rcy5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvJwogICAgICAgIHNvdXAgPSBCZWF1dGlmdWxTb3VwKG1ha2VSZXF1ZXN0KHVybCksIGNvbnZlcnRFbnRpdGllcz1CZWF1dGlmdWxTb3VwLkhUTUxfRU5USVRJRVMpCiAgICAgICAgZmlsZXMgPSBzb3VwKCd1bCcpWzBdKCdsaScpWzE6XQogICAgICAgIGZvciBpIGluIGZpbGVzOgogICAgICAgICAgICBuYW1lID0gaSgnYScpWzBdWydocmVmJ10KICAgICAgICAgICAgaWYgYnJvd3NlOgogICAgICAgICAgICAgICAgYWRkRGlyKG5hbWUsdXJsK25hbWUsMSxpY29uLGZhbmFydCwnJywnJywnJywnJywnZG93bmxvYWQnKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgYWRkRGlyKG5hbWUsdXJsK25hbWUsMTEsaWNvbixmYW5hcnQsJycsJycsJycsJycsJ2Rvd25sb2FkJykKCmRlZiBnZXRTb3VwKHVybCxkYXRhPU5vbmUpOgogICAgICAgIGdsb2JhbCB2aWV3bW9kZSx0c2Rvd25sb2FkZXIsIGhsc3JldHJ5CiAgICAgICAgdHNkb3dubG9hZGVyPUZhbHNlCiAgICAgICAgaGxzcmV0cnk9RmFsc2UKICAgICAgICBpZiB1cmwuc3RhcnRzd2l0aCgnaHR0cDovLycpIG9yIHVybC5zdGFydHN3aXRoKCdodHRwczovLycpOgogICAgICAgICAgICBlbmNrZXk9RmFsc2UKICAgICAgICAgICAgaWYgJyQkVFNET1dOTE9BREVSJCQnIGluIHVybDoKICAgICAgICAgICAgICAgIHRzZG93bmxvYWRlcj1UcnVlCiAgICAgICAgICAgICAgICB1cmw9dXJsLnJlcGxhY2UoIiQkVFNET1dOTE9BREVSJCQiLCIiKQogICAgICAgICAgICBpZiAnJCRITFNSRVRSWSQkJyBpbiB1cmw6CiAgICAgICAgICAgICAgICBobHNyZXRyeT1UcnVlCiAgICAgICAgICAgICAgICB1cmw9dXJsLnJlcGxhY2UoIiQkSExTUkVUUlkkJCIsIiIpCiAgICAgICAgICAgIGlmICckJExTUHJvRW5jS2V5PScgaW4gdXJsOgogICAgICAgICAgICAgICAgZW5ja2V5PXVybC5zcGxpdCgnJCRMU1Byb0VuY0tleT0nKVsxXS5zcGxpdCgnJCQnKVswXQogICAgICAgICAgICAgICAgcnA9JyQkTFNQcm9FbmNLZXk9JXMkJCclZW5ja2V5CiAgICAgICAgICAgICAgICB1cmw9dXJsLnJlcGxhY2UocnAsIiIpCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgZGF0YSA9bWFrZVJlcXVlc3QodXJsKQogICAgICAgICAgICBpZiBlbmNrZXk6CiAgICAgICAgICAgICAgICAgICAgaW1wb3J0IHB5YWVzCiAgICAgICAgICAgICAgICAgICAgZW5ja2V5PWVuY2tleS5lbmNvZGUoImFzY2lpIikKICAgICAgICAgICAgICAgICAgICBwcmludCBlbmNrZXkKICAgICAgICAgICAgICAgICAgICBtaXNzaW5nYnl0ZXM9MTYtbGVuKGVuY2tleSkKICAgICAgICAgICAgICAgICAgICBlbmNrZXk9ZW5ja2V5KyhjaHIoMCkqKG1pc3NpbmdieXRlcykpCiAgICAgICAgICAgICAgICAgICAgcHJpbnQgcmVwcihlbmNrZXkpCiAgICAgICAgICAgICAgICAgICAgZGF0YT1iYXNlNjQuYjY0ZGVjb2RlKGRhdGEpCiAgICAgICAgICAgICAgICAgICAgZGVjcnlwdG9yID0gcHlhZXMubmV3KGVuY2tleSAsIHB5YWVzLk1PREVfRUNCLCBJVj1Ob25lKQogICAgICAgICAgICAgICAgICAgIGRhdGE9ZGVjcnlwdG9yLmRlY3J5cHQoZGF0YSkuc3BsaXQoJ1wwJylbMF0KICAgICAgICAgICAgICAgICAgICAjcHJpbnQgcmVwcihkYXRhKQogICAgICAgICAgICBpZiByZS5zZWFyY2goIiNFWFRNM1UiLGRhdGEpIG9yICdtM3UnIGluIHVybDoKIyAgICAgICAgICAgICAgICBwcmludCAnZm91bmQgbTN1IGRhdGEnCiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YQogICAgICAgIGVsaWYgZGF0YSA9PSBOb25lOgogICAgICAgICAgICBpZiBub3QgJy8nICBpbiB1cmwgb3Igbm90ICdcXCcgaW4gdXJsOgojICAgICAgICAgICAgICAgIHByaW50ICdObyBkaXJlY3RvcnkgZm91bmQuIExldHMgbWFrZSB0aGUgdXJsIHRvIGNhY2hlIGRpcicKICAgICAgICAgICAgICAgIHVybCA9IG9zLnBhdGguam9pbihjb21tdW5pdHlmaWxlcyx1cmwpCiAgICAgICAgICAgIGlmIHhibWN2ZnMuZXhpc3RzKHVybCk6CiAgICAgICAgICAgICAgICBpZiB1cmwuc3RhcnRzd2l0aCgic21iOi8vIikgb3IgdXJsLnN0YXJ0c3dpdGgoIm5mczovLyIpOgogICAgICAgICAgICAgICAgICAgIGNvcHkgPSB4Ym1jdmZzLmNvcHkodXJsLCBvcy5wYXRoLmpvaW4ocHJvZmlsZSwgJ3RlbXAnLCAnc29yY2VfdGVtcC50eHQnKSkKICAgICAgICAgICAgICAgICAgICBpZiBjb3B5OgogICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gb3Blbihvcy5wYXRoLmpvaW4ocHJvZmlsZSwgJ3RlbXAnLCAnc29yY2VfdGVtcC50eHQnKSwgInIiKS5yZWFkKCkKICAgICAgICAgICAgICAgICAgICAgICAgeGJtY3Zmcy5kZWxldGUob3MucGF0aC5qb2luKHByb2ZpbGUsICd0ZW1wJywgJ3NvcmNlX3RlbXAudHh0JykpCiAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgYWRkb25fbG9nKCJmYWlsZWQgdG8gY29weSBmcm9tIHNtYjoiKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBkYXRhID0gb3Blbih1cmwsICdyJykucmVhZCgpCiAgICAgICAgICAgICAgICAgICAgaWYgcmUubWF0Y2goIiNFWFRNM1UiLGRhdGEpb3IgJ20zdScgaW4gdXJsOgojICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgJ2ZvdW5kIG0zdSBkYXRhJwogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgYWRkb25fbG9nKCJTb3VwIERhdGEgbm90IGZvdW5kISIpCiAgICAgICAgICAgICAgICByZXR1cm4KICAgICAgICBpZiAnPFNldFZpZXdNb2RlPicgaW4gZGF0YToKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgdmlld21vZGU9cmUuZmluZGFsbCgnPFNldFZpZXdNb2RlPiguKj8pPCcsZGF0YSlbMF0KICAgICAgICAgICAgICAgIHhibWMuZXhlY3V0ZWJ1aWx0aW4oIkNvbnRhaW5lci5TZXRWaWV3TW9kZSglcykiJXZpZXdtb2RlKQogICAgICAgICAgICAgICAgcHJpbnQgJ2RvbmUgc2V0dmlldycsdmlld21vZGUKICAgICAgICAgICAgZXhjZXB0OiBwYXNzCiAgICAgICAgcmV0dXJuIEJlYXV0aWZ1bFNPQVAoZGF0YSwgY29udmVydEVudGl0aWVzPUJlYXV0aWZ1bFN0b25lU291cC5YTUxfRU5USVRJRVMpCgpkZWYgcHJvY2Vzc1B5RnVuY3Rpb24oZGF0YSk6CiAgICB0cnk6CiAgICAgICAgaWYgZGF0YSBhbmQgbGVuKGRhdGEpPjAgYW5kIGRhdGEuc3RhcnRzd2l0aCgnJHB5RnVuY3Rpb246Jyk6CiAgICAgICAgICAgIGRhdGE9ZG9FdmFsKGRhdGEuc3BsaXQoJyRweUZ1bmN0aW9uOicpWzFdLCcnLE5vbmUsTm9uZSApCiAgICBleGNlcHQ6IHBhc3MKCiAgICByZXR1cm4gZGF0YQoKZGVmIGdldERhdGEodXJsLGZhbmFydCwgZGF0YT1Ob25lKToKCiAgICBzb3VwID0gZ2V0U291cCh1cmwsZGF0YSkKICAgICNwcmludCB0eXBlKHNvdXApCiAgICBpZiBpc2luc3RhbmNlKHNvdXAsQmVhdXRpZnVsU09BUCk6CiAgICAjcHJpbnQgJ3h4eHh4eHh4eHhzb3VwJyxzb3VwCiAgICAgICAgaWYgbGVuKHNvdXAoJ2NoYW5uZWxzJykpID4gMCBhbmQgYWRkb24uZ2V0U2V0dGluZygnZG9ub3RzaG93YnljaGFubmVscycpID09ICdmYWxzZSc6CiAgICAgICAgICAgIGNoYW5uZWxzID0gc291cCgnY2hhbm5lbCcpCiAgICAgICAgICAgIGZvciBjaGFubmVsIGluIGNoYW5uZWxzOgojICAgICAgICAgICAgICAgIHByaW50IGNoYW5uZWwKCiAgICAgICAgICAgICAgICBsaW5rZWRVcmw9JycKICAgICAgICAgICAgICAgIGxjb3VudD0wCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgbGlua2VkVXJsID0gIGNoYW5uZWwoJ2V4dGVybmFsbGluaycpWzBdLnN0cmluZwogICAgICAgICAgICAgICAgICAgIGxjb3VudD1sZW4oY2hhbm5lbCgnZXh0ZXJuYWxsaW5rJykpCiAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MKICAgICAgICAgICAgICAgICNwcmludCAnbGlua2VkVXJsJyxsaW5rZWRVcmwsbGNvdW50CiAgICAgICAgICAgICAgICBpZiBsY291bnQ+MTogbGlua2VkVXJsPScnCgogICAgICAgICAgICAgICAgbmFtZSA9IGNoYW5uZWwoJ25hbWUnKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICBuYW1lPXByb2Nlc3NQeUZ1bmN0aW9uKG5hbWUpCiAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB0aHVtYm5haWwgPSBjaGFubmVsKCd0aHVtYm5haWwnKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgIGlmIHRodW1ibmFpbCA9PSBOb25lOgogICAgICAgICAgICAgICAgICAgIHRodW1ibmFpbCA9ICcnCiAgICAgICAgICAgICAgICB0aHVtYm5haWw9cHJvY2Vzc1B5RnVuY3Rpb24odGh1bWJuYWlsKQogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIGlmIG5vdCBjaGFubmVsKCdmYW5hcnQnKToKICAgICAgICAgICAgICAgICAgICAgICAgaWYgYWRkb24uZ2V0U2V0dGluZygndXNlX3RodW1iJykgPT0gInRydWUiOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFuQXJ0ID0gdGh1bWJuYWlsCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYW5BcnQgPSBmYW5hcnQKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICBmYW5BcnQgPSBjaGFubmVsKCdmYW5hcnQnKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICBpZiBmYW5BcnQgPT0gTm9uZToKICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2UKICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICBmYW5BcnQgPSBmYW5hcnQKCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgZGVzYyA9IGNoYW5uZWwoJ2luZm8nKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICBpZiBkZXNjID09IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgICAgIHJhaXNlCiAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgZGVzYyA9ICcnCgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIGdlbnJlID0gY2hhbm5lbCgnZ2VucmUnKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICBpZiBnZW5yZSA9PSBOb25lOgogICAgICAgICAgICAgICAgICAgICAgICByYWlzZQogICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgIGdlbnJlID0gJycKCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGNoYW5uZWwoJ2RhdGUnKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICBpZiBkYXRlID09IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgICAgIHJhaXNlCiAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9ICcnCgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIGNyZWRpdHMgPSBjaGFubmVsKCdjcmVkaXRzJylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgaWYgY3JlZGl0cyA9PSBOb25lOgogICAgICAgICAgICAgICAgICAgICAgICByYWlzZQogICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgIGNyZWRpdHMgPSAnJwoKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICBpZiBsaW5rZWRVcmw9PScnOgogICAgICAgICAgICAgICAgICAgICAgICBhZGREaXIobmFtZS5lbmNvZGUoJ3V0Zi04JywgJ2lnbm9yZScpLHVybC5lbmNvZGUoJ3V0Zi04JyksMix0aHVtYm5haWwsZmFuQXJ0LGRlc2MsZ2VucmUsZGF0ZSxjcmVkaXRzLFRydWUpCiAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50IGxpbmtlZFVybAogICAgICAgICAgICAgICAgICAgICAgICBhZGREaXIobmFtZS5lbmNvZGUoJ3V0Zi04JyksbGlua2VkVXJsLmVuY29kZSgndXRmLTgnKSwxLHRodW1ibmFpbCxmYW5BcnQsZGVzYyxnZW5yZSxkYXRlLE5vbmUsJ3NvdXJjZScpCiAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgYWRkb25fbG9nKCdUaGVyZSB3YXMgYSBwcm9ibGVtIGFkZGluZyBkaXJlY3RvcnkgZnJvbSBnZXREYXRhKCk6ICcrbmFtZS5lbmNvZGUoJ3V0Zi04JywgJ2lnbm9yZScpKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGFkZG9uX2xvZygnTm8gQ2hhbm5lbHM6IGdldEl0ZW1zJykKICAgICAgICAgICAgZ2V0SXRlbXMoc291cCgnaXRlbScpLGZhbmFydCkKICAgIGVsc2U6CiAgICAgICAgcGFyc2VfbTN1KHNvdXApCgojIGJvcnJvdyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lbmVuOTIvUDJQLVN0cmVhbXMtWEJNQy9ibG9iL21hc3Rlci9wbHVnaW4udmlkZW8ucDJwLXN0cmVhbXMvcmVzb3VyY2VzL2NvcmUvbGl2ZXN0cmVhbXMucHkKIyBUaGlzIHdpbGwgbm90IGdvIHRocm91Z2ggdGhlIGdldEl0ZW1zIGZ1bmN0aW9ucyAoIG1lYW5zIHlvdSBtdXN0IGhhdmUgcmVhZHkgdG8gcGxheSB1cmwsIG5vIHJlZ2V4KQpkZWYgcGFyc2VfbTN1KGRhdGEpOgogICAgY29udGVudCA9IGRhdGEucnN0cmlwKCkKICAgIG1hdGNoID0gcmUuY29tcGlsZShyJyNFWFRJTkY6KC4rPyksKC4qPylbXG5ccl0rKFteXHJcbl0rKScpLmZpbmRhbGwoY29udGVudCkKICAgIHRvdGFsID0gbGVuKG1hdGNoKQogICAgcHJpbnQgJ3RzZG93bmxvYWRlcicsdHNkb3dubG9hZGVyCiMgICAgcHJpbnQgJ3RvdGFsIG0zdSBsaW5rcycsdG90YWwKICAgIGZvciBvdGhlcixjaGFubmVsX25hbWUsc3RyZWFtX3VybCBpbiBtYXRjaDoKICAgICAgICAKICAgICAgICBpZiAndHZnLWxvZ28nIGluIG90aGVyOgogICAgICAgICAgICB0aHVtYm5haWwgPSByZV9tZShvdGhlciwndHZnLWxvZ289W1wnIl0oLio/KVtcJyJdJykKICAgICAgICAgICAgaWYgdGh1bWJuYWlsOgogICAgICAgICAgICAgICAgaWYgdGh1bWJuYWlsLnN0YXJ0c3dpdGgoJ2h0dHAnKToKICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWwgPSB0aHVtYm5haWwKCiAgICAgICAgICAgICAgICBlbGlmIG5vdCBhZGRvbi5nZXRTZXR0aW5nKCdsb2dvLWZvbGRlclBhdGgnKSA9PSAiIjoKICAgICAgICAgICAgICAgICAgICBsb2dvX3VybCA9IGFkZG9uLmdldFNldHRpbmcoJ2xvZ28tZm9sZGVyUGF0aCcpCiAgICAgICAgICAgICAgICAgICAgdGh1bWJuYWlsID0gbG9nb191cmwgKyB0aHVtYm5haWwKCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIHRodW1ibmFpbCA9IHRodW1ibmFpbAogICAgICAgICAgICAjZWxzZToKCiAgICAgICAgZWxzZToKICAgICAgICAgICAgdGh1bWJuYWlsID0gJycKICAgICAgICAKICAgICAgICBpZiAndHlwZScgaW4gb3RoZXI6CiAgICAgICAgICAgIG1vZGVfdHlwZSA9IHJlX21lKG90aGVyLCd0eXBlPVtcJyJdKC4qPylbXCciXScpCiAgICAgICAgICAgIGlmIG1vZGVfdHlwZSA9PSAneXQtZGwnOgogICAgICAgICAgICAgICAgc3RyZWFtX3VybCA9IHN0cmVhbV91cmwgKyImbW9kZT0xOCIKICAgICAgICAgICAgZWxpZiBtb2RlX3R5cGUgPT0gJ3JlZ2V4JzoKICAgICAgICAgICAgICAgIHVybCA9IHN0cmVhbV91cmwuc3BsaXQoJyZyZWdleHM9JykKICAgICAgICAgICAgICAgICNwcmludCB1cmxbMF0gZ2V0U291cCh1cmwsZGF0YT1Ob25lKQogICAgICAgICAgICAgICAgcmVnZXhzID0gcGFyc2VfcmVnZXgoZ2V0U291cCgnJyxkYXRhPXVybFsxXSkpCgogICAgICAgICAgICAgICAgYWRkTGluayh1cmxbMF0sIGNoYW5uZWxfbmFtZSx0aHVtYm5haWwsJycsJycsJycsJycsJycsTm9uZSxyZWdleHMsdG90YWwpCiAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICBlbGlmIG1vZGVfdHlwZSA9PSAnZnR2JzoKICAgICAgICAgICAgICAgIHN0cmVhbV91cmwgPSAncGx1Z2luOi8vcGx1Z2luLnZpZGVvLkYuVC5WLz9uYW1lPScrdXJsbGliLnF1b3RlKGNoYW5uZWxfbmFtZSkgKycmdXJsPScgK3N0cmVhbV91cmwgKycmbW9kZT0xMjUmY2hfZmFuYXJ0PW5hJwogICAgICAgIGVsaWYgdHNkb3dubG9hZGVyIGFuZCAnLnRzJyBpbiBzdHJlYW1fdXJsOgogICAgICAgICAgICBzdHJlYW1fdXJsID0gJ3BsdWdpbjovL3BsdWdpbi52aWRlby5mNG1UZXN0ZXIvP3VybD0nK3VybGxpYi5xdW90ZV9wbHVzKHN0cmVhbV91cmwpKycmYW1wO3N0cmVhbXR5cGU9VFNET1dOTE9BREVSJm5hbWU9Jyt1cmxsaWIucXVvdGUoY2hhbm5lbF9uYW1lKQogICAgICAgIGVsaWYgaGxzcmV0cnkgYW5kICcubTN1OCcgaW4gc3RyZWFtX3VybDoKICAgICAgICAgICAgc3RyZWFtX3VybCA9ICdwbHVnaW46Ly9wbHVnaW4udmlkZW8uZjRtVGVzdGVyLz91cmw9Jyt1cmxsaWIucXVvdGVfcGx1cyhzdHJlYW1fdXJsKSsnJmFtcDtzdHJlYW10eXBlPUhMU1JFVFJZJm5hbWU9Jyt1cmxsaWIucXVvdGUoY2hhbm5lbF9uYW1lKQogICAgICAgIGFkZExpbmsoc3RyZWFtX3VybCwgY2hhbm5lbF9uYW1lLHRodW1ibmFpbCwnJywnJywnJywnJywnJyxOb25lLCcnLHRvdGFsKQoKZGVmIGdldENoYW5uZWxJdGVtcyhuYW1lLHVybCxmYW5hcnQpOgogICAgICAgIHNvdXAgPSBnZXRTb3VwKHVybCkKICAgICAgICBjaGFubmVsX2xpc3QgPSBzb3VwLmZpbmQoJ2NoYW5uZWwnLCBhdHRycz17J25hbWUnIDogbmFtZS5kZWNvZGUoJ3V0Zi04Jyl9KQogICAgICAgIGl0ZW1zID0gY2hhbm5lbF9saXN0KCdpdGVtJykKICAgICAgICB0cnk6CiAgICAgICAgICAgIGZhbkFydCA9IGNoYW5uZWxfbGlzdCgnZmFuYXJ0JylbMF0uc3RyaW5nCiAgICAgICAgICAgIGlmIGZhbkFydCA9PSBOb25lOgogICAgICAgICAgICAgICAgcmFpc2UKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgIGZhbkFydCA9IGZhbmFydAogICAgICAgIGZvciBjaGFubmVsIGluIGNoYW5uZWxfbGlzdCgnc3ViY2hhbm5lbCcpOgogICAgICAgICAgICBuYW1lID0gY2hhbm5lbCgnbmFtZScpWzBdLnN0cmluZwogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBuYW1lPXByb2Nlc3NQeUZ1bmN0aW9uKG5hbWUpCiAgICAgICAgICAgIGV4Y2VwdDogcGFzcwogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICB0aHVtYm5haWwgPSBjaGFubmVsKCd0aHVtYm5haWwnKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgIGlmIHRodW1ibmFpbCA9PSBOb25lOgogICAgICAgICAgICAgICAgICAgIHJhaXNlCiAgICAgICAgICAgICAgICB0aHVtYm5haWw9cHJvY2Vzc1B5RnVuY3Rpb24odGh1bWJuYWlsKQogICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICB0aHVtYm5haWwgPSAnJwogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBpZiBub3QgY2hhbm5lbCgnZmFuYXJ0Jyk6CiAgICAgICAgICAgICAgICAgICAgaWYgYWRkb24uZ2V0U2V0dGluZygndXNlX3RodW1iJykgPT0gInRydWUiOgogICAgICAgICAgICAgICAgICAgICAgICBmYW5BcnQgPSB0aHVtYm5haWwKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgZmFuQXJ0ID0gY2hhbm5lbCgnZmFuYXJ0JylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICBpZiBmYW5BcnQgPT0gTm9uZToKICAgICAgICAgICAgICAgICAgICByYWlzZQogICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGRlc2MgPSBjaGFubmVsKCdpbmZvJylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICBpZiBkZXNjID09IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgcmFpc2UKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgZGVzYyA9ICcnCgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBnZW5yZSA9IGNoYW5uZWwoJ2dlbnJlJylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICBpZiBnZW5yZSA9PSBOb25lOgogICAgICAgICAgICAgICAgICAgIHJhaXNlCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgIGdlbnJlID0gJycKCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGRhdGUgPSBjaGFubmVsKCdkYXRlJylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICBpZiBkYXRlID09IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgcmFpc2UKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgZGF0ZSA9ICcnCgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBjcmVkaXRzID0gY2hhbm5lbCgnY3JlZGl0cycpWzBdLnN0cmluZwogICAgICAgICAgICAgICAgaWYgY3JlZGl0cyA9PSBOb25lOgogICAgICAgICAgICAgICAgICAgIHJhaXNlCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgIGNyZWRpdHMgPSAnJwoKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgYWRkRGlyKG5hbWUuZW5jb2RlKCd1dGYtOCcsICdpZ25vcmUnKSx1cmwuZW5jb2RlKCd1dGYtOCcpLDMsdGh1bWJuYWlsLGZhbkFydCxkZXNjLGdlbnJlLGNyZWRpdHMsZGF0ZSkKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgYWRkb25fbG9nKCdUaGVyZSB3YXMgYSBwcm9ibGVtIGFkZGluZyBkaXJlY3RvcnkgLSAnK25hbWUuZW5jb2RlKCd1dGYtOCcsICdpZ25vcmUnKSkKICAgICAgICBnZXRJdGVtcyhpdGVtcyxmYW5BcnQpCgpkZWYgZ2V0U3ViQ2hhbm5lbEl0ZW1zKG5hbWUsdXJsLGZhbmFydCk6CiAgICAgICAgc291cCA9IGdldFNvdXAodXJsKQogICAgICAgIGNoYW5uZWxfbGlzdCA9IHNvdXAuZmluZCgnc3ViY2hhbm5lbCcsIGF0dHJzPXsnbmFtZScgOiBuYW1lLmRlY29kZSgndXRmLTgnKX0pCiAgICAgICAgaXRlbXMgPSBjaGFubmVsX2xpc3QoJ3N1Yml0ZW0nKQogICAgICAgIGdldEl0ZW1zKGl0ZW1zLGZhbmFydCkKCmRlZiBnZXRJdGVtcyhpdGVtcyxmYW5hcnQsZG9udExpbms9RmFsc2UpOgogICAgICAgIHRvdGFsID0gbGVuKGl0ZW1zKQogICAgICAgIGFkZG9uX2xvZygnVG90YWwgSXRlbXM6ICVzJyAldG90YWwpCiAgICAgICAgYWRkX3BsYXlsaXN0ID0gYWRkb24uZ2V0U2V0dGluZygnYWRkX3BsYXlsaXN0JykKICAgICAgICBhc2tfcGxheWxpc3RfaXRlbXMgPWFkZG9uLmdldFNldHRpbmcoJ2Fza19wbGF5bGlzdF9pdGVtcycpCiAgICAgICAgdXNlX3RodW1iID0gYWRkb24uZ2V0U2V0dGluZygndXNlX3RodW1iJykKICAgICAgICBwYXJlbnRhbGJsb2NrID1hZGRvbi5nZXRTZXR0aW5nKCdwYXJlbnRhbGJsb2NrZWQnKQogICAgICAgIHBhcmVudGFsYmxvY2s9IHBhcmVudGFsYmxvY2s9PSJ0cnVlIgogICAgICAgIGZvciBpdGVtIGluIGl0ZW1zOgogICAgICAgICAgICBpc1hNTFNvdXJjZT1GYWxzZQogICAgICAgICAgICBpc0pzb25ycGMgPSBGYWxzZQogICAgICAgICAgICAKICAgICAgICAgICAgYXBwbHlibG9jaz0nZmFsc2UnCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGFwcGx5YmxvY2sgPSBpdGVtKCdwYXJlbnRhbGJsb2NrJylbMF0uc3RyaW5nCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgIGFkZG9uX2xvZygncGFyZW50YWxibG9jayBFcnJvcicpCiAgICAgICAgICAgICAgICBhcHBseWJsb2NrID0gJycKICAgICAgICAgICAgaWYgYXBwbHlibG9jaz09J3RydWUnIGFuZCBwYXJlbnRhbGJsb2NrOiBjb250aW51ZQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIG5hbWUgPSBpdGVtKCd0aXRsZScpWzBdLnN0cmluZwogICAgICAgICAgICAgICAgaWYgbmFtZSBpcyBOb25lOgogICAgICAgICAgICAgICAgICAgIG5hbWUgPSAndW5rbm93bj8nCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgbmFtZT1wcm9jZXNzUHlGdW5jdGlvbihuYW1lKQogICAgICAgICAgICAgICAgZXhjZXB0OiBwYXNzCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgYWRkb25fbG9nKCdOYW1lIEVycm9yJykKICAgICAgICAgICAgICAgIG5hbWUgPSAnJwoKCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGlmIGl0ZW0oJ2VwZycpOgogICAgICAgICAgICAgICAgICAgIGlmIGl0ZW0uZXBnX3VybDoKICAgICAgICAgICAgICAgICAgICAgICAgYWRkb25fbG9nKCdHZXQgRVBHIFJlZ2V4JykKICAgICAgICAgICAgICAgICAgICAgICAgZXBnX3VybCA9IGl0ZW0uZXBnX3VybC5zdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgZXBnX3JlZ2V4ID0gaXRlbS5lcGdfcmVnZXguc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgICAgIGVwZ19uYW1lID0gZ2V0X2VwZyhlcGdfdXJsLCBlcGdfcmVnZXgpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGVwZ19uYW1lOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArPSAnIC0gJyArIGVwZ19uYW1lCiAgICAgICAgICAgICAgICAgICAgZWxpZiBpdGVtKCdlcGcnKVswXS5zdHJpbmcgPiAxOgogICAgICAgICAgICAgICAgICAgICAgICBuYW1lICs9IGdldGVwZyhpdGVtKCdlcGcnKVswXS5zdHJpbmcpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgYWRkb25fbG9nKCdFUEcgRXJyb3InKQogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICB1cmwgPSBbXQogICAgICAgICAgICAgICAgaWYgbGVuKGl0ZW0oJ2xpbmsnKSkgPjA6CiAgICAgICAgICAgICAgICAgICAgI3ByaW50ICdpdGVtIGxpbmsnLCBpdGVtKCdsaW5rJykKCiAgICAgICAgICAgICAgICAgICAgZm9yIGkgaW4gaXRlbSgnbGluaycpOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBub3QgaS5zdHJpbmcgPT0gTm9uZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybC5hcHBlbmQoaS5zdHJpbmcpCgogICAgICAgICAgICAgICAgZWxpZiBsZW4oaXRlbSgnc3BvcnRzZGV2aWwnKSkgPjA6CiAgICAgICAgICAgICAgICAgICAgZm9yIGkgaW4gaXRlbSgnc3BvcnRzZGV2aWwnKToKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm90IGkuc3RyaW5nID09IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcG9ydHNkZXZpbCA9ICdwbHVnaW46Ly9wbHVnaW4udmlkZW8uU3BvcnRzRGV2aWwvP21vZGU9MSZhbXA7aXRlbT1jYXRjaGVyJTNkc3RyZWFtcyUyNnVybD0nICtpLnN0cmluZyArJyUyNnZpZGVvVGl0bGU9JyArbmFtZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlciA9IGl0ZW0oJ3JlZmVyZXInKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHJlZmVyZXI6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50ICdyZWZlcmVyIGZvdW5kJwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwb3J0c2RldmlsID0gc3BvcnRzZGV2aWwgKyAnJTI2cmVmZXJlcj0nICtyZWZlcmVyCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybC5hcHBlbmQoc3BvcnRzZGV2aWwpCiAgICAgICAgICAgICAgICBlbGlmIGxlbihpdGVtKCdwMnAnKSkgPjA6CiAgICAgICAgICAgICAgICAgICAgZm9yIGkgaW4gaXRlbSgncDJwJyk6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCBpLnN0cmluZyA9PSBOb25lOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgJ3NvcDovLycgaW4gaS5zdHJpbmc6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29wID0gJ3BsdWdpbjovL3BsdWdpbi52aWRlby5wMnAtc3RyZWFtcy8/bW9kZT0ydXJsPScraS5zdHJpbmcgKycmJyArICduYW1lPScrbmFtZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybC5hcHBlbmQoc29wKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMnA9J3BsdWdpbjovL3BsdWdpbi52aWRlby5wMnAtc3RyZWFtcy8/bW9kZT0xJnVybD0nK2kuc3RyaW5nICsnJicgKyAnbmFtZT0nK25hbWUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwuYXBwZW5kKHAycCkKICAgICAgICAgICAgICAgIGVsaWYgbGVuKGl0ZW0oJ3ZhdWdobicpKSA+MDoKICAgICAgICAgICAgICAgICAgICBmb3IgaSBpbiBpdGVtKCd2YXVnaG4nKToKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm90IGkuc3RyaW5nID09IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXVnaG4gPSAncGx1Z2luOi8vcGx1Z2luLnN0cmVhbS52YXVnaG5saXZlLnR2Lz9tb2RlPVBsYXlMaXZlU3RyZWFtJmFtcDtjaGFubmVsPScraS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybC5hcHBlbmQodmF1Z2huKQogICAgICAgICAgICAgICAgZWxpZiBsZW4oaXRlbSgnaWxpdmUnKSkgPjA6CiAgICAgICAgICAgICAgICAgICAgZm9yIGkgaW4gaXRlbSgnaWxpdmUnKToKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm90IGkuc3RyaW5nID09IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBub3QgJ2h0dHAnIGluIGkuc3RyaW5nOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlsaXZlID0gJ3BsdWdpbjovL3BsdWdpbi52aWRlby50YmguaWxpdmUvP3VybD1odHRwOi8vd3d3LnN0cmVhbWxpdmUudG8vdmlldy8nK2kuc3RyaW5nKycmYW1wO2xpbms9OTkmYW1wO21vZGU9aUxpdmVQbGF5JwogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbGl2ZSA9ICdwbHVnaW46Ly9wbHVnaW4udmlkZW8udGJoLmlsaXZlLz91cmw9JytpLnN0cmluZysnJmFtcDtsaW5rPTk5JmFtcDttb2RlPWlMaXZlUGxheScKICAgICAgICAgICAgICAgIGVsaWYgbGVuKGl0ZW0oJ3l0LWRsJykpID4wOgogICAgICAgICAgICAgICAgICAgIGZvciBpIGluIGl0ZW0oJ3l0LWRsJyk6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCBpLnN0cmluZyA9PSBOb25lOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgeXRkbCA9IGkuc3RyaW5nICsgJyZtb2RlPTE4JwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsLmFwcGVuZCh5dGRsKQogICAgICAgICAgICAgICAgZWxpZiBsZW4oaXRlbSgnZG0nKSkgPjA6CiAgICAgICAgICAgICAgICAgICAgZm9yIGkgaW4gaXRlbSgnZG0nKToKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm90IGkuc3RyaW5nID09IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbSA9ICJwbHVnaW46Ly9wbHVnaW4udmlkZW8uZGFpbHltb3Rpb25fY29tLz9tb2RlPXBsYXlWaWRlbyZ1cmw9IiArIGkuc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwuYXBwZW5kKGRtKQogICAgICAgICAgICAgICAgZWxpZiBsZW4oaXRlbSgnZG1saXZlJykpID4wOgogICAgICAgICAgICAgICAgICAgIGZvciBpIGluIGl0ZW0oJ2RtbGl2ZScpOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBub3QgaS5zdHJpbmcgPT0gTm9uZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRtID0gInBsdWdpbjovL3BsdWdpbi52aWRlby5kYWlseW1vdGlvbl9jb20vP21vZGU9cGxheUxpdmVWaWRlbyZ1cmw9IiArIGkuc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwuYXBwZW5kKGRtKQogICAgICAgICAgICAgICAgZWxpZiBsZW4oaXRlbSgndXR1YmUnKSkgPjA6CiAgICAgICAgICAgICAgICAgICAgZm9yIGkgaW4gaXRlbSgndXR1YmUnKToKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm90IGkuc3RyaW5nID09IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAnICcgaW4gaS5zdHJpbmcgOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0dWJlID0gJ3BsdWdpbjovL3BsdWdpbi52aWRlby55b3V0dWJlL3NlYXJjaC8/cT0nKyB1cmxsaWIucXVvdGVfcGx1cyhpLnN0cmluZykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0pzb25ycGM9dXR1YmUKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsaWYgbGVuKGkuc3RyaW5nKSA9PSAxMToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dHViZSA9ICdwbHVnaW46Ly9wbHVnaW4udmlkZW8ueW91dHViZS9wbGF5Lz92aWRlb19pZD0nKyBpLnN0cmluZwogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxpZiAoaS5zdHJpbmcuc3RhcnRzd2l0aCgnUEwnKSBhbmQgbm90ICcmb3JkZXI9JyBpbiBpLnN0cmluZykgb3IgaS5zdHJpbmcuc3RhcnRzd2l0aCgnVVUnKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dHViZSA9ICdwbHVnaW46Ly9wbHVnaW4udmlkZW8ueW91dHViZS9wbGF5Lz8mb3JkZXI9ZGVmYXVsdCZwbGF5bGlzdF9pZD0nICsgaS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsaWYgaS5zdHJpbmcuc3RhcnRzd2l0aCgnUEwnKSBvciBpLnN0cmluZy5zdGFydHN3aXRoKCdVVScpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0dWJlID0gJ3BsdWdpbjovL3BsdWdpbi52aWRlby55b3V0dWJlL3BsYXkvP3BsYXlsaXN0X2lkPScgKyBpLnN0cmluZwogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxpZiBpLnN0cmluZy5zdGFydHN3aXRoKCdVQycpIGFuZCBsZW4oaS5zdHJpbmcpID4gMTI6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXR1YmUgPSAncGx1Z2luOi8vcGx1Z2luLnZpZGVvLnlvdXR1YmUvY2hhbm5lbC8nICsgaS5zdHJpbmcgKyAnLycKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0pzb25ycGM9dXR1YmUKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsaWYgbm90IGkuc3RyaW5nLnN0YXJ0c3dpdGgoJ1VDJykgYW5kIG5vdCAoaS5zdHJpbmcuc3RhcnRzd2l0aCgnUEwnKSkgIDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dHViZSA9ICdwbHVnaW46Ly9wbHVnaW4udmlkZW8ueW91dHViZS91c2VyLycgKyBpLnN0cmluZyArICcvJwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSnNvbnJwYz11dHViZQogICAgICAgICAgICAgICAgICAgICAgICB1cmwuYXBwZW5kKHV0dWJlKQogICAgICAgICAgICAgICAgZWxpZiBsZW4oaXRlbSgnaW1kYicpKSA+MDoKICAgICAgICAgICAgICAgICAgICBmb3IgaSBpbiBpdGVtKCdpbWRiJyk6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCBpLnN0cmluZyA9PSBOb25lOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgYWRkb24uZ2V0U2V0dGluZygnZ2VuZXNpc29ycHVsc2FyJykgPT0gJzAnOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZGIgPSAncGx1Z2luOi8vcGx1Z2luLnZpZGVvLmdlbmVzaXMvP2FjdGlvbj1wbGF5JmltZGI9JytpLnN0cmluZwogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWRiID0gJ3BsdWdpbjovL3BsdWdpbi52aWRlby5wdWxzYXIvbW92aWUvdHQnK2kuc3RyaW5nKycvcGxheScKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybC5hcHBlbmQoaW1kYikKCiAgICAgICAgICAgICAgICBlbGlmIGxlbihpdGVtKCdmNG0nKSkgPjA6CiAgICAgICAgICAgICAgICAgICAgZm9yIGkgaW4gaXRlbSgnZjRtJyk6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCBpLnN0cmluZyA9PSBOb25lOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgJy5mNG0nIGluIGkuc3RyaW5nOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGY0bSA9ICdwbHVnaW46Ly9wbHVnaW4udmlkZW8uZjRtVGVzdGVyLz91cmw9Jyt1cmxsaWIucXVvdGVfcGx1cyhpLnN0cmluZykKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsaWYgJy5tM3U4JyBpbiBpLnN0cmluZzoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmNG0gPSAncGx1Z2luOi8vcGx1Z2luLnZpZGVvLmY0bVRlc3Rlci8/dXJsPScrdXJsbGliLnF1b3RlX3BsdXMoaS5zdHJpbmcpKycmYW1wO3N0cmVhbXR5cGU9SExTJwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZjRtID0gJ3BsdWdpbjovL3BsdWdpbi52aWRlby5mNG1UZXN0ZXIvP3VybD0nK3VybGxpYi5xdW90ZV9wbHVzKGkuc3RyaW5nKSsnJmFtcDtzdHJlYW10eXBlPVNJTVBMRScKICAgICAgICAgICAgICAgICAgICAgICAgdXJsLmFwcGVuZChmNG0pICAgICAgIAogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBlbGlmIGxlbihpdGVtKCdmdHYnKSkgPjA6CiAgICAgICAgICAgICAgICAgICAgZm9yIGkgaW4gaXRlbSgnZnR2Jyk6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCBpLnN0cmluZyA9PSBOb25lOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnR2ID0gJ3BsdWdpbjovL3BsdWdpbi52aWRlby5GLlQuVi8/bmFtZT0nK3VybGxpYi5xdW90ZShuYW1lKSArJyZ1cmw9JyAraS5zdHJpbmcgKycmbW9kZT0xMjUmY2hfZmFuYXJ0PW5hJwogICAgICAgICAgICAgICAgICAgICAgICB1cmwuYXBwZW5kKGZ0dikKICAgICAgICAgICAgICAgIGVsaWYgbGVuKGl0ZW0oJ3VybHNvbHZlJykpID4wOiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgZm9yIGkgaW4gaXRlbSgndXJsc29sdmUnKToKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm90IGkuc3RyaW5nID09IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IGkuc3RyaW5nICsnJm1vZGU9MTknCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwuYXBwZW5kKHJlc29sdmVyKQogICAgICAgICAgICAgICAgZWxpZiBsZW4oaXRlbSgnaW5wdXRzdHJlYW0nKSkgPjA6ICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBmb3IgaSBpbiBpdGVtKCdpbnB1dHN0cmVhbScpOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBub3QgaS5zdHJpbmcgPT0gTm9uZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzdHJlYW0gPSBpLnN0cmluZyArJyZtb2RlPTIwJwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsLmFwcGVuZChpc3RyZWFtKQogICAgICAgICAgICAgICAgZWxpZiBsZW4oaXRlbSgnc2xwcm94eScpKSA+MDoKICAgICAgICAgICAgICAgICAgICBmb3IgaSBpbiBpdGVtKCdzbHByb3h5Jyk6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCBpLnN0cmluZyA9PSBOb25lOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaXN0cmVhbSA9IGkuc3RyaW5nICsnJm1vZGU9MjInCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwuYXBwZW5kKGlzdHJlYW0pICAgICAgIAoKICAgICAgICAgICAgICAgIGlmIGxlbih1cmwpIDwgMToKICAgICAgICAgICAgICAgICAgICByYWlzZQoKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgYWRkb25fbG9nKCdFcnJvciA8bGluaz4gZWxlbWVudCwgUGFzc2luZzonK25hbWUuZW5jb2RlKCd1dGYtOCcsICdpZ25vcmUnKSkKICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGlzWE1MU291cmNlID0gaXRlbSgnZXh0ZXJuYWxsaW5rJylbMF0uc3RyaW5nCiAgICAgICAgICAgIGV4Y2VwdDogcGFzcwoKICAgICAgICAgICAgaWYgaXNYTUxTb3VyY2U6CiAgICAgICAgICAgICAgICBleHRfdXJsPVtpc1hNTFNvdXJjZV0KICAgICAgICAgICAgICAgIGlzWE1MU291cmNlPVRydWUKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGlzWE1MU291cmNlPUZhbHNlCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGlzSnNvbnJwYyA9IGl0ZW0oJ2pzb25ycGMnKVswXS5zdHJpbmcKICAgICAgICAgICAgZXhjZXB0OiBwYXNzCiAgICAgICAgICAgIGlmIGlzSnNvbnJwYzoKCiAgICAgICAgICAgICAgICBleHRfdXJsPVtpc0pzb25ycGNdCiAgICAgICAgICAgICAgICAjcHJpbnQgJ0pTT04tUlBDIGV4dF91cmwnLGV4dF91cmwKICAgICAgICAgICAgICAgIGlzSnNvbnJwYz1UcnVlCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBpc0pzb25ycGM9RmFsc2UKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgdGh1bWJuYWlsID0gaXRlbSgndGh1bWJuYWlsJylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICBpZiB0aHVtYm5haWwgPT0gTm9uZToKICAgICAgICAgICAgICAgICAgICByYWlzZQogICAgICAgICAgICAgICAgdGh1bWJuYWlsPXByb2Nlc3NQeUZ1bmN0aW9uKHRodW1ibmFpbCkKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgdGh1bWJuYWlsID0gJycKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgaWYgbm90IGl0ZW0oJ2ZhbmFydCcpOgogICAgICAgICAgICAgICAgICAgIGlmIGFkZG9uLmdldFNldHRpbmcoJ3VzZV90aHVtYicpID09ICJ0cnVlIjoKICAgICAgICAgICAgICAgICAgICAgICAgZmFuQXJ0ID0gdGh1bWJuYWlsCiAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgZmFuQXJ0ID0gZmFuYXJ0CiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIGZhbkFydCA9IGl0ZW0oJ2ZhbmFydCcpWzBdLnN0cmluZwogICAgICAgICAgICAgICAgaWYgZmFuQXJ0ID09IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgcmFpc2UKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgZmFuQXJ0ID0gZmFuYXJ0CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGRlc2MgPSBpdGVtKCdpbmZvJylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICBpZiBkZXNjID09IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgcmFpc2UKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgZGVzYyA9ICcnCgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBnZW5yZSA9IGl0ZW0oJ2dlbnJlJylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICBpZiBnZW5yZSA9PSBOb25lOgogICAgICAgICAgICAgICAgICAgIHJhaXNlCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgIGdlbnJlID0gJycKCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGRhdGUgPSBpdGVtKCdkYXRlJylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICBpZiBkYXRlID09IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgcmFpc2UKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgZGF0ZSA9ICcnCgogICAgICAgICAgICByZWdleHMgPSBOb25lCiAgICAgICAgICAgIGlmIGl0ZW0oJ3JlZ2V4Jyk6CiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgcmVnX2l0ZW0gPSBpdGVtKCdyZWdleCcpCiAgICAgICAgICAgICAgICAgICAgcmVnZXhzID0gcGFyc2VfcmVnZXgocmVnX2l0ZW0pCiAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGlmIGxlbih1cmwpID4gMToKICAgICAgICAgICAgICAgICAgICBhbHQgPSAwCiAgICAgICAgICAgICAgICAgICAgcGxheWxpc3QgPSBbXQogICAgICAgICAgICAgICAgICAgIGlnbm9yZWxpc3RzZXR0aW5nPVRydWUgaWYgJyQkTFNQbGF5T25seU9uZSQkJyBpbiB1cmxbMF0gZWxzZSBGYWxzZQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGZvciBpIGluIHVybDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICBhZGRfcGxheWxpc3QgPT0gImZhbHNlIiBhbmQgbm90IGlnbm9yZWxpc3RzZXR0aW5nOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdCArPSAxCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkTGluayhpLCclcykgJXMnICUoYWx0LCBuYW1lLmVuY29kZSgndXRmLTgnLCAnaWdub3JlJykpLHRodW1ibmFpbCxmYW5BcnQsZGVzYyxnZW5yZSxkYXRlLFRydWUscGxheWxpc3QscmVnZXhzLHRvdGFsKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxpZiAgKGFkZF9wbGF5bGlzdCA9PSAidHJ1ZSIgYW5kICBhc2tfcGxheWxpc3RfaXRlbXMgPT0gJ3RydWUnKSBvciBpZ25vcmVsaXN0c2V0dGluZzoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiByZWdleHM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlsaXN0LmFwcGVuZChpKycmcmVnZXhzPScrcmVnZXhzKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsaWYgIGFueSh4IGluIGkgZm9yIHggaW4gcmVzb2x2ZV91cmwpIGFuZCAgaS5zdGFydHN3aXRoKCdodHRwJyk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlsaXN0LmFwcGVuZChpKycmbW9kZT0xOScpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxheWxpc3QuYXBwZW5kKGkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlsaXN0LmFwcGVuZChpKQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGlmIGxlbihwbGF5bGlzdCkgPiAxOiAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICBhZGRMaW5rKCcnLCBuYW1lLmVuY29kZSgndXRmLTgnKSx0aHVtYm5haWwsZmFuQXJ0LGRlc2MsZ2VucmUsZGF0ZSxUcnVlLHBsYXlsaXN0LHJlZ2V4cyx0b3RhbCkKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgaWYgZG9udExpbms6CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLHVybFswXSxyZWdleHMKICAgICAgICAgICAgICAgICAgICBpZiBpc1hNTFNvdXJjZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCByZWdleHMgPT0gTm9uZTogIzxleHRlcm5hbGxpbms+IGFuZCA8cmVnZXg+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGlyKG5hbWUuZW5jb2RlKCd1dGYtOCcpLGV4dF91cmxbMF0uZW5jb2RlKCd1dGYtOCcpLDEsdGh1bWJuYWlsLGZhbkFydCxkZXNjLGdlbnJlLGRhdGUsTm9uZSwnISF1cGRhdGUnLHJlZ2V4cyx1cmxbMF0uZW5jb2RlKCd1dGYtOCcpKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICNhZGRMaW5rKHVybFswXSxuYW1lLmVuY29kZSgndXRmLTgnLCAnaWdub3JlJykrICAnW0NPTE9SIHllbGxvd11idWlsZCBYTUxbL0NPTE9SXScsdGh1bWJuYWlsLGZhbkFydCxkZXNjLGdlbnJlLGRhdGUsVHJ1ZSxOb25lLHJlZ2V4cyx0b3RhbCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGlyKG5hbWUuZW5jb2RlKCd1dGYtOCcpLGV4dF91cmxbMF0uZW5jb2RlKCd1dGYtOCcpLDEsdGh1bWJuYWlsLGZhbkFydCxkZXNjLGdlbnJlLGRhdGUsTm9uZSwnc291cmNlJyxOb25lLE5vbmUpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI2FkZERpcihuYW1lLmVuY29kZSgndXRmLTgnKSx1cmxbMF0uZW5jb2RlKCd1dGYtOCcpLDEsdGh1bWJuYWlsLGZhbmFydCxkZXNjLGdlbnJlLGRhdGUsTm9uZSwnc291cmNlJykKICAgICAgICAgICAgICAgICAgICBlbGlmIGlzSnNvbnJwYzoKICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGlyKG5hbWUuZW5jb2RlKCd1dGYtOCcpLGV4dF91cmxbMF0sNTMsdGh1bWJuYWlsLGZhbkFydCxkZXNjLGdlbnJlLGRhdGUsTm9uZSwnc291cmNlJykKICAgICAgICAgICAgICAgICAgICAgICAgI3hibWMuZXhlY3V0ZWJ1aWx0aW4oIkNvbnRhaW5lci5TZXRWaWV3TW9kZSg1MDApIikKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAnJGRvcmVnZXgnIGluIG5hbWUgYW5kIG5vdCBnZXRSZWdleFBhcnNlZD09Tm9uZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bmFtZSxzZXRyZXM9Z2V0UmVnZXhQYXJzZWQocmVnZXhzLCBuYW1lKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCB0bmFtZT09Tm9uZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT10bmFtZQogICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgJyRkb3JlZ2V4JyBpbiB0aHVtYm5haWwgYW5kIG5vdCBnZXRSZWdleFBhcnNlZD09Tm9uZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bmFtZSxzZXRyZXM9Z2V0UmVnZXhQYXJzZWQocmVnZXhzLCB0aHVtYm5haWwpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm90IHRuYW1lPT1Ob25lOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWw9dG5hbWUKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiBwYXNzCiAgICAgICAgICAgICAgICAgICAgICAgIGFkZExpbmsodXJsWzBdLG5hbWUuZW5jb2RlKCd1dGYtOCcsICdpZ25vcmUnKSx0aHVtYm5haWwsZmFuQXJ0LGRlc2MsZ2VucmUsZGF0ZSxUcnVlLE5vbmUscmVnZXhzLHRvdGFsKQogICAgICAgICAgICAgICAgICAgICNwcmludCAnc3VjY2VzcycKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgYWRkb25fbG9nKCdUaGVyZSB3YXMgYSBwcm9ibGVtIGFkZGluZyBpdGVtIC0gJytuYW1lLmVuY29kZSgndXRmLTgnLCAnaWdub3JlJykpCgpkZWYgcGFyc2VfcmVnZXgocmVnX2l0ZW0pOgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIHJlZ2V4cyA9IHt9CiAgICAgICAgICAgICAgICAgICAgZm9yIGkgaW4gcmVnX2l0ZW06CiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4c1tpKCduYW1lJylbMF0uc3RyaW5nXSA9IHt9CiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4c1tpKCduYW1lJylbMF0uc3RyaW5nXVsnbmFtZSddPWkoJ25hbWUnKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgI3JlZ2V4c1tpKCduYW1lJylbMF0uc3RyaW5nXVsnZXhwcmVzJ10gPSBpKCdleHByZXMnKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWydleHByZXMnXSA9IGkoJ2V4cHJlcycpWzBdLnN0cmluZwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm90IHJlZ2V4c1tpKCduYW1lJylbMF0uc3RyaW5nXVsnZXhwcmVzJ106CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWydleHByZXMnXT0nJwogICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRvbl9sb2coIlJlZ2V4OiAtLSBObyBSZWZlcmVyIC0tIikKICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWydwYWdlJ10gPSBpKCdwYWdlJylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4c1tpKCduYW1lJylbMF0uc3RyaW5nXVsncmVmZXJlciddID0gaSgncmVmZXJlcicpWzBdLnN0cmluZwogICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRvbl9sb2coIlJlZ2V4OiAtLSBObyBSZWZlcmVyIC0tIikKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWydjb25uZWN0aW9uJ10gPSBpKCdjb25uZWN0aW9uJylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZG9uX2xvZygiUmVnZXg6IC0tIE5vIGNvbm5lY3Rpb24gLS0iKQoKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWydub3RwbGF5YWJsZSddID0gaSgnbm90cGxheWFibGUnKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkb25fbG9nKCJSZWdleDogLS0gTm8gbm90cGxheWFibGUgLS0iKQoKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWydub3JlZGlyZWN0J10gPSBpKCdub3JlZGlyZWN0JylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZG9uX2xvZygiUmVnZXg6IC0tIE5vIG5vcmVkaXJlY3QgLS0iKQogICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleHNbaSgnbmFtZScpWzBdLnN0cmluZ11bJ29yaWdpbiddID0gaSgnb3JpZ2luJylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZG9uX2xvZygiUmVnZXg6IC0tIE5vIG9yaWdpbiAtLSIpCiAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4c1tpKCduYW1lJylbMF0uc3RyaW5nXVsnYWNjZXB0J10gPSBpKCdhY2NlcHQnKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkb25fbG9nKCJSZWdleDogLS0gTm8gYWNjZXB0IC0tIikKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWydpbmNsdWRlaGVhZGVycyddID0gaSgnaW5jbHVkZWhlYWRlcnMnKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkb25fbG9nKCJSZWdleDogLS0gTm8gaW5jbHVkZWhlYWRlcnMgLS0iKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleHNbaSgnbmFtZScpWzBdLnN0cmluZ11bJ2xpc3RyZXBlYXQnXSA9IGkoJ2xpc3RyZXBlYXQnKVswXS5zdHJpbmcKIyAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAnbGlzdHJlcGVhdCcscmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWydsaXN0cmVwZWF0J10saSgnbGlzdHJlcGVhdCcpWzBdLnN0cmluZywgaQogICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRvbl9sb2coIlJlZ2V4OiAtLSBObyBsaXN0cmVwZWF0IC0tIikKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWydwcm94eSddID0gaSgncHJveHknKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkb25fbG9nKCJSZWdleDogLS0gTm8gcHJveHkgLS0iKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4c1tpKCduYW1lJylbMF0uc3RyaW5nXVsneC1yZXEnXSA9IGkoJ3gtcmVxJylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZG9uX2xvZygiUmVnZXg6IC0tIE5vIHgtcmVxIC0tIikKCiAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4c1tpKCduYW1lJylbMF0uc3RyaW5nXVsneC1hZGRyJ10gPSBpKCd4LWFkZHInKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkb25fbG9nKCJSZWdleDogLS0gTm8geC1hZGRyIC0tIikgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWyd4LWZvcndhcmQnXSA9IGkoJ3gtZm9yd2FyZCcpWzBdLnN0cmluZwogICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRvbl9sb2coIlJlZ2V4OiAtLSBObyB4LWZvcndhcmQgLS0iKQoKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWydhZ2VudCddID0gaSgnYWdlbnQnKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkb25fbG9nKCJSZWdleDogLS0gTm8gVXNlciBBZ2VudCAtLSIpCiAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4c1tpKCduYW1lJylbMF0uc3RyaW5nXVsncG9zdCddID0gaSgncG9zdCcpWzBdLnN0cmluZwogICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRvbl9sb2coIlJlZ2V4OiAtLSBOb3QgYSBwb3N0IikKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWydyYXdwb3N0J10gPSBpKCdyYXdwb3N0JylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZG9uX2xvZygiUmVnZXg6IC0tIE5vdCBhIHJhd3Bvc3QiKQogICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleHNbaSgnbmFtZScpWzBdLnN0cmluZ11bJ2h0bWx1bmVzY2FwZSddID0gaSgnaHRtbHVuZXNjYXBlJylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZG9uX2xvZygiUmVnZXg6IC0tIE5vdCBhIGh0bWx1bmVzY2FwZSIpCgoKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWydyZWFkY29va2llb25seSddID0gaSgncmVhZGNvb2tpZW9ubHknKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkb25fbG9nKCJSZWdleDogLS0gTm90IGEgcmVhZENvb2tpZU9ubHkiKQogICAgICAgICAgICAgICAgICAgICAgICAjcHJpbnQgaQogICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleHNbaSgnbmFtZScpWzBdLnN0cmluZ11bJ2Nvb2tpZWphciddID0gaSgnY29va2llamFyJylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBub3QgcmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWydjb29raWVqYXInXToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleHNbaSgnbmFtZScpWzBdLnN0cmluZ11bJ2Nvb2tpZWphciddPScnCiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZG9uX2xvZygiUmVnZXg6IC0tIE5vdCBhIGNvb2tpZUphciIpCiAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4c1tpKCduYW1lJylbMF0uc3RyaW5nXVsnc2V0Y29va2llJ10gPSBpKCdzZXRjb29raWUnKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkb25fbG9nKCJSZWdleDogLS0gTm90IGEgc2V0Y29va2llIikKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWydhcHBlbmRjb29raWUnXSA9IGkoJ2FwcGVuZGNvb2tpZScpWzBdLnN0cmluZwogICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRvbl9sb2coIlJlZ2V4OiAtLSBOb3QgYSBhcHBlbmRjb29raWUiKQoKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhzW2koJ25hbWUnKVswXS5zdHJpbmddWydpZ25vcmVjYWNoZSddID0gaSgnaWdub3JlY2FjaGUnKVswXS5zdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkb25fbG9nKCJSZWdleDogLS0gbm8gaWdub3JlY2FjaGUiKQogICAgICAgICAgICAgICAgICAgICAgICAjdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAjICAgIHJlZ2V4c1tpKCduYW1lJylbMF0uc3RyaW5nXVsnaWdub3JlY2FjaGUnXSA9IGkoJ2lnbm9yZWNhY2hlJylbMF0uc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgICAgICNleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICMgICAgYWRkb25fbG9nKCJSZWdleDogLS0gbm8gaWdub3JlY2FjaGUiKQoKICAgICAgICAgICAgICAgICAgICByZWdleHMgPSB1cmxsaWIucXVvdGUocmVwcihyZWdleHMpKQogICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdleHMKICAgICAgICAgICAgICAgICAgICAjcHJpbnQgcmVnZXhzCiAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgcmVnZXhzID0gTm9uZQogICAgICAgICAgICAgICAgICAgIGFkZG9uX2xvZygncmVnZXggRXJyb3I6ICcrbmFtZS5lbmNvZGUoJ3V0Zi04JywgJ2lnbm9yZScpKQojY29waWVzIGZyb20gbGFtZGEncyBpbXBsZW1lbnRhdGlvbgpkZWYgZ2V0X3VzdHJlYW0odXJsKToKICAgIHRyeToKICAgICAgICBmb3IgaSBpbiByYW5nZSgxLCA1MSk6CiAgICAgICAgICAgIHJlc3VsdCA9IGdldFVybCh1cmwpCiAgICAgICAgICAgIGlmICJFWFQtWC1TVFJFQU0tSU5GIiBpbiByZXN1bHQ6IHJldHVybiB1cmwKICAgICAgICAgICAgaWYgbm90ICJFWFRNM1UiIGluIHJlc3VsdDogcmV0dXJuCiAgICAgICAgICAgIHhibWMuc2xlZXAoMjAwMCkKICAgICAgICByZXR1cm4KICAgIGV4Y2VwdDoKICAgICAgICByZXR1cm4KCmRlZiBnZXRSZWdleFBhcnNlZChyZWdleHMsIHVybCxjb29raWVKYXI9Tm9uZSxmb3JDb29raWVKYXJPbmx5PUZhbHNlLHJlY3Vyc2l2ZUNhbGw9RmFsc2UsY2FjaGVkUGFnZXM9e30sIHJhd1Bvc3Q9RmFsc2UsIGNvb2tpZV9qYXJfZmlsZT1Ob25lKTojMCwxLDIgPSBVUkwsIHJlZ2V4T25seSwgQ29va2llSmFyT25seQogICAgICAgIGlmIG5vdCByZWN1cnNpdmVDYWxsOgogICAgICAgICAgICByZWdleHMgPSBldmFsKHVybGxpYi51bnF1b3RlKHJlZ2V4cykpCiAgICAgICAgI2NhY2hlZFBhZ2VzID0ge30KICAgICAgICAjcHJpbnQgJ3VybCcsdXJsCiAgICAgICAgZG9SZWdleHMgPSByZS5jb21waWxlKCdcJGRvcmVnZXhcWyhbXlxdXSopXF0nKS5maW5kYWxsKHVybCkKICAgICAgICAjcHJpbnQgJ2RvUmVnZXhzJyxkb1JlZ2V4cyxyZWdleHMKICAgICAgICBzZXRyZXNvbHZlZD1UcnVlCiAgICAgICAgZm9yIGsgaW4gZG9SZWdleHM6CiAgICAgICAgICAgIGlmIGsgaW4gcmVnZXhzOgogICAgICAgICAgICAgICAgI3ByaW50ICdwcm9jZXNzaW5nICcgLGsKICAgICAgICAgICAgICAgIG0gPSByZWdleHNba10KICAgICAgICAgICAgICAgICNwcmludCBtCiAgICAgICAgICAgICAgICBjb29raWVKYXJQYXJhbT1GYWxzZQogICAgICAgICAgICAgICAgaWYgICdjb29raWVqYXInIGluIG06ICMgc28gZWl0aGVyIGNyZWF0ZSBvciByZXVzZSBleGlzdGluZyBqYXIKICAgICAgICAgICAgICAgICAgICAjcHJpbnQgJ2Nvb2tpZWphciBleGlzdHMnLG1bJ2Nvb2tpZWphciddCiAgICAgICAgICAgICAgICAgICAgY29va2llSmFyUGFyYW09bVsnY29va2llamFyJ10KICAgICAgICAgICAgICAgICAgICBpZiAgJyRkb3JlZ2V4JyBpbiBjb29raWVKYXJQYXJhbToKICAgICAgICAgICAgICAgICAgICAgICAgY29va2llSmFyPWdldFJlZ2V4UGFyc2VkKHJlZ2V4cywgbVsnY29va2llamFyJ10sY29va2llSmFyLFRydWUsIFRydWUsY2FjaGVkUGFnZXMpCiAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICBjb29raWVKYXJQYXJhbT1UcnVlCiAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgY29va2llSmFyUGFyYW09VHJ1ZQogICAgICAgICAgICAgICAgI3ByaW50ICdtW2Nvb2tpZWphcl0nLG1bJ2Nvb2tpZWphciddLGNvb2tpZUphcgogICAgICAgICAgICAgICAgaWYgY29va2llSmFyUGFyYW06CiAgICAgICAgICAgICAgICAgICAgaWYgY29va2llSmFyPT1Ob25lOgogICAgICAgICAgICAgICAgICAgICAgICAjcHJpbnQgJ2NyZWF0ZSBjb29raWUgamFyJwogICAgICAgICAgICAgICAgICAgICAgICBjb29raWVfamFyX2ZpbGU9Tm9uZQogICAgICAgICAgICAgICAgICAgICAgICBpZiAnb3BlblsnIGluIG1bJ2Nvb2tpZWphciddOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2llX2phcl9maWxlPW1bJ2Nvb2tpZWphciddLnNwbGl0KCdvcGVuWycpWzFdLnNwbGl0KCddJylbMF0KIyAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAnY29va2llSmFyIGZyb20gZmlsZSBuYW1lJyxjb29raWVfamFyX2ZpbGUKCiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZUphcj1nZXRDb29raWVKYXIoY29va2llX2phcl9maWxlKQojICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgJ2Nvb2tpZUphciBmcm9tIGZpbGUnLGNvb2tpZUphcgogICAgICAgICAgICAgICAgICAgICAgICBpZiBjb29raWVfamFyX2ZpbGU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlQ29va2llSmFyKGNvb2tpZUphcixjb29raWVfamFyX2ZpbGUpCiAgICAgICAgICAgICAgICAgICAgICAgICNpbXBvcnQgY29va2llbGliCiAgICAgICAgICAgICAgICAgICAgICAgICNjb29raWVKYXIgPSBjb29raWVsaWIuTFdQQ29va2llSmFyKCkKICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50ICdjb29raWVKYXIgbmV3Jyxjb29raWVKYXIKICAgICAgICAgICAgICAgICAgICBlbGlmICdzYXZlWycgaW4gbVsnY29va2llamFyJ106CiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZV9qYXJfZmlsZT1tWydjb29raWVqYXInXS5zcGxpdCgnc2F2ZVsnKVsxXS5zcGxpdCgnXScpWzBdCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlX3BhdGg9b3MucGF0aC5qb2luKHByb2ZpbGUsY29va2llX2phcl9maWxlKQojICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgJ2NvbXBsZXRlX3BhdGgnLGNvbXBsZXRlX3BhdGgKICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZUNvb2tpZUphcihjb29raWVKYXIsY29va2llX2phcl9maWxlKQogICAgICAgICAgICAgICAgaWYgIG1bJ3BhZ2UnXSBhbmQgJyRkb3JlZ2V4JyBpbiBtWydwYWdlJ106CiAgICAgICAgICAgICAgICAgICAgcGc9Z2V0UmVnZXhQYXJzZWQocmVnZXhzLCBtWydwYWdlJ10sY29va2llSmFyLHJlY3Vyc2l2ZUNhbGw9VHJ1ZSxjYWNoZWRQYWdlcz1jYWNoZWRQYWdlcykKICAgICAgICAgICAgICAgICAgICBpZiBsZW4ocGcpPT0wOgogICAgICAgICAgICAgICAgICAgICAgICBwZz0naHR0cDovL3JlZ2V4ZmFpbGVkJwogICAgICAgICAgICAgICAgICAgIG1bJ3BhZ2UnXT1wZwoKICAgICAgICAgICAgICAgIGlmICdzZXRjb29raWUnIGluIG0gYW5kIG1bJ3NldGNvb2tpZSddIGFuZCAnJGRvcmVnZXgnIGluIG1bJ3NldGNvb2tpZSddOgogICAgICAgICAgICAgICAgICAgIG1bJ3NldGNvb2tpZSddPWdldFJlZ2V4UGFyc2VkKHJlZ2V4cywgbVsnc2V0Y29va2llJ10sY29va2llSmFyLHJlY3Vyc2l2ZUNhbGw9VHJ1ZSxjYWNoZWRQYWdlcz1jYWNoZWRQYWdlcykKICAgICAgICAgICAgICAgIGlmICdhcHBlbmRjb29raWUnIGluIG0gYW5kIG1bJ2FwcGVuZGNvb2tpZSddIGFuZCAnJGRvcmVnZXgnIGluIG1bJ2FwcGVuZGNvb2tpZSddOgogICAgICAgICAgICAgICAgICAgIG1bJ2FwcGVuZGNvb2tpZSddPWdldFJlZ2V4UGFyc2VkKHJlZ2V4cywgbVsnYXBwZW5kY29va2llJ10sY29va2llSmFyLHJlY3Vyc2l2ZUNhbGw9VHJ1ZSxjYWNoZWRQYWdlcz1jYWNoZWRQYWdlcykKCgogICAgICAgICAgICAgICAgaWYgICdwb3N0JyBpbiBtIGFuZCAnJGRvcmVnZXgnIGluIG1bJ3Bvc3QnXToKICAgICAgICAgICAgICAgICAgICBtWydwb3N0J109Z2V0UmVnZXhQYXJzZWQocmVnZXhzLCBtWydwb3N0J10sY29va2llSmFyLHJlY3Vyc2l2ZUNhbGw9VHJ1ZSxjYWNoZWRQYWdlcz1jYWNoZWRQYWdlcykKIyAgICAgICAgICAgICAgICAgICAgcHJpbnQgJ3Bvc3QgaXMgbm93JyxtWydwb3N0J10KCiAgICAgICAgICAgICAgICBpZiAgJ3Jhd3Bvc3QnIGluIG0gYW5kICckZG9yZWdleCcgaW4gbVsncmF3cG9zdCddOgogICAgICAgICAgICAgICAgICAgIG1bJ3Jhd3Bvc3QnXT1nZXRSZWdleFBhcnNlZChyZWdleHMsIG1bJ3Jhd3Bvc3QnXSxjb29raWVKYXIscmVjdXJzaXZlQ2FsbD1UcnVlLGNhY2hlZFBhZ2VzPWNhY2hlZFBhZ2VzLHJhd1Bvc3Q9VHJ1ZSkKICAgICAgICAgICAgICAgICAgICAjcHJpbnQgJ3Jhd3Bvc3QgaXMgbm93JyxtWydyYXdwb3N0J10KCiAgICAgICAgICAgICAgICBpZiAncmF3cG9zdCcgaW4gbSBhbmQgJyRlcG9jdGltZSQnIGluIG1bJ3Jhd3Bvc3QnXToKICAgICAgICAgICAgICAgICAgICBtWydyYXdwb3N0J109bVsncmF3cG9zdCddLnJlcGxhY2UoJyRlcG9jdGltZSQnLGdldEVwb2NUaW1lKCkpCgogICAgICAgICAgICAgICAgaWYgJ3Jhd3Bvc3QnIGluIG0gYW5kICckZXBvY3RpbWUyJCcgaW4gbVsncmF3cG9zdCddOgogICAgICAgICAgICAgICAgICAgIG1bJ3Jhd3Bvc3QnXT1tWydyYXdwb3N0J10ucmVwbGFjZSgnJGVwb2N0aW1lMiQnLGdldEVwb2NUaW1lMigpKQoKCiAgICAgICAgICAgICAgICBsaW5rPScnCiAgICAgICAgICAgICAgICBpZiBtWydwYWdlJ10gYW5kIG1bJ3BhZ2UnXSBpbiBjYWNoZWRQYWdlcyBhbmQgbm90ICdpZ25vcmVjYWNoZScgaW4gbSBhbmQgZm9yQ29va2llSmFyT25seT09RmFsc2UgOgogICAgICAgICAgICAgICAgICAgICNwcmludCAndXNpbmcgY2FjaGUgcGFnZScsbVsncGFnZSddCiAgICAgICAgICAgICAgICAgICAgbGluayA9IGNhY2hlZFBhZ2VzW21bJ3BhZ2UnXV0KICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgaWYgbVsncGFnZSddIGFuZCAgbm90IG1bJ3BhZ2UnXT09JycgYW5kICBtWydwYWdlJ10uc3RhcnRzd2l0aCgnaHR0cCcpOgogICAgICAgICAgICAgICAgICAgICAgICBpZiAnJGVwb2N0aW1lJCcgaW4gbVsncGFnZSddOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbVsncGFnZSddPW1bJ3BhZ2UnXS5yZXBsYWNlKCckZXBvY3RpbWUkJyxnZXRFcG9jVGltZSgpKQogICAgICAgICAgICAgICAgICAgICAgICBpZiAnJGVwb2N0aW1lMiQnIGluIG1bJ3BhZ2UnXToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1bJ3BhZ2UnXT1tWydwYWdlJ10ucmVwbGFjZSgnJGVwb2N0aW1lMiQnLGdldEVwb2NUaW1lMigpKQoKICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50ICdJbmdvcmluZyBDYWNoZScsbVsncGFnZSddCiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2Vfc3BsaXQ9bVsncGFnZSddLnNwbGl0KCd8JykKICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVVybD1wYWdlX3NwbGl0WzBdCiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcl9pbl9wYWdlPU5vbmUKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbGVuKHBhZ2Vfc3BsaXQpPjE6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJfaW5fcGFnZT1wYWdlX3NwbGl0WzFdCgojICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIAojICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IHVybGxpYjIuUHJveHlIYW5kbGVyKHsgKCdodHRwcycgPyBwcm94eXRvdXNlWzo1XT09Imh0dHBzIjoiaHR0cCIpIDogcHJveHl0b3VzZX0pCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyID0gdXJsbGliMi5idWlsZF9vcGVuZXIocHJveHkpCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsbGliMi5pbnN0YWxsX29wZW5lcihvcGVuZXIpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIAojICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0IHVybGxpYjIKIyAgICAgICAgICAgICAgICAgICAgICAgIHByaW50ICd1cmxsaWIyLmdldHByb3hpZXMnLHVybGxpYjIuZ2V0cHJveGllcygpCiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfcHJveGllcz11cmxsaWIyLlByb3h5SGFuZGxlcih1cmxsaWIyLmdldHByb3hpZXMoKSkKICAgICAgICAKICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgJ2dldHRpbmcgcGFnZVVybCcscGFnZVVybAogICAgICAgICAgICAgICAgICAgICAgICByZXEgPSB1cmxsaWIyLlJlcXVlc3QocGFnZVVybCkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgJ3Byb3h5JyBpbiBtOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHl0b3VzZT0gbVsncHJveHknXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50ICdwcm94eXRvdXNlJyxwcm94eXRvdXNlCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsbGliMi5nZXRwcm94aWVzPSBsYW1iZGE6IHt9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBwYWdlVXJsWzo1XT09Imh0dHBzIjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eSA9IHVybGxpYjIuUHJveHlIYW5kbGVyKHsgJ2h0dHBzJyA6IHByb3h5dG91c2V9KQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICNyZXEuc2V0X3Byb3h5KHByb3h5dG91c2UsICdodHRwcycpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5ID0gdXJsbGliMi5Qcm94eUhhbmRsZXIoeyAnaHR0cCcgIDogcHJveHl0b3VzZX0pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI3JlcS5zZXRfcHJveHkocHJveHl0b3VzZSwgJ2h0dHAnKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGlmIHJlLnNlYXJjaChyJ2h0dHBzPzpcL1wvLio/QC4qOlxkKycsIHByb3h5dG91c2UpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgIyAgICAgYXV0aCA9IHVybGxpYjIuSFRUUEJhc2ljQXV0aEhhbmRsZXIoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIyAgICAgb3BlbmVyID0gdXJsbGliMi5idWlsZF9vcGVuZXIocHJveHksIGF1dGgsIHVybGxpYjIuSFRUUEhhbmRsZXIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXIgPSB1cmxsaWIyLmJ1aWxkX29wZW5lcihwcm94eSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybGxpYjIuaW5zdGFsbF9vcGVuZXIob3BlbmVyKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICByZXEuYWRkX2hlYWRlcignVXNlci1BZ2VudCcsICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCA2LjE7IHJ2OjE0LjApIEdlY2tvLzIwMTAwMTAxIEZpcmVmb3gvMTQuMC4xJykKICAgICAgICAgICAgICAgICAgICAgICAgcHJveHl0b3VzZT1Ob25lCgogICAgICAgICAgICAgICAgICAgICAgICBpZiAncmVmZXJlcicgaW4gbToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5hZGRfaGVhZGVyKCdSZWZlcmVyJywgbVsncmVmZXJlciddKQogICAgICAgICAgICAgICAgICAgICAgICBpZiAnYWNjZXB0JyBpbiBtOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmFkZF9oZWFkZXIoJ0FjY2VwdCcsIG1bJ2FjY2VwdCddKQogICAgICAgICAgICAgICAgICAgICAgICBpZiAnYWdlbnQnIGluIG06CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEuYWRkX2hlYWRlcignVXNlci1hZ2VudCcsIG1bJ2FnZW50J10pCiAgICAgICAgICAgICAgICAgICAgICAgIGlmICd4LXJlcScgaW4gbToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5hZGRfaGVhZGVyKCdYLVJlcXVlc3RlZC1XaXRoJywgbVsneC1yZXEnXSkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgJ3gtYWRkcicgaW4gbToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5hZGRfaGVhZGVyKCd4LWFkZHInLCBtWyd4LWFkZHInXSkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgJ3gtZm9yd2FyZCcgaW4gbToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5hZGRfaGVhZGVyKCdYLUZvcndhcmRlZC1Gb3InLCBtWyd4LWZvcndhcmQnXSkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgJ3NldGNvb2tpZScgaW4gbToKIyAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAnYWRkaW5nIGNvb2tpZScsbVsnc2V0Y29va2llJ10KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5hZGRfaGVhZGVyKCdDb29raWUnLCBtWydzZXRjb29raWUnXSkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgJ2FwcGVuZGNvb2tpZScgaW4gbToKIyAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAnYXBwZW5kaW5nIGNvb2tpZSB0byBjb29raWVqYXInLG1bJ2FwcGVuZGNvb2tpZSddCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29raWVzdG9BcGVuZD1tWydhcHBlbmRjb29raWUnXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2llc3RvQXBlbmQ9Y29va2llc3RvQXBlbmQuc3BsaXQoJzsnKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGggaW4gY29va2llc3RvQXBlbmQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbix2PWguc3BsaXQoJz0nKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcsbj0gbi5zcGxpdCgnOicpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2sgPSBjb29raWVsaWIuQ29va2llKHZlcnNpb249MCwgbmFtZT1uLCB2YWx1ZT12LCBwb3J0PU5vbmUsIHBvcnRfc3BlY2lmaWVkPUZhbHNlLCBkb21haW49dywgZG9tYWluX3NwZWNpZmllZD1GYWxzZSwgZG9tYWluX2luaXRpYWxfZG90PUZhbHNlLCBwYXRoPScvJywgcGF0aF9zcGVjaWZpZWQ9VHJ1ZSwgc2VjdXJlPUZhbHNlLCBleHBpcmVzPU5vbmUsIGRpc2NhcmQ9VHJ1ZSwgY29tbWVudD1Ob25lLCBjb21tZW50X3VybD1Ob25lLCByZXN0PXsnSHR0cE9ubHknOiBOb25lfSwgcmZjMjEwOT1GYWxzZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29raWVKYXIuc2V0X2Nvb2tpZShjaykKICAgICAgICAgICAgICAgICAgICAgICAgaWYgJ29yaWdpbicgaW4gbToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5hZGRfaGVhZGVyKCdPcmlnaW4nLCBtWydvcmlnaW4nXSkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgaGVhZGVyX2luX3BhZ2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJfaW5fcGFnZT1oZWFkZXJfaW5fcGFnZS5zcGxpdCgnJicpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgaCBpbiBoZWFkZXJfaW5fcGFnZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBoLnNwbGl0KCc9Jyk9PTI6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4sdj1oLnNwbGl0KCc9JykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxzPWguc3BsaXQoJz0nKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuPXZhbHNbMF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdj0nPScuam9pbih2YWxzWzE6XSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjbix2PWguc3BsaXQoJz0nKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5hZGRfaGVhZGVyKG4sdikKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCBjb29raWVKYXI9PU5vbmU6CiMgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgJ2Nvb2tpZUphclZhbCcsY29va2llSmFyCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29raWVfaGFuZGxlciA9IHVybGxpYjIuSFRUUENvb2tpZVByb2Nlc3Nvcihjb29raWVKYXIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXIgPSB1cmxsaWIyLmJ1aWxkX29wZW5lcihjb29raWVfaGFuZGxlciwgdXJsbGliMi5IVFRQQmFzaWNBdXRoSGFuZGxlcigpLCB1cmxsaWIyLkhUVFBIYW5kbGVyKCkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXIgPSB1cmxsaWIyLmluc3RhbGxfb3BlbmVyKG9wZW5lcikKIyAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAnbm9yZWRpcmVjdCcsJ25vcmVkaXJlY3QnIGluIG0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgJ25vcmVkaXJlY3QnIGluIG06CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyID0gdXJsbGliMi5idWlsZF9vcGVuZXIoY29va2llX2hhbmRsZXIsTm9SZWRpcmVjdGlvbiwgdXJsbGliMi5IVFRQQmFzaWNBdXRoSGFuZGxlcigpLCB1cmxsaWIyLkhUVFBIYW5kbGVyKCkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyID0gdXJsbGliMi5pbnN0YWxsX29wZW5lcihvcGVuZXIpCiAgICAgICAgICAgICAgICAgICAgICAgIGVsaWYgJ25vcmVkaXJlY3QnIGluIG06CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXIgPSB1cmxsaWIyLmJ1aWxkX29wZW5lcihOb1JlZGlyZWN0aW9uLCB1cmxsaWIyLkhUVFBCYXNpY0F1dGhIYW5kbGVyKCksIHVybGxpYjIuSFRUUEhhbmRsZXIoKSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lciA9IHVybGxpYjIuaW5zdGFsbF9vcGVuZXIob3BlbmVyKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICBpZiAnY29ubmVjdGlvbicgaW4gbToKIyAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAnLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5jb25uZWN0aW9uLy8vLy8vLicsbVsnY29ubmVjdGlvbiddCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIGtlZXBhbGl2ZSBpbXBvcnQgSFRUUEhhbmRsZXIKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBhbGl2ZV9oYW5kbGVyID0gSFRUUEhhbmRsZXIoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyID0gdXJsbGliMi5idWlsZF9vcGVuZXIoa2VlcGFsaXZlX2hhbmRsZXIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmxsaWIyLmluc3RhbGxfb3BlbmVyKG9wZW5lcikKCgogICAgICAgICAgICAgICAgICAgICAgICAjcHJpbnQgJ2FmdGVyIGNvb2tpZSBqYXInCiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Q9Tm9uZQoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgJ3Bvc3QnIGluIG06CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0RGF0YT1tWydwb3N0J10KICAgICAgICAgICAgICAgICAgICAgICAgICAgICNpZiAnJExpdmVTdHJlYW1SZWNhcHRjaGEnIGluIHBvc3REYXRhOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgIyAgICAoY2FwdGNoYV9jaGFsbGVuZ2UsY2F0cGNoYV93b3JkLGlkZmllbGQpPXByb2Nlc3NSZWNhcHRjaGEobVsncGFnZSddLGNvb2tpZUphcikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgICAgaWYgY2FwdGNoYV9jaGFsbGVuZ2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjICAgICAgICBwb3N0RGF0YT1wb3N0RGF0YS5yZXBsYWNlKCckTGl2ZVN0cmVhbVJlY2FwdGNoYScsJ21hbnVhbF9yZWNhcHRjaGFfY2hhbGxlbmdlX2ZpZWxkOicrY2FwdGNoYV9jaGFsbGVuZ2UrJyxyZWNhcHRjaGFfcmVzcG9uc2VfZmllbGQ6JytjYXRwY2hhX3dvcmQrJyxpZDonK2lkZmllbGQpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdHBvc3Q9cG9zdERhdGEuc3BsaXQoJywnKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdD17fQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHAgaW4gc3BsaXRwb3N0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG49cC5zcGxpdCgnOicpWzBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdj1wLnNwbGl0KCc6JylbMV0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0W25dPXYKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3QgPSB1cmxsaWIudXJsZW5jb2RlKHBvc3QpCgogICAgICAgICAgICAgICAgICAgICAgICBpZiAncmF3cG9zdCcgaW4gbToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Q9bVsncmF3cG9zdCddCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjaWYgJyRMaXZlU3RyZWFtUmVjYXB0Y2hhJyBpbiBwb3N0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgIyAgICAoY2FwdGNoYV9jaGFsbGVuZ2UsY2F0cGNoYV93b3JkLGlkZmllbGQpPXByb2Nlc3NSZWNhcHRjaGEobVsncGFnZSddLGNvb2tpZUphcikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgICAgaWYgY2FwdGNoYV9jaGFsbGVuZ2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjICAgICAgIHBvc3Q9cG9zdC5yZXBsYWNlKCckTGl2ZVN0cmVhbVJlY2FwdGNoYScsJyZtYW51YWxfcmVjYXB0Y2hhX2NoYWxsZW5nZV9maWVsZD0nK2NhcHRjaGFfY2hhbGxlbmdlKycmcmVjYXB0Y2hhX3Jlc3BvbnNlX2ZpZWxkPScrY2F0cGNoYV93b3JkKycmaWQ9JytpZGZpZWxkKQogICAgICAgICAgICAgICAgICAgICAgICBsaW5rPScnCiAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgcG9zdDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHVybGxpYjIudXJsb3BlbihyZXEscG9zdCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB1cmxsaWIyLnVybG9wZW4ocmVxKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgcmVzcG9uc2UuaW5mbygpLmdldCgnQ29udGVudC1FbmNvZGluZycpID09ICdnemlwJzoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIFN0cmluZ0lPIGltcG9ydCBTdHJpbmdJTwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydCBnemlwCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmID0gU3RyaW5nSU8oIHJlc3BvbnNlLnJlYWQoKSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gZ3ppcC5HemlwRmlsZShmaWxlb2JqPWJ1ZikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rID0gZi5yZWFkKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluaz1yZXNwb25zZS5yZWFkKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAncHJveHknIGluIG0gYW5kIG5vdCBjdXJyZW50X3Byb3hpZXMgaXMgTm9uZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmxsaWIyLmluc3RhbGxfb3BlbmVyKHVybGxpYjIuYnVpbGRfb3BlbmVyKGN1cnJlbnRfcHJveGllcykpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbms9amF2YXNjcmlwdFVuRXNjYXBlKGxpbmspCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjcHJpbnQgcmVwcihsaW5rKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50IGxpbmsgVGhpcyBqdXN0IHByaW50IHdob2xlIHdlYnBhZ2UgaW4gTE9HCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAnaW5jbHVkZWhlYWRlcnMnIGluIG06CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI2xpbmsrPXN0cihyZXNwb25zZS5oZWFkZXJzLmdldCgnU2V0LUNvb2tpZScpKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsrPSckJEhFQURFUlNfU1RBUlQkJDonCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGIgaW4gcmVzcG9uc2UuaGVhZGVyczoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluays9IGIrJzonK3Jlc3BvbnNlLmhlYWRlcnMuZ2V0KGIpKydcbicKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rKz0nJCRIRUFERVJTX0VORCQkOicKICAgICMgICAgICAgICAgICAgICAgICAgICAgICBwcmludCBsaW5rCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRvbl9sb2cobGluaykKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZG9uX2xvZyhjb29raWVKYXIgKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmNsb3NlKCkKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkUGFnZXNbbVsncGFnZSddXSA9IGxpbmsKICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50IGxpbmsKICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50ICdzdG9yZSBsaW5rIGZvcicsbVsncGFnZSddLGZvckNvb2tpZUphck9ubHkKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGZvckNvb2tpZUphck9ubHk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29va2llSmFyIyBkbyBub3RoaW5nCiAgICAgICAgICAgICAgICAgICAgZWxpZiBtWydwYWdlJ10gYW5kICBub3QgbVsncGFnZSddLnN0YXJ0c3dpdGgoJ2h0dHAnKToKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbVsncGFnZSddLnN0YXJ0c3dpdGgoJyRweUZ1bmN0aW9uOicpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsPWRvRXZhbChtWydwYWdlJ10uc3BsaXQoJyRweUZ1bmN0aW9uOicpWzFdLCcnLGNvb2tpZUphcixtICkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGZvckNvb2tpZUphck9ubHk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvb2tpZUphciMgZG8gbm90aGluZwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluaz12YWwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbms9amF2YXNjcmlwdFVuRXNjYXBlKGxpbmspCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rPW1bJ3BhZ2UnXQoKICAgICAgICAgICAgICAgIGlmICckcHlGdW5jdGlvbjpwbGF5bWVkaWEoJyBpbiBtWydleHByZXMnXSBvciAnQWN0aXZhdGVXaW5kb3cnICBpbiBtWydleHByZXMnXSBvciAnUnVuUGx1Z2luJyAgaW4gbVsnZXhwcmVzJ10gIG9yICckUExBWUVSUFJPWFkkPScgaW4gdXJsICBvciAgYW55KHggaW4gdXJsIGZvciB4IGluIGdfaWdub3JlU2V0UmVzb2x2ZWQpOgogICAgICAgICAgICAgICAgICAgIHNldHJlc29sdmVkPUZhbHNlCiAgICAgICAgICAgICAgICBpZiAgJyRkb3JlZ2V4JyBpbiBtWydleHByZXMnXToKICAgICAgICAgICAgICAgICAgICBtWydleHByZXMnXT1nZXRSZWdleFBhcnNlZChyZWdleHMsIG1bJ2V4cHJlcyddLGNvb2tpZUphcixyZWN1cnNpdmVDYWxsPVRydWUsY2FjaGVkUGFnZXM9Y2FjaGVkUGFnZXMpCiAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYgbm90IG1bJ2V4cHJlcyddPT0nJzoKICAgICAgICAgICAgICAgICAgICAjcHJpbnQgJ2RvaW5nIGl0ICcsbVsnZXhwcmVzJ10KICAgICAgICAgICAgICAgICAgICBpZiAnJExpdmVTdHJlYW1DYXB0Y2hhJyBpbiBtWydleHByZXMnXToKICAgICAgICAgICAgICAgICAgICAgICAgdmFsPWFza0NhcHRjaGEobSxsaW5rLGNvb2tpZUphcikKICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50ICd1cmwgYW5kIHZhbCcsdXJsLHZhbAogICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgiJGRvcmVnZXhbIiArIGsgKyAiXSIsIHZhbCkKCiAgICAgICAgICAgICAgICAgICAgZWxpZiBtWydleHByZXMnXS5zdGFydHN3aXRoKCckcHlGdW5jdGlvbjonKSBvciAnIyRweUZ1bmN0aW9uJyBpbiBtWydleHByZXMnXToKICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50ICdleHBlZWVlZWVlZWVlZWVlZWVlZWVlJyxtWydleHByZXMnXQogICAgICAgICAgICAgICAgICAgICAgICB2YWw9JycKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbVsnZXhwcmVzJ10uc3RhcnRzd2l0aCgnJHB5RnVuY3Rpb246Jyk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw9ZG9FdmFsKG1bJ2V4cHJlcyddLnNwbGl0KCckcHlGdW5jdGlvbjonKVsxXSxsaW5rLGNvb2tpZUphcixtKQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsPWRvRXZhbEZ1bmN0aW9uKG1bJ2V4cHJlcyddLGxpbmssY29va2llSmFyLG0pCiAgICAgICAgICAgICAgICAgICAgICAgIGlmICdBY3RpdmF0ZVdpbmRvdycgaW4gbVsnZXhwcmVzJ10gb3IgJ1J1blBsdWdpbicgaW4gbVsnZXhwcmVzJ10gIDogcmV0dXJuICcnLEZhbHNlCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGZvckNvb2tpZUphck9ubHk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29va2llSmFyIyBkbyBub3RoaW5nCiAgICAgICAgICAgICAgICAgICAgICAgIGlmICdsaXN0cmVwZWF0JyBpbiBtOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdHJlcGVhdD1tWydsaXN0cmVwZWF0J10gICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjcmV0PXJlLmZpbmRhbGwobVsnZXhwcmVzJ10sbGluaykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICNwcmludCAncmV0Jyx2YWwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0cmVwZWF0LGV2YWwodmFsKSwgbSxyZWdleHMsY29va2llSmFyCiMgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAndXJsIGsgdmFsJyx1cmwsayx2YWwKICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50ICdyZXByJyxyZXByKHZhbCkKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKHUiJGRvcmVnZXhbIiArIGsgKyAiXSIsIHZhbCkKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiB1cmwgPSB1cmwucmVwbGFjZSgiJGRvcmVnZXhbIiArIGsgKyAiXSIsIHZhbC5kZWNvZGUoInV0Zi04IikpCiAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgaWYgJ2xpc3RyZXBlYXQnIGluIG06CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0cmVwZWF0PW1bJ2xpc3RyZXBlYXQnXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50ICdsaXN0cmVwZWF0JyxtWydleHByZXMnXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50IG1bJ2V4cHJlcyddCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjcHJpbnQgJ2FhYWEnCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjcHJpbnQgbGluawogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0PXJlLmZpbmRhbGwobVsnZXhwcmVzJ10sbGluaykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICNwcmludCAncmV0JyxyZXQKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0cmVwZWF0LHJldCwgbSxyZWdleHMsY29va2llSmFyCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIHZhbD0nJwogICAgICAgICAgICAgICAgICAgICAgICBpZiBub3QgbGluaz09Jyc6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjcHJpbnQgJ2xpbmsnLGxpbmsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZyA9IHJlLmNvbXBpbGUobVsnZXhwcmVzJ10pLnNlYXJjaChsaW5rKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw9cmVnLmdyb3VwKDEpLnN0cmlwKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDogdHJhY2ViYWNrLnByaW50X2V4YygpCiAgICAgICAgICAgICAgICAgICAgICAgIGVsaWYgbVsncGFnZSddPT0nJyBvciBtWydwYWdlJ109PU5vbmU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw9bVsnZXhwcmVzJ10KICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICBpZiByYXdQb3N0OgojICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50ICdyYXdwb3N0JwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsPXVybGxpYi5xdW90ZV9wbHVzKHZhbCkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgJ2h0bWx1bmVzY2FwZScgaW4gbToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICN2YWw9dXJsbGliLnVucXVvdGVfcGx1cyh2YWwpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnQgSFRNTFBhcnNlcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsPUhUTUxQYXJzZXIuSFRNTFBhcnNlcigpLnVuZXNjYXBlKHZhbCkKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoIiRkb3JlZ2V4WyIgKyBrICsgIl0iLCB2YWwpCiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDogdXJsID0gdXJsLnJlcGxhY2UoIiRkb3JlZ2V4WyIgKyBrICsgIl0iLCB2YWwuZGVjb2RlKCJ1dGYtOCIpKQogICAgICAgICAgICAgICAgICAgICAgICAjcHJpbnQgJ3VyJyx1cmwKICAgICAgICAgICAgICAgICAgICAgICAgI3JldHVybiB2YWwKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoIiRkb3JlZ2V4WyIgKyBrICsgIl0iLCcnKQoKICAgICAgICBpZiAnJGVwb2N0aW1lJCcgaW4gdXJsOgogICAgICAgICAgICB1cmw9dXJsLnJlcGxhY2UoJyRlcG9jdGltZSQnLGdldEVwb2NUaW1lKCkpCiAgICAgICAgaWYgJyRlcG9jdGltZTIkJyBpbiB1cmw6CiAgICAgICAgICAgIHVybD11cmwucmVwbGFjZSgnJGVwb2N0aW1lMiQnLGdldEVwb2NUaW1lMigpKQoKICAgICAgICBpZiAnJEdVSUQkJyBpbiB1cmw6CiAgICAgICAgICAgIGltcG9ydCB1dWlkCiAgICAgICAgICAgIHVybD11cmwucmVwbGFjZSgnJEdVSUQkJyxzdHIodXVpZC51dWlkMSgpKS51cHBlcigpKQogICAgICAgIGlmICckZ2V0X2Nvb2tpZXMkJyBpbiB1cmw6CiAgICAgICAgICAgIHVybD11cmwucmVwbGFjZSgnJGdldF9jb29raWVzJCcsZ2V0Q29va2llc1N0cmluZyhjb29raWVKYXIpKQoKICAgICAgICBpZiByZWN1cnNpdmVDYWxsOiByZXR1cm4gdXJsCiAgICAgICAgI3ByaW50ICdmaW5hbCB1cmwnLHJlcHIodXJsKQogICAgICAgIGlmIHVybD09IiI6CiAgICAgICAgICAgIHJldHVybgogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHJldHVybiB1cmwsc2V0cmVzb2x2ZWQKCmRlZiBnZXRtZDUodCk6CiAgICBpbXBvcnQgaGFzaGxpYgogICAgaD1oYXNobGliLm1kNSgpCiAgICBoLnVwZGF0ZSh0KQogICAgcmV0dXJuIGguaGV4ZGlnZXN0KCkKCmRlZiBkZWNyeXB0X3ZhdWdobmxpdmUoZW5jcnlwdGVkKToKICAgIHJldFZhbD0iIgojICAgIHByaW50ICdlbmMnLGVuY3J5cHRlZAogICAgI2ZvciB2YWwgaW4gZW5jcnlwdGVkLnNwbGl0KCc6Jyk6CiAgICAjICAgIHJldFZhbCs9Y2hyKGludCh2YWwucmVwbGFjZSgiMG0wIiwiIikpKQogICAgI3JldHVybiByZXRWYWwKCmRlZiBwbGF5bWVkaWEobWVkaWFfdXJsKToKICAgIHRyeToKICAgICAgICBpbXBvcnQgIEN1c3RvbVBsYXllcgogICAgICAgIHBsYXllciA9IEN1c3RvbVBsYXllci5NeVhCTUNQbGF5ZXIoKQogICAgICAgIGxpc3RpdGVtID0geGJtY2d1aS5MaXN0SXRlbSggbGFiZWwgPSBzdHIobmFtZSksIGljb25JbWFnZSA9ICJEZWZhdWx0VmlkZW8ucG5nIiwgdGh1bWJuYWlsSW1hZ2UgPSB4Ym1jLmdldEluZm9JbWFnZSggIkxpc3RJdGVtLlRodW1iIiApLCBwYXRoPW1lZGlhX3VybCApCiAgICAgICAgcGxheWVyLnBsYXkoIG1lZGlhX3VybCxsaXN0aXRlbSkKICAgICAgICB4Ym1jLnNsZWVwKDEwMDApCiAgICAgICAgd2hpbGUgcGxheWVyLmlzX2FjdGl2ZToKICAgICAgICAgICAgeGJtYy5zbGVlcCgyMDApCiAgICBleGNlcHQ6CiAgICAgICAgdHJhY2ViYWNrLnByaW50X2V4YygpCiAgICByZXR1cm4gJycKCmRlZiBrb2RpSnNvblJlcXVlc3QocGFyYW1zKToKICAgIGRhdGEgPSBqc29uLmR1bXBzKHBhcmFtcykKICAgIHJlcXVlc3QgPSB4Ym1jLmV4ZWN1dGVKU09OUlBDKGRhdGEpCgogICAgdHJ5OgogICAgICAgIHJlc3BvbnNlID0ganNvbi5sb2FkcyhyZXF1ZXN0KQogICAgZXhjZXB0IFVuaWNvZGVEZWNvZGVFcnJvcjoKICAgICAgICByZXNwb25zZSA9IGpzb24ubG9hZHMocmVxdWVzdC5kZWNvZGUoJ3V0Zi04JywgJ2lnbm9yZScpKQoKICAgIHRyeToKICAgICAgICBpZiAncmVzdWx0JyBpbiByZXNwb25zZToKICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydyZXN1bHQnXQogICAgICAgIHJldHVybiBOb25lCiAgICBleGNlcHQgS2V5RXJyb3I6CiAgICAgICAgbG9nZ2VyLndhcm4oIlslc10gJXMiICUgKHBhcmFtc1snbWV0aG9kJ10sIHJlc3BvbnNlWydlcnJvciddWydtZXNzYWdlJ10pKQogICAgICAgIHJldHVybiBOb25lCgpkZWYgc2V0S29kaVByb3h5KHByb3h5c2V0dGluZ3M9Tm9uZSk6CgogICAgaWYgcHJveHlzZXR0aW5ncz09Tm9uZToKIyAgICAgICAgcHJpbnQgJ3Byb3h5IHNldCB0byBub3RoaW5nJwogICAgICAgIHhibWMuZXhlY3V0ZUpTT05SUEMoJ3sianNvbnJwYyI6IjIuMCIsICJtZXRob2QiOiJTZXR0aW5ncy5TZXRTZXR0aW5nVmFsdWUiLCAicGFyYW1zIjp7InNldHRpbmciOiJuZXR3b3JrLnVzZWh0dHBwcm94eSIsICJ2YWx1ZSI6ZmFsc2V9LCAiaWQiOjF9JykKICAgIGVsc2U6CiAgICAgICAgCiAgICAgICAgcHM9cHJveHlzZXR0aW5ncy5zcGxpdCgnOicpCiAgICAgICAgcHJveHlVUkw9cHNbMF0KICAgICAgICBwcm94eVBvcnQ9cHNbMV0KICAgICAgICBwcm94eVR5cGU9cHNbMl0KICAgICAgICBwcm94eVVzZXJuYW1lPU5vbmUKICAgICAgICBwcm94eVBhc3N3b3JkPU5vbmUKICAgICAgICAKICAgICAgICBpZiBsZW4ocHMpPjMgYW5kICdAJyBpbiBwc1szXTogI2phaXJveCAjIyNwcm94eXNldHRpbmdzCiAgICAgICAgICAgIHByb3h5VXNlcm5hbWU9cHNbM10uc3BsaXQoJ0AnKVswXSAjamFpcm94ICMjI3BzWzNdCiAgICAgICAgICAgIHByb3h5UGFzc3dvcmQ9cHNbM10uc3BsaXQoJ0AnKVsxXSAjamFpcm94ICMjI3Byb3h5c2V0dGluZ3Muc3BsaXQoJ0AnKVstMV0KCiAgICAgICAgI3ByaW50ICdwcm94eSBzZXQgdG8nLCBwcm94eVR5cGUsIHByb3h5VVJMLHByb3h5UG9ydAogICAgICAgIHhibWMuZXhlY3V0ZUpTT05SUEMoJ3sianNvbnJwYyI6IjIuMCIsICJtZXRob2QiOiJTZXR0aW5ncy5TZXRTZXR0aW5nVmFsdWUiLCAicGFyYW1zIjp7InNldHRpbmciOiJuZXR3b3JrLnVzZWh0dHBwcm94eSIsICJ2YWx1ZSI6dHJ1ZX0sICJpZCI6MX0nKQogICAgICAgIHhibWMuZXhlY3V0ZUpTT05SUEMoJ3sianNvbnJwYyI6IjIuMCIsICJtZXRob2QiOiJTZXR0aW5ncy5TZXRTZXR0aW5nVmFsdWUiLCAicGFyYW1zIjp7InNldHRpbmciOiJuZXR3b3JrLmh0dHBwcm94eXR5cGUiLCAidmFsdWUiOicgKyBzdHIocHJveHlUeXBlKSArJ30sICJpZCI6MX0nKQogICAgICAgIHhibWMuZXhlY3V0ZUpTT05SUEMoJ3sianNvbnJwYyI6IjIuMCIsICJtZXRob2QiOiJTZXR0aW5ncy5TZXRTZXR0aW5nVmFsdWUiLCAicGFyYW1zIjp7InNldHRpbmciOiJuZXR3b3JrLmh0dHBwcm94eXNlcnZlciIsICJ2YWx1ZSI6IicgKyBzdHIocHJveHlVUkwpICsnIn0sICJpZCI6MX0nKQogICAgICAgIHhibWMuZXhlY3V0ZUpTT05SUEMoJ3sianNvbnJwYyI6IjIuMCIsICJtZXRob2QiOiJTZXR0aW5ncy5TZXRTZXR0aW5nVmFsdWUiLCAicGFyYW1zIjp7InNldHRpbmciOiJuZXR3b3JrLmh0dHBwcm94eXBvcnQiLCAidmFsdWUiOicgKyBzdHIocHJveHlQb3J0KSArJ30sICJpZCI6MX0nKQogICAgICAgIAogICAgICAgIAogICAgICAgIGlmIG5vdCBwcm94eVVzZXJuYW1lPT1Ob25lOgogICAgICAgICAgICB4Ym1jLmV4ZWN1dGVKU09OUlBDKCd7Impzb25ycGMiOiIyLjAiLCAibWV0aG9kIjoiU2V0dGluZ3MuU2V0U2V0dGluZ1ZhbHVlIiwgInBhcmFtcyI6eyJzZXR0aW5nIjoibmV0d29yay5odHRwcHJveHl1c2VybmFtZSIsICJ2YWx1ZSI6IicgKyBzdHIocHJveHlVc2VybmFtZSkgKycifSwgImlkIjoxfScpCiAgICAgICAgICAgIHhibWMuZXhlY3V0ZUpTT05SUEMoJ3sianNvbnJwYyI6IjIuMCIsICJtZXRob2QiOiJTZXR0aW5ncy5TZXRTZXR0aW5nVmFsdWUiLCAicGFyYW1zIjp7InNldHRpbmciOiJuZXR3b3JrLmh0dHBwcm94eXBhc3N3b3JkIiwgInZhbHVlIjoiJyArIHN0cihwcm94eVBhc3N3b3JkKSArJyJ9LCAiaWQiOjF9JykKICAgICAgIApkZWYgZ2V0Q29uZmlndXJlZFByb3h5KCk6CiAgICBwcm94eUFjdGl2ZSA9IGtvZGlKc29uUmVxdWVzdCh7J2pzb25ycGMnOiAnMi4wJywgIm1ldGhvZCI6IlNldHRpbmdzLkdldFNldHRpbmdWYWx1ZSIsICJwYXJhbXMiOnsic2V0dGluZyI6Im5ldHdvcmsudXNlaHR0cHByb3h5In0sICdpZCc6IDF9KVsndmFsdWUnXQojICAgIHByaW50ICdwcm94eUFjdGl2ZScscHJveHlBY3RpdmUKICAgIHByb3h5VHlwZSA9IGtvZGlKc29uUmVxdWVzdCh7J2pzb25ycGMnOiAnMi4wJywgIm1ldGhvZCI6IlNldHRpbmdzLkdldFNldHRpbmdWYWx1ZSIsICJwYXJhbXMiOnsic2V0dGluZyI6Im5ldHdvcmsuaHR0cHByb3h5dHlwZSJ9LCAnaWQnOiAxfSlbJ3ZhbHVlJ10KCiAgICBpZiBwcm94eUFjdGl2ZTogIyBQUk9YWV9IVFRQCiAgICAgICAgcHJveHlVUkwgPSBrb2RpSnNvblJlcXVlc3Qoeydqc29ucnBjJzogJzIuMCcsICJtZXRob2QiOiJTZXR0aW5ncy5HZXRTZXR0aW5nVmFsdWUiLCAicGFyYW1zIjp7InNldHRpbmciOiJuZXR3b3JrLmh0dHBwcm94eXNlcnZlciJ9LCAnaWQnOiAxfSlbJ3ZhbHVlJ10KICAgICAgICBwcm94eVBvcnQgPSB1bmljb2RlKGtvZGlKc29uUmVxdWVzdCh7J2pzb25ycGMnOiAnMi4wJywgIm1ldGhvZCI6IlNldHRpbmdzLkdldFNldHRpbmdWYWx1ZSIsICJwYXJhbXMiOnsic2V0dGluZyI6Im5ldHdvcmsuaHR0cHByb3h5cG9ydCJ9LCAnaWQnOiAxfSlbJ3ZhbHVlJ10pCiAgICAgICAgcHJveHlVc2VybmFtZSA9IGtvZGlKc29uUmVxdWVzdCh7J2pzb25ycGMnOiAnMi4wJywgIm1ldGhvZCI6IlNldHRpbmdzLkdldFNldHRpbmdWYWx1ZSIsICJwYXJhbXMiOnsic2V0dGluZyI6Im5ldHdvcmsuaHR0cHByb3h5dXNlcm5hbWUifSwgJ2lkJzogMX0pWyd2YWx1ZSddCiAgICAgICAgcHJveHlQYXNzd29yZCA9IGtvZGlKc29uUmVxdWVzdCh7J2pzb25ycGMnOiAnMi4wJywgIm1ldGhvZCI6IlNldHRpbmdzLkdldFNldHRpbmdWYWx1ZSIsICJwYXJhbXMiOnsic2V0dGluZyI6Im5ldHdvcmsuaHR0cHByb3h5cGFzc3dvcmQifSwgJ2lkJzogMX0pWyd2YWx1ZSddCgogICAgICAgIGlmIHByb3h5VXNlcm5hbWUgYW5kIHByb3h5UGFzc3dvcmQgYW5kIHByb3h5VVJMIGFuZCBwcm94eVBvcnQ6CiAgICAgICAgICAgIHJldHVybiBwcm94eVVSTCArICc6JyArIHN0cihwcm94eVBvcnQpKyc6JytzdHIocHJveHlUeXBlKSArICc6JyArIHByb3h5VXNlcm5hbWUgKyAnQCcgKyBwcm94eVBhc3N3b3JkCiAgICAgICAgZWxpZiBwcm94eVVSTCBhbmQgcHJveHlQb3J0OgogICAgICAgICAgICByZXR1cm4gcHJveHlVUkwgKyAnOicgKyBzdHIocHJveHlQb3J0KSsnOicrc3RyKHByb3h5VHlwZSkKICAgIGVsc2U6CiAgICAgICAgcmV0dXJuIE5vbmUKICAgICAgICAKZGVmIHBsYXltZWRpYXdpdGhwcm94eShtZWRpYV91cmwsIG5hbWUsIGljb25JbWFnZSxwcm94eWlwLHBvcnQsIHByb3h5dXNlcj1Ob25lLCBwcm94eXBhc3M9Tm9uZSk6ICNqYWlyb3gKCiAgICBpZiBtZWRpYV91cmw9PU5vbmUgb3IgbWVkaWFfdXJsPT0nJzoKICAgICAgICB4Ym1jLmV4ZWN1dGVidWlsdGluKCJYQk1DLk5vdGlmaWNhdGlvbihGaXJlVFYsVW5hYmxlIHRvIHBsYXkgZW1wdHkgVXJsLDUwMDAsIitpY29uKyIpIikKICAgICAgICByZXR1cm4KICAgIHByb2dyZXNzID0geGJtY2d1aS5EaWFsb2dQcm9ncmVzcygpCiAgICBwcm9ncmVzcy5jcmVhdGUoJ1Byb2dyZXNzJywgJ1BsYXlpbmcgd2l0aCBjdXN0b20gcHJveHknKQogICAgcHJvZ3Jlc3MudXBkYXRlKCAxMCwgIiIsICJzZXR0aW5nIHByb3h5Li4iLCAiIiApCiAgICBwcm94eXNldD1GYWxzZQogICAgZXhpc3RpbmdfcHJveHk9JycKICAgICNwcmludCAncGxheW1lZGlhd2l0aHByb3h5JwogICAgdHJ5OgogICAgICAgIAogICAgICAgIGV4aXN0aW5nX3Byb3h5PWdldENvbmZpZ3VyZWRQcm94eSgpCiAgICAgICAgcHJpbnQgJ2V4aXN0aW5nX3Byb3h5JyxleGlzdGluZ19wcm94eQogICAgICAgICNyZWFkIGFuZCBzZXQgaGVyZQogICAgICAgICNqYWlyb3gKICAgICAgICBpZiBub3QgcHJveHl1c2VyID09IE5vbmU6CiAgICAgICAgICAgIHNldEtvZGlQcm94eSggcHJveHlpcCArICc6JyArIHBvcnQgKyAnOjA6JyArIHByb3h5dXNlciArICdAJyArIHByb3h5cGFzcykKICAgICAgICBlbHNlOgogICAgICAgICAgICBzZXRLb2RpUHJveHkoIHByb3h5aXAgKyAnOicgKyBwb3J0ICsgJzowJykKCiAgICAgICAgcHJpbnQgJ3Byb3h5IHNldHRpbmcgY29tcGxldGUgcGxheWluZycsbWVkaWFfdXJsCiAgICAgICAgcHJveHlzZXQ9VHJ1ZQogICAgICAgIHByb2dyZXNzLnVwZGF0ZSggODAsICIiLCAic2V0dGluZyBwcm94eSBjb21wbGV0ZSwgbm93IHBsYXlpbmciLCAiIiApCiAgICAgICAgCgogICAgICAgIGltcG9ydCAgQ3VzdG9tUGxheWVyCiAgICAgICAgcGxheWVyID0gQ3VzdG9tUGxheWVyLk15WEJNQ1BsYXllcigpCiAgICAgICAgcGxheWVyLnBkaWFsb2d1ZT09cHJvZ3Jlc3MKICAgICAgICBsaXN0aXRlbSA9IHhibWNndWkuTGlzdEl0ZW0oIGxhYmVsID0gc3RyKG5hbWUpLCBpY29uSW1hZ2UgPSBpY29uSW1hZ2UsIHRodW1ibmFpbEltYWdlID0geGJtYy5nZXRJbmZvSW1hZ2UoICJMaXN0SXRlbS5UaHVtYiIgKSwgcGF0aD1tZWRpYV91cmwgKQogICAgICAgIHBsYXllci5wbGF5KCBtZWRpYV91cmwsbGlzdGl0ZW0pCiAgICAgICAgeGJtYy5zbGVlcCgxMDAwKQogICAgICAgICN3aGlsZSBwbGF5ZXIuaXNfYWN0aXZlOgogICAgICAgICMgICAgeGJtYy5zbGVlcCgyMDApCiAgICAgICAgaW1wb3J0IHRpbWUKICAgICAgICBiZWZvcmVzdGFydD10aW1lLnRpbWUoKQogICAgICAgIHRyeToKICAgICAgICAgICAgd2hpbGUgcGxheWVyLmlzX2FjdGl2ZToKICAgICAgICAgICAgICAgIHhibWMuc2xlZXAoMTAwMCkgICAgICAgCiAgICAgICAgICAgICAgICBpZiBwbGF5ZXIudXJscGxheWVkPT1GYWxzZSBhbmQgdGltZS50aW1lKCktYmVmb3Jlc3RhcnQ+MTI6CiAgICAgICAgICAgICAgICAgICAgcHJpbnQgJ2ZhaWxlZCEhIScKICAgICAgICAgICAgICAgICAgICB4Ym1jLmV4ZWN1dGVidWlsdGluKCJYQk1DLk5vdGlmaWNhdGlvbihGaXJlVFYsVW5hYmxlIHRvIHBsYXkgY2hlY2sgcHJveHksNTAwMCwiK2ljb24rIikiKQogICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICAjeGJtYy5zbGVlcCgxMDAwKQogICAgICAgIGV4Y2VwdDogcGFzcwoKICAgICAgICBwcm9ncmVzcy5jbG9zZSgpCiAgICAgICAgcHJvZ3Jlc3M9Tm9uZQogICAgZXhjZXB0OgogICAgICAgIHRyYWNlYmFjay5wcmludF9leGMoKQogICAgaWYgcHJvZ3Jlc3M6CiAgICAgICAgcHJvZ3Jlc3MuY2xvc2UoKQogICAgaWYgcHJveHlzZXQ6CiAgICAgICAgcHJpbnQgJ25vdyByZXNldHRpbmcgdGhlIHByb3h5IGJhY2snCiAgICAgICAgc2V0S29kaVByb3h5KGV4aXN0aW5nX3Byb3h5KQogICAgICAgIHByaW50ICdyZXNldCBoZXJlJwogICAgcmV0dXJuICcnCgpkZWYgZ2V0X3Nhd19ydG1wKHBhZ2VfdmFsdWUsIHJlZmVyZXI9Tm9uZSk6CiAgICBpZiByZWZlcmVyOgogICAgICAgIHJlZmVyZXI9WygnUmVmZXJlcicscmVmZXJlcildCiAgICBpZiBwYWdlX3ZhbHVlLnN0YXJ0c3dpdGgoImh0dHAiKToKICAgICAgICBwYWdlX3VybD1wYWdlX3ZhbHVlCiAgICAgICAgcGFnZV92YWx1ZT0gZ2V0VXJsKHBhZ2VfdmFsdWUsaGVhZGVycz1yZWZlcmVyKQoKICAgIHN0cl9wYXR0ZXJuPSIoZXZhbFwoZnVuY3Rpb25cKHAsYSxjLGssZSwoPzpyfGQpLiopIgoKICAgIHJlZ19yZXM9cmUuY29tcGlsZShzdHJfcGF0dGVybikuZmluZGFsbChwYWdlX3ZhbHVlKQogICAgcj0iIgogICAgaWYgcmVnX3JlcyBhbmQgbGVuKHJlZ19yZXMpPjA6CiAgICAgICAgZm9yIHYgaW4gcmVnX3JlczoKICAgICAgICAgICAgcjE9Z2V0X3VucGFja2VkKHYpCiAgICAgICAgICAgIHIyPXJlX21lKHIxLCdcJyguKj8pXCcnKQogICAgICAgICAgICBpZiAndW5lc2NhcGUnIGluIHIxOgogICAgICAgICAgICAgICAgcjE9dXJsbGliLnVucXVvdGUocjIpCiAgICAgICAgICAgIHIrPXIxKydcbicKIyAgICAgICAgcHJpbnQgJ2ZpbmFsIHZhbHVlIGlzICcscgoKICAgICAgICBwYWdlX3VybD1yZV9tZShyLCdzcmM9IiguKj8pIicpCgogICAgICAgIHBhZ2VfdmFsdWU9IGdldFVybChwYWdlX3VybCxoZWFkZXJzPXJlZmVyZXIpCgogICAgI3ByaW50IHBhZ2VfdmFsdWUKCiAgICBydG1wPXJlX21lKHBhZ2VfdmFsdWUsJ3N0cmVhbWVyXCcuKj9cJyguKj8pXCdcKScpCiAgICBwbGF5cGF0aD1yZV9tZShwYWdlX3ZhbHVlLCdmaWxlXCcsXHNcJyguKj8pXCcnKQoKCiAgICByZXR1cm4gcnRtcCsnIHBsYXlwYXRoPScrcGxheXBhdGggKycgcGFnZVVybD0nK3BhZ2VfdXJsCgpkZWYgZ2V0X2xldG9uX3J0bXAocGFnZV92YWx1ZSwgcmVmZXJlcj1Ob25lKToKICAgIGlmIHJlZmVyZXI6CiAgICAgICAgcmVmZXJlcj1bKCdSZWZlcmVyJyxyZWZlcmVyKV0KICAgIGlmIHBhZ2VfdmFsdWUuc3RhcnRzd2l0aCgiaHR0cCIpOgogICAgICAgIHBhZ2VfdmFsdWU9IGdldFVybChwYWdlX3ZhbHVlLGhlYWRlcnM9cmVmZXJlcikKICAgIHN0cl9wYXR0ZXJuPSJ2YXIgYSA9ICguKj8pO1xzKnZhciBiID0gKC4qPyk7XHMqdmFyIGMgPSAoLio/KTtccyp2YXIgZCA9ICguKj8pO1xzKnZhciBmID0gKC4qPyk7XHMqdmFyIHZfcGFydCA9ICcoLio/KSc7IgogICAgcmVnX3Jlcz1yZS5jb21waWxlKHN0cl9wYXR0ZXJuKS5maW5kYWxsKHBhZ2VfdmFsdWUpWzBdCgogICAgYSxiLGMsZCxmLHY9KHJlZ19yZXMpCiAgICBmPWludChmKQogICAgYT1pbnQoYSkvZgogICAgYj1pbnQoYikvZgogICAgYz1pbnQoYykvZgogICAgZD1pbnQoZCkvZgoKICAgIHJldD0gJ3J0bXA6Ly8nICsgc3RyKGEpICsgJy4nICsgc3RyKGIpICsgJy4nICsgc3RyKGMpICsgJy4nICsgc3RyKGQpICsgdgogICAgcmV0dXJuIHJldAoKZGVmIGNyZWF0ZU0zdUZvckRhc2godXJsLHVzZXJhZ2VudD1Ob25lKToKICAgIHN0cj0nI0VYVE0zVScKICAgIHN0cis9J1xuI0VYVC1YLVNUUkVBTS1JTkY6UFJPR1JBTS1JRD0xLEJBTkRXSURUSD0zNjE4MTYnCiAgICBzdHIrPSdcbicrdXJsKycmYnl0ZXM9MC0yMDAwMDAnIysnfFVzZXItQWdlbnQ9Jyt1c2VyYWdlbnQKICAgIHNvdXJjZV9maWxlID0gb3MucGF0aC5qb2luKHByb2ZpbGUsICd0ZXN0ZmlsZS5tM3UnKQogICAgc3RyKz0nXG4nCiAgICBTYXZlVG9GaWxlKHNvdXJjZV9maWxlLHN0cikKICAgICNyZXR1cm4gJ0M6L1VzZXJzL3NoYW5pL0Rvd25sb2Fkcy90ZXN0Lm0zdTgnCiAgICByZXR1cm4gc291cmNlX2ZpbGUKCmRlZiBTYXZlVG9GaWxlKGZpbGVfbmFtZSxwYWdlX2RhdGEsYXBwZW5kPUZhbHNlKToKICAgIGlmIGFwcGVuZDoKICAgICAgICBmID0gb3BlbihmaWxlX25hbWUsICdhJykKICAgICAgICBmLndyaXRlKHBhZ2VfZGF0YSkKICAgICAgICBmLmNsb3NlKCkKICAgIGVsc2U6CiAgICAgICAgZj1vcGVuKGZpbGVfbmFtZSwnd2InKQogICAgICAgIGYud3JpdGUocGFnZV9kYXRhKQogICAgICAgIGYuY2xvc2UoKQogICAgICAgIHJldHVybiAnJwoKZGVmIExvYWRGaWxlKGZpbGVfbmFtZSk6CiAgICBmPW9wZW4oZmlsZV9uYW1lLCdyYicpCiAgICBkPWYucmVhZCgpCiAgICBmLmNsb3NlKCkKICAgIHJldHVybiBkCgpkZWYgZ2V0X3BhY2tlZF9pcGhvbmV0dl91cmwocGFnZV9kYXRhKToKICAgIGltcG9ydCByZSxiYXNlNjQsdXJsbGliCiAgICBzPXBhZ2VfZGF0YQogICAgd2hpbGUgJ2dlaCgnIGluIHM6CiAgICAgICAgaWYgcy5zdGFydHN3aXRoKCdsb2woJyk6IHM9c1s1Oi0xXQojICAgICAgIHByaW50ICdzIGlzICcscwogICAgICAgIHM9cmUuY29tcGlsZSgnIiguKj8pIicpLmZpbmRhbGwocylbMF0KICAgICAgICBzPSAgYmFzZTY0LmI2NGRlY29kZShzKQogICAgICAgIHM9dXJsbGliLnVucXVvdGUocykKICAgIHByaW50IHMKICAgIHJldHVybiBzCgpkZWYgZ2V0X2ZlcnJhcmlfdXJsKHBhZ2VfZGF0YSk6CiMgICAgcHJpbnQgJ2dldF9kYWdfdXJsMicscGFnZV9kYXRhCiAgICBwYWdlX2RhdGEyPWdldFVybChwYWdlX2RhdGEpCiAgICBwYXR0PScoaHR0cC4qKScKICAgIGltcG9ydCB1dWlkCiAgICBwbGF5YmFjaz1zdHIodXVpZC51dWlkMSgpKS51cHBlcigpCiAgICBsaW5rcz1yZS5jb21waWxlKHBhdHQpLmZpbmRhbGwocGFnZV9kYXRhMikKICAgIGhlYWRlcnM9WygnWC1QbGF5YmFjay1TZXNzaW9uLUlkJyxwbGF5YmFjayldCiAgICBmb3IgbCBpbiBsaW5rczoKICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBwYWdlX2RhdGF0ZW1wPWdldFVybChsLGhlYWRlcnM9aGVhZGVycykKCiAgICAgICAgZXhjZXB0OiBwYXNzCgogICAgcmV0dXJuIHBhZ2VfZGF0YSsnfCZYLVBsYXliYWNrLVNlc3Npb24tSWQ9JytwbGF5YmFjawoKZGVmIGdldF9kYWdfdXJsKHBhZ2VfZGF0YSk6CiMgICAgcHJpbnQgJ2dldF9kYWdfdXJsJyxwYWdlX2RhdGEKICAgIGlmIHBhZ2VfZGF0YS5zdGFydHN3aXRoKCdodHRwOi8vZGFnLnRvdGFsLXN0cmVhbS5uZXQnKToKICAgICAgICBoZWFkZXJzPVsoJ1VzZXItQWdlbnQnLCdWZXJpc21vLUJsYWNrVUlfKDIuNC43LjUuOC4wLjM0KScpXQogICAgICAgIHBhZ2VfZGF0YT1nZXRVcmwocGFnZV9kYXRhLGhlYWRlcnM9aGVhZGVycykKCiAgICBpZiAnMTI3LjAuMC4xJyBpbiBwYWdlX2RhdGE6CiAgICAgICAgcmV0dXJuIHJldmlzdF9kYWcocGFnZV9kYXRhKQogICAgZWxpZiByZV9tZShwYWdlX2RhdGEsICd3bXNBdXRoU2lnbiUzRChbXiUmXSspJykgIT0gJyc6CiAgICAgICAgZmluYWxfdXJsID0gcmVfbWUocGFnZV9kYXRhLCAnJnZlcl90PShbXiZdKykmJykgKyAnP3dtc0F1dGhTaWduPScgKyByZV9tZShwYWdlX2RhdGEsICd3bXNBdXRoU2lnbiUzRChbXiUmXSspJykgKyAnPT0vbXA0OicgKyByZV9tZShwYWdlX2RhdGEsICdcXD95PShbXiZdKykmJykKICAgIGVsc2U6CiAgICAgICAgZmluYWxfdXJsID0gcmVfbWUocGFnZV9kYXRhLCAnaHJlZj0iKFteIl0rKSJbXiJdKyQnKQogICAgICAgIGlmIGxlbihmaW5hbF91cmwpPT0wOgogICAgICAgICAgICBmaW5hbF91cmw9cGFnZV9kYXRhCiAgICBmaW5hbF91cmwgPSBmaW5hbF91cmwucmVwbGFjZSgnICcsICclMjAnKQogICAgcmV0dXJuIGZpbmFsX3VybAoKZGVmIHJlX21lKGRhdGEsIHJlX3BhdHRlbik6CiAgICBtYXRjaCA9ICcnCiAgICBtID0gcmUuc2VhcmNoKHJlX3BhdHRlbiwgZGF0YSkKICAgIGlmIG0gIT0gTm9uZToKICAgICAgICBtYXRjaCA9IG0uZ3JvdXAoMSkKICAgIGVsc2U6CiAgICAgICAgbWF0Y2ggPSAnJwogICAgcmV0dXJuIG1hdGNoCgpkZWYgcmV2aXN0X2RhZyhwYWdlX2RhdGEpOgogICAgZmluYWxfdXJsID0gJycKICAgIGlmICcxMjcuMC4wLjEnIGluIHBhZ2VfZGF0YToKICAgICAgICBmaW5hbF91cmwgPSByZV9tZShwYWdlX2RhdGEsICcmdmVyX3Q9KFteJl0rKSYnKSArICcgbGl2ZT10cnVlIHRpbWVvdXQ9MTUgcGxheXBhdGg9JyArIHJlX21lKHBhZ2VfZGF0YSwgJ1xcP3k9KFthLXpBLVowLTktX1xcLkBdKyknKQoKICAgIGlmIHJlX21lKHBhZ2VfZGF0YSwgJ3Rva2VuPShbXiZdKykmJykgIT0gJyc6CiAgICAgICAgZmluYWxfdXJsID0gZmluYWxfdXJsICsgJz90b2tlbj0nICsgcmVfbWUocGFnZV9kYXRhLCAndG9rZW49KFteJl0rKSYnKQogICAgZWxpZiByZV9tZShwYWdlX2RhdGEsICd3bXNBdXRoU2lnbiUzRChbXiUmXSspJykgIT0gJyc6CiAgICAgICAgZmluYWxfdXJsID0gcmVfbWUocGFnZV9kYXRhLCAnJnZlcl90PShbXiZdKykmJykgKyAnP3dtc0F1dGhTaWduPScgKyByZV9tZShwYWdlX2RhdGEsICd3bXNBdXRoU2lnbiUzRChbXiUmXSspJykgKyAnPT0vbXA0OicgKyByZV9tZShwYWdlX2RhdGEsICdcXD95PShbXiZdKykmJykKICAgIGVsc2U6CiAgICAgICAgZmluYWxfdXJsID0gcmVfbWUocGFnZV9kYXRhLCAnSFJFRj0iKFteIl0rKSInKQoKICAgIGlmICdkYWcxLmFzeCcgaW4gZmluYWxfdXJsOgogICAgICAgIHJldHVybiBnZXRfZGFnX3VybChmaW5hbF91cmwpCgogICAgaWYgJ2RldmlubGl2ZWZzLmZwbGl2ZS5uZXQnIG5vdCBpbiBmaW5hbF91cmw6CiAgICAgICAgZmluYWxfdXJsID0gZmluYWxfdXJsLnJlcGxhY2UoJ2RldmlubGl2ZScsICdmbGl2ZScpCiAgICBpZiAncGVybWxpdmVmcy5mcGxpdmUubmV0JyBub3QgaW4gZmluYWxfdXJsOgogICAgICAgIGZpbmFsX3VybCA9IGZpbmFsX3VybC5yZXBsYWNlKCdwZXJtbGl2ZScsICdmbGl2ZScpCiAgICByZXR1cm4gZmluYWxfdXJsCgpkZWYgZ2V0X3Vud2lzZSggc3RyX2V2YWwpOgogICAgcGFnZV92YWx1ZT0iIgogICAgdHJ5OgogICAgICAgIHNzPSJ3LGkscyxlPSgiK3N0cl9ldmFsKycpJwogICAgICAgIGV4ZWMgKHNzKQogICAgICAgIHBhZ2VfdmFsdWU9dW53aXNlX2Z1bmModyxpLHMsZSkKICAgIGV4Y2VwdDogdHJhY2ViYWNrLnByaW50X2V4YyhmaWxlPXN5cy5zdGRvdXQpCiAgICAjcHJpbnQgJ3VucGFja2VkJyxwYWdlX3ZhbHVlCiAgICByZXR1cm4gcGFnZV92YWx1ZQoKZGVmIHVud2lzZV9mdW5jKCB3LCBpLCBzLCBlKToKICAgIGxJbGwgPSAwCiAgICBsbDFJID0gMAogICAgSWwxbCA9IDAKICAgIGxsMWwgPSBbXQogICAgbDFsSSA9IFtdCiAgICB3aGlsZSBUcnVlOgogICAgICAgIGlmIChsSWxsIDwgNSk6CiAgICAgICAgICAgIGwxbEkuYXBwZW5kKHdbbElsbF0pCiAgICAgICAgZWxpZiAobElsbCA8IGxlbih3KSk6CiAgICAgICAgICAgIGxsMWwuYXBwZW5kKHdbbElsbF0pCiAgICAgICAgbElsbCs9MQogICAgICAgIGlmIChsbDFJIDwgNSk6CiAgICAgICAgICAgIGwxbEkuYXBwZW5kKGlbbGwxSV0pCiAgICAgICAgZWxpZiAobGwxSSA8IGxlbihpKSk6CiAgICAgICAgICAgIGxsMWwuYXBwZW5kKGlbbGwxSV0pCiAgICAgICAgbGwxSSs9MQogICAgICAgIGlmIChJbDFsIDwgNSk6CiAgICAgICAgICAgIGwxbEkuYXBwZW5kKHNbSWwxbF0pCiAgICAgICAgZWxpZiAoSWwxbCA8IGxlbihzKSk6CiAgICAgICAgICAgIGxsMWwuYXBwZW5kKHNbSWwxbF0pCiAgICAgICAgSWwxbCs9MQogICAgICAgIGlmIChsZW4odykgKyBsZW4oaSkgKyBsZW4ocykgKyBsZW4oZSkgPT0gbGVuKGxsMWwpICsgbGVuKGwxbEkpICsgbGVuKGUpKToKICAgICAgICAgICAgYnJlYWsKCiAgICBsSTFsID0gJycuam9pbihsbDFsKSMuam9pbignJyk7CiAgICBJMWxJID0gJycuam9pbihsMWxJKSMuam9pbignJyk7CiAgICBsbDFJID0gMAogICAgbDFsbCA9IFtdCiAgICBmb3IgbElsbCBpbiByYW5nZSgwLGxlbihsbDFsKSwyKToKICAgICAgICAjcHJpbnQgJ2FycmF5IGknLGxJbGwsbGVuKGxsMWwpCiAgICAgICAgbGwxMSA9IC0xCiAgICAgICAgaWYgKCBvcmQoSTFsSVtsbDFJXSkgJSAyKToKICAgICAgICAgICAgbGwxMSA9IDEKICAgICAgICAjcHJpbnQgJ3ZhbCBpcyAnLCBsSTFsW2xJbGw6IGxJbGwrMl0KICAgICAgICBsMWxsLmFwcGVuZChjaHIoICAgIGludChsSTFsW2xJbGw6IGxJbGwrMl0sIDM2KSAtIGxsMTEpKQogICAgICAgIGxsMUkrPTEKICAgICAgICBpZiAobGwxSSA+PSBsZW4obDFsSSkpOgogICAgICAgICAgICBsbDFJID0gMAogICAgcmV0PScnLmpvaW4obDFsbCkKICAgIGlmICdldmFsKGZ1bmN0aW9uKHcsaSxzLGUpJyBpbiByZXQ6CiMgICAgICAgIHByaW50ICdTVElMTCBHT2luZycKICAgICAgICByZXQ9cmUuY29tcGlsZSgnZXZhbFwoZnVuY3Rpb25cKHcsaSxzLGVcKS4qfVwoKC4qPylcKScpLmZpbmRhbGwocmV0KVswXQogICAgICAgIHJldHVybiBnZXRfdW53aXNlKHJldCkKICAgIGVsc2U6CiMgICAgICAgIHByaW50ICdGSU5JU0hFRCcKICAgICAgICByZXR1cm4gcmV0CgpkZWYgZ2V0X3VucGFja2VkKCBwYWdlX3ZhbHVlLCByZWdleF9mb3JfdGV4dD0nJywgaXRlcmF0aW9ucz0xLCB0b3RhbF9pdGVyYXRpb249MSk6CiAgICB0cnk6CiAgICAgICAgcmVnX2RhdGE9Tm9uZQogICAgICAgIGlmIHBhZ2VfdmFsdWUuc3RhcnRzd2l0aCgiaHR0cCIpOgogICAgICAgICAgICBwYWdlX3ZhbHVlPSBnZXRVcmwocGFnZV92YWx1ZSkKIyAgICAgICAgcHJpbnQgJ3BhZ2VfdmFsdWUnLHBhZ2VfdmFsdWUKICAgICAgICBpZiByZWdleF9mb3JfdGV4dCBhbmQgbGVuKHJlZ2V4X2Zvcl90ZXh0KT4wOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBwYWdlX3ZhbHVlPXJlLmNvbXBpbGUocmVnZXhfZm9yX3RleHQpLmZpbmRhbGwocGFnZV92YWx1ZSlbMF0gI2dldCB0aGUganMgdmFyaWFibGUKICAgICAgICAgICAgZXhjZXB0OiByZXR1cm4gJ05PVFBBQ0tFRCcKCiAgICAgICAgcGFnZV92YWx1ZT11bnBhY2socGFnZV92YWx1ZSxpdGVyYXRpb25zLHRvdGFsX2l0ZXJhdGlvbikKICAgIGV4Y2VwdDoKICAgICAgICBwYWdlX3ZhbHVlPSdVTlBBQ0tFREZBSUxFRCcKICAgICAgICB0cmFjZWJhY2sucHJpbnRfZXhjKGZpbGU9c3lzLnN0ZG91dCkKIyAgICBwcmludCAndW5wYWNrZWQnLHBhZ2VfdmFsdWUKICAgIGlmICdzYXYxbGl2ZS50dicgaW4gcGFnZV92YWx1ZToKICAgICAgICBwYWdlX3ZhbHVlPXBhZ2VfdmFsdWUucmVwbGFjZSgnc2F2MWxpdmUudHYnLCdzYXdsaXZlLnR2JykgI3F1aWNrIGZpeCBzb21lIGJ1ZyBzb21ld2hlcmUKIyAgICAgICAgcHJpbnQgJ3NhdjEgdW5wYWNrZWQnLHBhZ2VfdmFsdWUKICAgIHJldHVybiBwYWdlX3ZhbHVlCgpkZWYgdW5wYWNrKHNKYXZhc2NyaXB0LGl0ZXJhdGlvbj0xLCB0b3RhbGl0ZXJhdGlvbnM9MiAgKToKIyAgICBwcmludCAnaXRlcmF0aW9uJyxpdGVyYXRpb24KICAgIGlmIHNKYXZhc2NyaXB0LnN0YXJ0c3dpdGgoJ3ZhciBfMHhjYjhhPScpOgogICAgICAgIGFTcGxpdD1zSmF2YXNjcmlwdC5zcGxpdCgndmFyIF8weGNiOGE9JykKICAgICAgICBzcz0ibXlhcnJheT0iK2FTcGxpdFsxXS5zcGxpdCgiZXZhbCgiKVswXQogICAgICAgIGV4ZWMoc3MpCiAgICAgICAgYTE9NjIKICAgICAgICBjMT1pbnQoYVNwbGl0WzFdLnNwbGl0KCIsNjIsIilbMV0uc3BsaXQoJywnKVswXSkKICAgICAgICBwMT1teWFycmF5WzBdCiAgICAgICAgazE9bXlhcnJheVszXQogICAgICAgIHdpdGggb3BlbigndGVtcCBmaWxlJytzdHIoaXRlcmF0aW9uKSsnLmpzJywgIndiIikgYXMgZmlsZXdyaXRlcjoKICAgICAgICAgICAgZmlsZXdyaXRlci53cml0ZShzdHIoazEpKQogICAgICAgICNhYT0xLzAKICAgIGVsc2U6CgogICAgICAgIGlmICJybiBwfSgnIiBpbiBzSmF2YXNjcmlwdDoKICAgICAgICAgICAgYVNwbGl0ID0gc0phdmFzY3JpcHQuc3BsaXQoInJuIHB9KCciKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGFTcGxpdCA9IHNKYXZhc2NyaXB0LnNwbGl0KCJybiBBfSgnIikKIyAgICAgICAgcHJpbnQgYVNwbGl0CgogICAgICAgIHAxLGExLGMxLGsxPSgnJywnMCcsJzAnLCcnKQoKICAgICAgICBzcz0icDEsYTEsYzEsazE9KCciK2FTcGxpdFsxXS5zcGxpdCgiLnNwbGkiKVswXSsnKScKICAgICAgICBleGVjKHNzKQogICAgazE9azEuc3BsaXQoJ3wnKQogICAgYVNwbGl0ID0gYVNwbGl0WzFdLnNwbGl0KCIpKSciKQojICAgIHByaW50ICcgcCBhcnJheSBpcyAnLGxlbihhU3BsaXQpCiMgICBwcmludCBsZW4oYVNwbGl0ICkKCiAgICAjcD1zdHIoYVNwbGl0WzBdKycpKScpIy5yZXBsYWNlKCJcXCIsIiIpIy5yZXBsYWNlKCdcXFxcJywnXFwnKQoKICAgICNwcmludCBhU3BsaXRbMV0KICAgICNhU3BsaXQgPSBhU3BsaXRbMV0uc3BsaXQoIiwiKQogICAgI3ByaW50IGFTcGxpdFswXQogICAgI2EgPSBpbnQoYVNwbGl0WzFdKQogICAgI2MgPSBpbnQoYVNwbGl0WzJdKQogICAgI2sgPSBhU3BsaXRbM10uc3BsaXQoIi4iKVswXS5yZXBsYWNlKCInIiwgJycpLnNwbGl0KCd8JykKICAgICNhPWludChhKQogICAgI2M9aW50KGMpCgogICAgI3A9cC5yZXBsYWNlKCdcXCcsICcnKQojICAgIHByaW50ICdwIHZhbCBpcyAnLHBbMDoxMDBdLCcuLi4uLi4uLi4uLi4nLHBbLTEwMDpdLGxlbihwKQojICAgIHByaW50ICdwMSB2YWwgaXMgJyxwMVswOjEwMF0sJy4uLi4uLi4uLi4uLicscDFbLTEwMDpdLGxlbihwMSkKCiAgICAjcHJpbnQgYSxhMQogICAgI3ByaW50IGMsYTEKICAgICNwcmludCAnayB2YWwgaXMgJyxrWy0xMDpdLGxlbihrKQojICAgIHByaW50ICdrMSB2YWwgaXMgJyxrMVstMTA6XSxsZW4oazEpCiAgICBlID0gJycKICAgIGQgPSAnJyMzMjgyMwoKICAgICNzVW5wYWNrZWQgPSBzdHIoX191bnBhY2socCwgYSwgYywgaywgZSwgZCkpCiAgICBzVW5wYWNrZWQxID0gc3RyKF9fdW5wYWNrKHAxLCBhMSwgYzEsIGsxLCBlLCBkLGl0ZXJhdGlvbikpCgogICAgI3ByaW50IHNVbnBhY2tlZFs6MjAwXSsnLi4uLicrc1VucGFja2VkWy0xMDA6XSwgbGVuKHNVbnBhY2tlZCkKIyAgICBwcmludCBzVW5wYWNrZWQxWzoyMDBdKycuLi4uJytzVW5wYWNrZWQxWy0xMDA6XSwgbGVuKHNVbnBhY2tlZDEpCgogICAgI2V4ZWMoJ3NVbnBhY2tlZDE9Iicrc1VucGFja2VkMSsnIicpCiAgICBpZiBpdGVyYXRpb24+PXRvdGFsaXRlcmF0aW9uczoKIyAgICAgICAgcHJpbnQgJ2ZpbmFsIHJlcycsc1VucGFja2VkMVs6MjAwXSsnLi4uLicrc1VucGFja2VkMVstMTAwOl0sIGxlbihzVW5wYWNrZWQxKQogICAgICAgIHJldHVybiBzVW5wYWNrZWQxIy5yZXBsYWNlKCdcXFxcJywgJ1xcJykKICAgIGVsc2U6CiMgICAgICAgIHByaW50ICdmaW5hbCByZXMgZm9yIHRoaXMgaXRlcmF0aW9uIGlzJyxpdGVyYXRpb24KICAgICAgICByZXR1cm4gdW5wYWNrKHNVbnBhY2tlZDEsaXRlcmF0aW9uKzEpIy5yZXBsYWNlKCdcXCcsICcnKSxpdGVyYXRpb24pIy5yZXBsYWNlKCdcXCcsICcnKTsjdW5wYWNrKHNVbnBhY2tlZC5yZXBsYWNlKCdcXCcsICcnKSkKCmRlZiBfX3VucGFjayhwLCBhLCBjLCBrLCBlLCBkLCBpdGVyYXRpb24sdj0xKToKCiAgICAjd2l0aCBvcGVuKCdiZWZvcmUgZmlsZScrc3RyKGl0ZXJhdGlvbikrJy5qcycsICJ3YiIpIGFzIGZpbGV3cml0ZXI6CiAgICAjICAgIGZpbGV3cml0ZXIud3JpdGUoc3RyKHApKQogICAgd2hpbGUgKGMgPj0gMSk6CiAgICAgICAgYyA9IGMgLTEKICAgICAgICBpZiAoa1tjXSk6CiAgICAgICAgICAgIGFhPXN0cihfX2l0b2FOZXcoYywgYSkpCiAgICAgICAgICAgIGlmIHY9PTE6CiAgICAgICAgICAgICAgICBwPXJlLnN1YignXFxiJyArIGFhICsnXFxiJywga1tjXSwgcCkjIFRISVMgSVMgQmxvb2R5IHNsb3chCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBwPWZpbmRBbmRSZXBsYWNlV29yZChwLGFhLGtbY10pCgogICAgICAgICAgICAjcD1maW5kQW5kUmVwbGFjZVdvcmQocCxhYSxrW2NdKQoKCiAgICAjd2l0aCBvcGVuKCdhZnRlciBmaWxlJytzdHIoaXRlcmF0aW9uKSsnLmpzJywgIndiIikgYXMgZmlsZXdyaXRlcjoKICAgICMgICAgZmlsZXdyaXRlci53cml0ZShzdHIocCkpCiAgICByZXR1cm4gcAoKIwojZnVuY3Rpb24gZXF1YWxhdmVudCB0byByZS5zdWIoJ1xcYicgKyBhYSArJ1xcYicsIGtbY10sIHApCmRlZiBmaW5kQW5kUmVwbGFjZVdvcmQoc291cmNlX3N0ciwgd29yZF90b19maW5kLHJlcGxhY2Vfd2l0aCk6CiAgICBzcGxpdHM9Tm9uZQogICAgc3BsaXRzPXNvdXJjZV9zdHIuc3BsaXQod29yZF90b19maW5kKQogICAgaWYgbGVuKHNwbGl0cyk+MToKICAgICAgICBuZXdfc3RyaW5nPVtdCiAgICAgICAgY3VycmVudF9pbmRleD0wCiAgICAgICAgZm9yIGN1cnJlbnRfc3BsaXQgaW4gc3BsaXRzOgogICAgICAgICAgICAjcHJpbnQgJ2hlcmUnLGkKICAgICAgICAgICAgbmV3X3N0cmluZy5hcHBlbmQoY3VycmVudF9zcGxpdCkKICAgICAgICAgICAgdmFsPXdvcmRfdG9fZmluZCNieSBkZWZhdWx0IGFzc3VtZSBpdCB3YXMgd3JvbmcgdG8gc3BsaXQKCiAgICAgICAgICAgICNpZiBpdHMgZmlyc3Qgb25lIGFuZCBpdGVtIGlzIGJsYW5rIHRoZW4gY2hlY2sgbmV4dCBpdGVtIGlzIHZhbGlkIG9yIG5vdAogICAgICAgICAgICBpZiBjdXJyZW50X2luZGV4PT1sZW4oc3BsaXRzKS0xOgogICAgICAgICAgICAgICAgdmFsPScnICMgbGFzdCBvbmUgbm90aGluZyB0byBhcHBlbmQgbm9ybWFsbHkKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGlmIGxlbihjdXJyZW50X3NwbGl0KT09MDogI2lmIGJsYW5rIGNoZWNrIG5leHQgb25lIHdpdGggY3VycmVudCBzcGxpdCB2YWx1ZQogICAgICAgICAgICAgICAgICAgIGlmICggbGVuKHNwbGl0c1tjdXJyZW50X2luZGV4KzFdKT09MCBhbmQgd29yZF90b19maW5kWzBdLmxvd2VyKCkgbm90IGluICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejEyMzQ1Njc4OTBfJykgb3IgKGxlbihzcGxpdHNbY3VycmVudF9pbmRleCsxXSk+MCAgYW5kIHNwbGl0c1tjdXJyZW50X2luZGV4KzFdWzBdLmxvd2VyKCkgbm90IGluICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejEyMzQ1Njc4OTBfJyk6IyBmaXJzdCBqdXN0IGp1c3QgY2hlY2sgbmV4dAogICAgICAgICAgICAgICAgICAgICAgICB2YWw9cmVwbGFjZV93aXRoCiAgICAgICAgICAgICAgICAjbm90IGJsYW5rLCB0aGVuIGNoZWNrIGN1cnJlbnQgZW5kdmFsdWUgYW5kIG5leHQgZmlyc3QgdmFsdWUKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0c1tjdXJyZW50X2luZGV4XVstMV0ubG93ZXIoKSBub3QgaW4gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MTIzNDU2Nzg5MF8nKSBhbmQgKCggbGVuKHNwbGl0c1tjdXJyZW50X2luZGV4KzFdKT09MCBhbmQgd29yZF90b19maW5kWzBdLmxvd2VyKCkgbm90IGluICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejEyMzQ1Njc4OTBfJykgb3IgKGxlbihzcGxpdHNbY3VycmVudF9pbmRleCsxXSk+MCAgYW5kIHNwbGl0c1tjdXJyZW50X2luZGV4KzFdWzBdLmxvd2VyKCkgbm90IGluICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejEyMzQ1Njc4OTBfJykpOiMgZmlyc3QganVzdCBqdXN0IGNoZWNrIG5leHQKICAgICAgICAgICAgICAgICAgICAgICAgdmFsPXJlcGxhY2Vfd2l0aAoKICAgICAgICAgICAgbmV3X3N0cmluZy5hcHBlbmQodmFsKQogICAgICAgICAgICBjdXJyZW50X2luZGV4Kz0xCiAgICAgICAgI2FhYWE9MS8wCiAgICAgICAgc291cmNlX3N0cj0nJy5qb2luKG5ld19zdHJpbmcpCiAgICByZXR1cm4gc291cmNlX3N0cgoKZGVmIF9faXRvYShudW0sIHJhZGl4KToKIyAgICBwcmludCAnbnVtIHJlZCcsbnVtLCByYWRpeAogICAgcmVzdWx0ID0gIiIKICAgIGlmIG51bT09MDogcmV0dXJuICcwJwogICAgd2hpbGUgbnVtID4gMDoKICAgICAgICByZXN1bHQgPSAiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6IltudW0gJSByYWRpeF0gKyByZXN1bHQKICAgICAgICBudW0gLz0gcmFkaXgKICAgIHJldHVybiByZXN1bHQKCmRlZiBfX2l0b2FOZXcoY2MsIGEpOgogICAgYWE9IiIgaWYgY2MgPCBhIGVsc2UgX19pdG9hTmV3KGludChjYyAvIGEpLGEpCiAgICBjYyA9IChjYyAlIGEpCiAgICBiYj1jaHIoY2MgKyAyOSkgaWYgY2M+IDM1IGVsc2Ugc3RyKF9faXRvYShjYywzNikpCiAgICByZXR1cm4gYWErYmIKCmRlZiBnZXRDb29raWVzU3RyaW5nKGNvb2tpZUphcik6CiAgICB0cnk6CiAgICAgICAgY29va2llU3RyaW5nPSIiCiAgICAgICAgZm9yIGluZGV4LCBjb29raWUgaW4gZW51bWVyYXRlKGNvb2tpZUphcik6CiAgICAgICAgICAgIGNvb2tpZVN0cmluZys9Y29va2llLm5hbWUgKyAiPSIgKyBjb29raWUudmFsdWUgKyI7IgogICAgZXhjZXB0OiBwYXNzCiAgICAjcHJpbnQgJ2Nvb2tpZVN0cmluZycsY29va2llU3RyaW5nCiAgICByZXR1cm4gY29va2llU3RyaW5nCgpkZWYgc2F2ZUNvb2tpZUphcihjb29raWVKYXIsQ09PS0lFRklMRSk6CiAgICB0cnk6CiAgICAgICAgY29tcGxldGVfcGF0aD1vcy5wYXRoLmpvaW4ocHJvZmlsZSxDT09LSUVGSUxFKQogICAgICAgIGNvb2tpZUphci5zYXZlKGNvbXBsZXRlX3BhdGgsaWdub3JlX2Rpc2NhcmQ9VHJ1ZSkKICAgIGV4Y2VwdDogcGFzcwoKZGVmIGdldENvb2tpZUphcihDT09LSUVGSUxFKToKCiAgICBjb29raWVKYXI9Tm9uZQogICAgaWYgQ09PS0lFRklMRToKICAgICAgICB0cnk6CiAgICAgICAgICAgIGNvbXBsZXRlX3BhdGg9b3MucGF0aC5qb2luKHByb2ZpbGUsQ09PS0lFRklMRSkKICAgICAgICAgICAgY29va2llSmFyID0gY29va2llbGliLkxXUENvb2tpZUphcigpCiAgICAgICAgICAgIGNvb2tpZUphci5sb2FkKGNvbXBsZXRlX3BhdGgsaWdub3JlX2Rpc2NhcmQ9VHJ1ZSkKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgIGNvb2tpZUphcj1Ob25lCgogICAgaWYgbm90IGNvb2tpZUphcjoKICAgICAgICBjb29raWVKYXIgPSBjb29raWVsaWIuTFdQQ29va2llSmFyKCkKCiAgICByZXR1cm4gY29va2llSmFyCgpkZWYgZG9FdmFsKGZ1bl9jYWxsLHBhZ2VfZGF0YSxDb29raWVfSmFyLG0pOgogICAgcmV0X3ZhbD0nJwogICAgI3ByaW50IGZ1bl9jYWxsCiAgICBpZiBmdW5jdGlvbnNfZGlyIG5vdCBpbiBzeXMucGF0aDoKICAgICAgICBzeXMucGF0aC5hcHBlbmQoZnVuY3Rpb25zX2RpcikKCiAgICBpZiBub3Qgb3MucGF0aC5leGlzdHMoZnVuY3Rpb25zX2Rpcik6CiAgICAgICAgb3MubWFrZWRpcnMoZnVuY3Rpb25zX2RpcikKIAoKICAgIHRyeToKICAgICAgICBweV9maWxlPSdpbXBvcnQgJytmdW5fY2FsbC5zcGxpdCgnLicpWzBdCiMgICAgICAgIHByaW50IHB5X2ZpbGUsc3lzLnBhdGgKICAgICAgICBleGVjKCBweV9maWxlKQojICAgICAgICBwcmludCAnZG9uZScKICAgIGV4Y2VwdDoKICAgICAgICBwcmludCAnZG9FdmFsOiBlcnJvciBpbiBpbXBvcnQnCiAgICAgICAgI3RyYWNlYmFjay5wcmludF9leGMoZmlsZT1zeXMuc3Rkb3V0KQojICAgIHByaW50ICdyZXRfdmFsPScrZnVuX2NhbGwKICAgIGV4ZWMgKCdyZXRfdmFsPScrZnVuX2NhbGwpCiMgICBwcmludCByZXRfdmFsCiAgICAjZXhlYygncmV0X3ZhbD0xKzEnKQogICAgdHJ5OgogICAgICAgIHJldHVybiBzdHIocmV0X3ZhbCkKICAgIGV4Y2VwdDogcmV0dXJuIHJldF92YWwKCmRlZiBkb0V2YWxGdW5jdGlvbihmdW5fY2FsbCxwYWdlX2RhdGEsQ29va2llX0phcixtKToKIyAgICBwcmludCAnZG9FdmFsRnVuY3Rpb24nCiAgICB0cnk6CiAgICAgICAgZ2xvYmFsIGdMU1Byb0R5bmFtaWNDb2RlTnVtYmVyCiAgICAgICAgZ0xTUHJvRHluYW1pY0NvZGVOdW1iZXI9Z0xTUHJvRHluYW1pY0NvZGVOdW1iZXIrMQogICAgICAgIHJldF92YWw9JycKICAgICAgICBwcmludCAnZG9vb29kb28nCiAgICAgICAgaWYgZnVuY3Rpb25zX2RpciBub3QgaW4gc3lzLnBhdGg6CiAgICAgICAgICAgIHN5cy5wYXRoLmFwcGVuZChmdW5jdGlvbnNfZGlyKQogICAgICAgICAgICAKICAgICAgICBpZiBub3Qgb3MucGF0aC5leGlzdHMoZnVuY3Rpb25zX2Rpcik6CiAgICAgICAgICAgIG9zLm1ha2VkaXJzKGZ1bmN0aW9uc19kaXIpCgogICAgICAgIGZpbGVuYW1lPSdMU1Byb2R5bmFtaWNDb2RlJXMucHknJXN0cihnTFNQcm9EeW5hbWljQ29kZU51bWJlcikKICAgICAgICBmaWxlbmFtZXdpdGhwYXRoPW9zLnBhdGguam9pbihmdW5jdGlvbnNfZGlyLGZpbGVuYW1lKQogICAgICAgIGY9b3BlbihmaWxlbmFtZXdpdGhwYXRoLCJ3YiIpCiAgICAgICAgZi53cml0ZSgiIyAtKi0gY29kaW5nOiB1dGYtOCAtKi1cbiIpCiAgICAgICAgZi53cml0ZShmdW5fY2FsbC5lbmNvZGUoInV0Zi04IikpCiAgICAgICAgZi5jbG9zZSgpCiAgICAgICAgcHJpbnQgJ2JlZm9yZSBkbycKICAgICAgICBMU1Byb2R5bmFtaWNDb2RlID0gaW1wb3J0X2J5X3N0cmluZyhmaWxlbmFtZS5zcGxpdCgnLicpWzBdLGZpbGVuYW1ld2l0aHBhdGgpCiAgICAgICAgcHJpbnQgJ2FmdGVyJwogICAgICAgICAKICAgICAgICByZXRfdmFsPUxTUHJvZHluYW1pY0NvZGUuR2V0TFNQcm9EYXRhKHBhZ2VfZGF0YSxDb29raWVfSmFyLG0pCiAgICAgICAgdHJ5OgogICAgICAgICAgICByZXR1cm4gc3RyKHJldF92YWwpCiAgICAgICAgZXhjZXB0OiByZXR1cm4gcmV0X3ZhbAogICAgZXhjZXB0OiB0cmFjZWJhY2sucHJpbnRfZXhjKCkKICAgIHJldHVybiAiIgoKZGVmIGltcG9ydF9ieV9zdHJpbmcoZnVsbF9uYW1lLGZpbGVuYW1ld2l0aHBhdGgpOgogICAgdHJ5OgogICAgICAgIAogICAgICAgIGltcG9ydCBpbXBvcnRsaWIKICAgICAgICByZXR1cm4gaW1wb3J0bGliLmltcG9ydF9tb2R1bGUoZnVsbF9uYW1lLCBwYWNrYWdlPU5vbmUpCiAgICBleGNlcHQ6CiAgICAgICAgaW1wb3J0IGltcAogICAgICAgIHJldHVybiBpbXAubG9hZF9zb3VyY2UoZnVsbF9uYW1lLGZpbGVuYW1ld2l0aHBhdGgpCgpkZWYgZ2V0R29vZ2xlUmVjYXB0Y2hhUmVzcG9uc2UoY2FwdGNoYWtleSwgY2osdHlwZT0xKTogIzEgZm9yIGdldCwgMiBmb3IgcG9zdCwgMyBmb3IgcmF3cG9zdAojICAgICNoZWFkZXJzPVsoJ1VzZXItQWdlbnQnLCdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCA2LjE7IHJ2OjE0LjApIEdlY2tvLzIwMTAwMTAxIEZpcmVmb3gvMTQuMC4xJyldCiMgICAgaHRtbF90ZXh0PWdldFVybCh1cmwsbm9yZWRpcj1UcnVlLCBjb29raWVKYXI9Y2osaGVhZGVycz1oZWFkZXJzKQogIyAgIHByaW50ICdodG1sX3RleHQnLGh0bWxfdGV4dAogICAgcmVjYXBDaGFsbGVuZ2U9IiIKICAgIHNvbHV0aW9uPSIiCiMgICAgY2FwX3JlZz0icmVjYXAuKj9cP2s9KC4qPylcIiIgICAgCiMgICAgbWF0Y2ggPXJlLmZpbmRhbGwoY2FwX3JlZywgaHRtbF90ZXh0KQogICAgCiAgICAgICAgCiMgICAgcHJpbnQgJ21hdGNoJyxtYXRjaAogICAgY2FwdGNoYT1GYWxzZQogICAgY2FwdGNoYV9yZWxvYWRfcmVzcG9uc2VfY2hhbGw9Tm9uZQogICAgc29sdXRpb249Tm9uZQogICAgaWYgbGVuKGNhcHRjaGFrZXkpPjA6ICNuZXcgc2hpbnkgY2FwdGNoYSEKICAgICAgICBjYXB0Y2hhX3VybD1jYXB0Y2hha2V5CiAgICAgICAgaWYgbm90IGNhcHRjaGFfdXJsLnN0YXJ0c3dpdGgoJ2h0dHAnKToKICAgICAgICAgICAgY2FwdGNoYV91cmw9J2h0dHA6Ly93d3cuZ29vZ2xlLmNvbS9yZWNhcHRjaGEvYXBpL2NoYWxsZW5nZT9rPScrY2FwdGNoYV91cmwrJyZhamF4PTEnCiMgICAgICAgIHByaW50ICdjYXB0Y2hhX3VybCcsY2FwdGNoYV91cmwKICAgICAgICBjYXB0Y2hhPVRydWUKCiAgICAgICAgY2FwX2NoYWxsX3JlZz0nY2hhbGxlbmdlLio/XCcoLio/KVwnJwogICAgICAgIGNhcF9pbWFnZV9yZWc9J1wnKC4qPylcJycKICAgICAgICBjYXB0Y2hhX3NjcmlwdD1nZXRVcmwoY2FwdGNoYV91cmwsY29va2llSmFyPWNqKQogICAgICAgIHJlY2FwQ2hhbGxlbmdlPXJlLmZpbmRhbGwoY2FwX2NoYWxsX3JlZywgY2FwdGNoYV9zY3JpcHQpWzBdCiAgICAgICAgY2FwdGNoYV9yZWxvYWQ9J2h0dHA6Ly93d3cuZ29vZ2xlLmNvbS9yZWNhcHRjaGEvYXBpL3JlbG9hZD9jPScKICAgICAgICBjYXB0Y2hhX2s9Y2FwdGNoYV91cmwuc3BsaXQoJ2s9JylbMV0KICAgICAgICBjYXB0Y2hhX3JlbG9hZCs9cmVjYXBDaGFsbGVuZ2UrJyZrPScrY2FwdGNoYV9rKycmcmVhc29uPWkmdHlwZT1pbWFnZSZsYW5nPWVuJwogICAgICAgIGNhcHRjaGFfcmVsb2FkX2pzPWdldFVybChjYXB0Y2hhX3JlbG9hZCxjb29raWVKYXI9Y2opCiAgICAgICAgY2FwdGNoYV9yZWxvYWRfcmVzcG9uc2VfY2hhbGw9cmUuZmluZGFsbChjYXBfaW1hZ2VfcmVnLCBjYXB0Y2hhX3JlbG9hZF9qcylbMF0KICAgICAgICBjYXB0Y2hhX2ltYWdlX3VybD0naHR0cDovL3d3dy5nb29nbGUuY29tL3JlY2FwdGNoYS9hcGkvaW1hZ2U/Yz0nK2NhcHRjaGFfcmVsb2FkX3Jlc3BvbnNlX2NoYWxsCiAgICAgICAgaWYgbm90IGNhcHRjaGFfaW1hZ2VfdXJsLnN0YXJ0c3dpdGgoImh0dHAiKToKICAgICAgICAgICAgY2FwdGNoYV9pbWFnZV91cmw9J2h0dHA6Ly93d3cuZ29vZ2xlLmNvbS9yZWNhcHRjaGEvYXBpLycrY2FwdGNoYV9pbWFnZV91cmwKICAgICAgICBpbXBvcnQgcmFuZG9tCiAgICAgICAgbj1yYW5kb20ucmFuZHJhbmdlKDEwMCwxMDAwLDUpCiAgICAgICAgbG9jYWxfY2FwdGNoYSA9IG9zLnBhdGguam9pbihwcm9maWxlLHN0cihuKSArImNhcHRjaGEuaW1nIiApCiAgICAgICAgbG9jYWxGaWxlID0gb3Blbihsb2NhbF9jYXB0Y2hhLCAid2IiKQogICAgICAgIGxvY2FsRmlsZS53cml0ZShnZXRVcmwoY2FwdGNoYV9pbWFnZV91cmwsY29va2llSmFyPWNqKSkKICAgICAgICBsb2NhbEZpbGUuY2xvc2UoKQogICAgICAgIHNvbHZlciA9IElucHV0V2luZG93KGNhcHRjaGE9bG9jYWxfY2FwdGNoYSkKICAgICAgICBzb2x1dGlvbiA9IHNvbHZlci5nZXQoKQogICAgICAgIG9zLnJlbW92ZShsb2NhbF9jYXB0Y2hhKQoKICAgIGlmIGNhcHRjaGFfcmVsb2FkX3Jlc3BvbnNlX2NoYWxsOgogICAgICAgIGlmIHR5cGU9PTE6CiAgICAgICAgICAgIHJldHVybiAncmVjYXB0Y2hhX2NoYWxsZW5nZV9maWVsZD0nK3VybGxpYi5xdW90ZV9wbHVzKGNhcHRjaGFfcmVsb2FkX3Jlc3BvbnNlX2NoYWxsKSsnJnJlY2FwdGNoYV9yZXNwb25zZV9maWVsZD0nK3VybGxpYi5xdW90ZV9wbHVzKHNvbHV0aW9uKQogICAgICAgIGVsaWYgdHlwZT09MjoKICAgICAgICAgICAgcmV0dXJuICdyZWNhcHRjaGFfY2hhbGxlbmdlX2ZpZWxkOicrY2FwdGNoYV9yZWxvYWRfcmVzcG9uc2VfY2hhbGwrJyxyZWNhcHRjaGFfcmVzcG9uc2VfZmllbGQ6Jytzb2x1dGlvbgogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHJldHVybiAncmVjYXB0Y2hhX2NoYWxsZW5nZV9maWVsZD0nK3VybGxpYi5xdW90ZV9wbHVzKGNhcHRjaGFfcmVsb2FkX3Jlc3BvbnNlX2NoYWxsKSsnJnJlY2FwdGNoYV9yZXNwb25zZV9maWVsZD0nK3VybGxpYi5xdW90ZV9wbHVzKHNvbHV0aW9uKQogICAgZWxzZToKICAgICAgICByZXR1cm4gJycKCmRlZiBnZXRVcmwodXJsLCBjb29raWVKYXI9Tm9uZSxwb3N0PU5vbmUsIHRpbWVvdXQ9MjAsIGhlYWRlcnM9Tm9uZSwgbm9yZWRpcj1GYWxzZSk6CgoKICAgIGNvb2tpZV9oYW5kbGVyID0gdXJsbGliMi5IVFRQQ29va2llUHJvY2Vzc29yKGNvb2tpZUphcikKCiAgICBpZiBub3JlZGlyOgogICAgICAgIG9wZW5lciA9IHVybGxpYjIuYnVpbGRfb3BlbmVyKE5vUmVkaXJlY3Rpb24sY29va2llX2hhbmRsZXIsIHVybGxpYjIuSFRUUEJhc2ljQXV0aEhhbmRsZXIoKSwgdXJsbGliMi5IVFRQSGFuZGxlcigpKQogICAgZWxzZToKICAgICAgICBvcGVuZXIgPSB1cmxsaWIyLmJ1aWxkX29wZW5lcihjb29raWVfaGFuZGxlciwgdXJsbGliMi5IVFRQQmFzaWNBdXRoSGFuZGxlcigpLCB1cmxsaWIyLkhUVFBIYW5kbGVyKCkpCiAgICAjb3BlbmVyID0gdXJsbGliMi5pbnN0YWxsX29wZW5lcihvcGVuZXIpCiAgICByZXEgPSB1cmxsaWIyLlJlcXVlc3QodXJsKQogICAgcmVxLmFkZF9oZWFkZXIoJ1VzZXItQWdlbnQnLCdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCA2LjE7IFdPVzY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMzMuMC4xNzUwLjE1NCBTYWZhcmkvNTM3LjM2JykKICAgIGlmIGhlYWRlcnM6CiAgICAgICAgZm9yIGgsaHYgaW4gaGVhZGVyczoKICAgICAgICAgICAgcmVxLmFkZF9oZWFkZXIoaCxodikKCiAgICByZXNwb25zZSA9IG9wZW5lci5vcGVuKHJlcSxwb3N0LHRpbWVvdXQ9dGltZW91dCkKICAgIGxpbms9cmVzcG9uc2UucmVhZCgpCiAgICByZXNwb25zZS5jbG9zZSgpCiAgICByZXR1cm4gbGluawoKZGVmIGdldF9kZWNvZGUoc3RyLHJlZz1Ob25lKToKICAgIGlmIHJlZzoKICAgICAgICBzdHI9cmUuZmluZGFsbChyZWcsIHN0cilbMF0KICAgIHMxID0gdXJsbGliLnVucXVvdGUoc3RyWzA6IGxlbihzdHIpLTFdKQogICAgdCA9ICcnCiAgICBmb3IgaSBpbiByYW5nZSggbGVuKHMxKSk6CiAgICAgICAgdCArPSBjaHIob3JkKHMxW2ldKSAtIHMxW2xlbihzMSktMV0pCiAgICB0PXVybGxpYi51bnF1b3RlKHQpCiMgICAgcHJpbnQgdAogICAgcmV0dXJuIHQKCmRlZiBqYXZhc2NyaXB0VW5Fc2NhcGUoc3RyKToKICAgIGpzPXJlLmZpbmRhbGwoJ3VuZXNjYXBlXChcJyguKj8pXCcnLHN0cikKIyAgICBwcmludCAnanMnLGpzCiAgICBpZiAobm90IGpzPT1Ob25lKSBhbmQgbGVuKGpzKT4wOgogICAgICAgIGZvciBqIGluIGpzOgogICAgICAgICAgICAjcHJpbnQgdXJsbGliLnVucXVvdGUoaikKICAgICAgICAgICAgc3RyPXN0ci5yZXBsYWNlKGogLHVybGxpYi51bnF1b3RlKGopKQogICAgcmV0dXJuIHN0cgoKaWlkPTAKZGVmIGFza0NhcHRjaGEobSxodG1sX3BhZ2UsIGNvb2tpZUphcik6CiAgICBnbG9iYWwgaWlkCiAgICBpaWQrPTEKICAgIGV4cHJlPSBtWydleHByZXMnXQogICAgcGFnZV91cmwgPSBtWydwYWdlJ10KICAgIGNhcHRjaGFfcmVnZXg9cmUuY29tcGlsZSgnXCRMaXZlU3RyZWFtQ2FwdGNoYVxbKFteXF1dKilcXScpLmZpbmRhbGwoZXhwcmUpWzBdCgogICAgY2FwdGNoYV91cmw9cmUuY29tcGlsZShjYXB0Y2hhX3JlZ2V4KS5maW5kYWxsKGh0bWxfcGFnZSlbMF0KIyAgICBwcmludCBleHByZSxjYXB0Y2hhX3JlZ2V4LGNhcHRjaGFfdXJsCiAgICBpZiBub3QgY2FwdGNoYV91cmwuc3RhcnRzd2l0aCgiaHR0cCIpOgogICAgICAgIHBhZ2VfPSdodHRwOi8vJysiIi5qb2luKHBhZ2VfdXJsLnNwbGl0KCcvJylbMjozXSkKICAgICAgICBpZiBjYXB0Y2hhX3VybC5zdGFydHN3aXRoKCIvIik6CiAgICAgICAgICAgIGNhcHRjaGFfdXJsPXBhZ2VfK2NhcHRjaGFfdXJsCiAgICAgICAgZWxzZToKICAgICAgICAgICAgY2FwdGNoYV91cmw9cGFnZV8rJy8nK2NhcHRjaGFfdXJsCgogICAgbG9jYWxfY2FwdGNoYSA9IG9zLnBhdGguam9pbihwcm9maWxlLCBzdHIoaWlkKSsiY2FwdGNoYS5qcGciICkKICAgIGxvY2FsRmlsZSA9IG9wZW4obG9jYWxfY2FwdGNoYSwgIndiIikKIyAgICBwcmludCAnIGMgY2FwdXJsJyxjYXB0Y2hhX3VybAogICAgcmVxID0gdXJsbGliMi5SZXF1ZXN0KGNhcHRjaGFfdXJsKQogICAgcmVxLmFkZF9oZWFkZXIoJ1VzZXItQWdlbnQnLCAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgNi4xOyBydjoxNC4wKSBHZWNrby8yMDEwMDEwMSBGaXJlZm94LzE0LjAuMScpCiAgICBpZiAncmVmZXJlcicgaW4gbToKICAgICAgICByZXEuYWRkX2hlYWRlcignUmVmZXJlcicsIG1bJ3JlZmVyZXInXSkKICAgIGlmICdhZ2VudCcgaW4gbToKICAgICAgICByZXEuYWRkX2hlYWRlcignVXNlci1hZ2VudCcsIG1bJ2FnZW50J10pCiAgICBpZiAnc2V0Y29va2llJyBpbiBtOgojICAgICAgICBwcmludCAnYWRkaW5nIGNvb2tpZScsbVsnc2V0Y29va2llJ10KICAgICAgICByZXEuYWRkX2hlYWRlcignQ29va2llJywgbVsnc2V0Y29va2llJ10pCgogICAgI2Nvb2tpZV9oYW5kbGVyID0gdXJsbGliMi5IVFRQQ29va2llUHJvY2Vzc29yKGNvb2tpZUphcikKICAgICNvcGVuZXIgPSB1cmxsaWIyLmJ1aWxkX29wZW5lcihjb29raWVfaGFuZGxlciwgdXJsbGliMi5IVFRQQmFzaWNBdXRoSGFuZGxlcigpLCB1cmxsaWIyLkhUVFBIYW5kbGVyKCkpCiAgICAjb3BlbmVyID0gdXJsbGliMi5pbnN0YWxsX29wZW5lcihvcGVuZXIpCiAgICB1cmxsaWIyLnVybG9wZW4ocmVxKQogICAgcmVzcG9uc2UgPSB1cmxsaWIyLnVybG9wZW4ocmVxKQoKICAgIGxvY2FsRmlsZS53cml0ZShyZXNwb25zZS5yZWFkKCkpCiAgICByZXNwb25zZS5jbG9zZSgpCiAgICBsb2NhbEZpbGUuY2xvc2UoKQogICAgc29sdmVyID0gSW5wdXRXaW5kb3coY2FwdGNoYT1sb2NhbF9jYXB0Y2hhKQogICAgc29sdXRpb24gPSBzb2x2ZXIuZ2V0KCkKICAgIHJldHVybiBzb2x1dGlvbgoKZGVmIGFza0NhcHRjaGFOZXcoaW1hZ2VyZWdleCxodG1sX3BhZ2UsY29va2llSmFyLG0pOgogICAgZ2xvYmFsIGlpZAogICAgaWlkKz0xCgoKICAgIGlmIG5vdCBpbWFnZXJlZ2V4PT0nJzoKICAgICAgICBpZiBodG1sX3BhZ2Uuc3RhcnRzd2l0aCgiaHR0cCIpOgogICAgICAgICAgICBwYWdlXz1nZXRVcmwoaHRtbF9wYWdlLGNvb2tpZUphcj1jb29raWVKYXIpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcGFnZV89aHRtbF9wYWdlCiAgICAgICAgY2FwdGNoYV91cmw9cmUuY29tcGlsZShpbWFnZXJlZ2V4KS5maW5kYWxsKGh0bWxfcGFnZSlbMF0KICAgIGVsc2U6CiAgICAgICAgY2FwdGNoYV91cmw9aHRtbF9wYWdlCiAgICAgICAgaWYgJ29uZXBsYXkudHYvZW1iZWQnIGluIGh0bWxfcGFnZToKICAgICAgICAgICAgaW1wb3J0IG9uZXBsYXkKICAgICAgICAgICAgcGFnZV89Z2V0VXJsKGh0bWxfcGFnZSxjb29raWVKYXI9Y29va2llSmFyKQogICAgICAgICAgICBjYXB0Y2hhX3VybD1vbmVwbGF5LmdldENhcHRjaGFVcmwocGFnZV8pCgogICAgbG9jYWxfY2FwdGNoYSA9IG9zLnBhdGguam9pbihwcm9maWxlLCBzdHIoaWlkKSsiY2FwdGNoYS5qcGciICkKICAgIGxvY2FsRmlsZSA9IG9wZW4obG9jYWxfY2FwdGNoYSwgIndiIikKIyAgICBwcmludCAnIGMgY2FwdXJsJyxjYXB0Y2hhX3VybAogICAgcmVxID0gdXJsbGliMi5SZXF1ZXN0KGNhcHRjaGFfdXJsKQogICAgcmVxLmFkZF9oZWFkZXIoJ1VzZXItQWdlbnQnLCAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgNi4xOyBydjoxNC4wKSBHZWNrby8yMDEwMDEwMSBGaXJlZm94LzE0LjAuMScpCiAgICBpZiAncmVmZXJlcicgaW4gbToKICAgICAgICByZXEuYWRkX2hlYWRlcignUmVmZXJlcicsIG1bJ3JlZmVyZXInXSkKICAgIGlmICdhZ2VudCcgaW4gbToKICAgICAgICByZXEuYWRkX2hlYWRlcignVXNlci1hZ2VudCcsIG1bJ2FnZW50J10pCiAgICBpZiAnYWNjZXB0JyBpbiBtOgogICAgICAgIHJlcS5hZGRfaGVhZGVyKCdBY2NlcHQnLCBtWydhY2NlcHQnXSkKICAgIGlmICdzZXRjb29raWUnIGluIG06CiMgICAgICAgIHByaW50ICdhZGRpbmcgY29va2llJyxtWydzZXRjb29raWUnXQogICAgICAgIHJlcS5hZGRfaGVhZGVyKCdDb29raWUnLCBtWydzZXRjb29raWUnXSkKCiAgICAjY29va2llX2hhbmRsZXIgPSB1cmxsaWIyLkhUVFBDb29raWVQcm9jZXNzb3IoY29va2llSmFyKQogICAgI29wZW5lciA9IHVybGxpYjIuYnVpbGRfb3BlbmVyKGNvb2tpZV9oYW5kbGVyLCB1cmxsaWIyLkhUVFBCYXNpY0F1dGhIYW5kbGVyKCksIHVybGxpYjIuSFRUUEhhbmRsZXIoKSkKICAgICNvcGVuZXIgPSB1cmxsaWIyLmluc3RhbGxfb3BlbmVyKG9wZW5lcikKICAgICN1cmxsaWIyLnVybG9wZW4ocmVxKQogICAgcmVzcG9uc2UgPSB1cmxsaWIyLnVybG9wZW4ocmVxKQoKICAgIGxvY2FsRmlsZS53cml0ZShyZXNwb25zZS5yZWFkKCkpCiAgICByZXNwb25zZS5jbG9zZSgpCiAgICBsb2NhbEZpbGUuY2xvc2UoKQogICAgc29sdmVyID0gSW5wdXRXaW5kb3coY2FwdGNoYT1sb2NhbF9jYXB0Y2hhKQogICAgc29sdXRpb24gPSBzb2x2ZXIuZ2V0KCkKICAgIHJldHVybiBzb2x1dGlvbgoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMgRnVuY3Rpb24gIDogR1VJRWRpdEV4cG9ydE5hbWUgICAgICAgICAgICAgICAgICAgICAgICAgIwojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKIyBQYXJhbWV0ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIwojIG5hbWUgICAgICAgIHN1Z2VzdGVkIG5hbWUgZm9yIGV4cG9ydCAgICAgICAgICAgICAgICAgICMKIyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIAojIFJldHVybnMgICA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMKIyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjCiMgbmFtZSAgICAgICAgbmFtZSBvZiBleHBvcnQgZXhjbHVkaW5nIGFueSBleHRlbnNpb24gICAgIwojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCmRlZiBUYWtlSW5wdXQobmFtZSwgaGVhZG5hbWUpOgoKCiAgICBrYiA9IHhibWMuS2V5Ym9hcmQoJ2RlZmF1bHQnLCAnaGVhZGluZycsIFRydWUpCiAgICBrYi5zZXREZWZhdWx0KG5hbWUpCiAgICBrYi5zZXRIZWFkaW5nKGhlYWRuYW1lKQogICAga2Iuc2V0SGlkZGVuSW5wdXQoRmFsc2UpCiAgICByZXR1cm4ga2IuZ2V0VGV4dCgpCiAgIAojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKY2xhc3MgSW5wdXRXaW5kb3coeGJtY2d1aS5XaW5kb3dEaWFsb2cpOgogICAgZGVmIF9faW5pdF9fKHNlbGYsICphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgc2VsZi5jcHRsb2MgPSBrd2FyZ3MuZ2V0KCdjYXB0Y2hhJykKICAgICAgICBzZWxmLmltZyA9IHhibWNndWkuQ29udHJvbEltYWdlKDMzNSwzMCw2MjQsNjAsc2VsZi5jcHRsb2MpCiAgICAgICAgc2VsZi5hZGRDb250cm9sKHNlbGYuaW1nKQogICAgICAgIHNlbGYua2JkID0geGJtYy5LZXlib2FyZCgpCgogICAgZGVmIGdldChzZWxmKToKICAgICAgICBzZWxmLnNob3coKQogICAgICAgIHRpbWUuc2xlZXAoMikKICAgICAgICBzZWxmLmtiZC5kb01vZGFsKCkKICAgICAgICBpZiAoc2VsZi5rYmQuaXNDb25maXJtZWQoKSk6CiAgICAgICAgICAgIHRleHQgPSBzZWxmLmtiZC5nZXRUZXh0KCkKICAgICAgICAgICAgc2VsZi5jbG9zZSgpCiAgICAgICAgICAgIHJldHVybiB0ZXh0CiAgICAgICAgc2VsZi5jbG9zZSgpCiAgICAgICAgcmV0dXJuIEZhbHNlCgpkZWYgZ2V0RXBvY1RpbWUoKToKICAgIGltcG9ydCB0aW1lCiAgICByZXR1cm4gc3RyKGludCh0aW1lLnRpbWUoKSoxMDAwKSkKCmRlZiBnZXRFcG9jVGltZTIoKToKICAgIGltcG9ydCB0aW1lCiAgICByZXR1cm4gc3RyKGludCh0aW1lLnRpbWUoKSkpCgpkZWYgZ2V0X3BhcmFtcygpOgogICAgICAgIHBhcmFtPVtdCiAgICAgICAgcGFyYW1zdHJpbmc9c3lzLmFyZ3ZbMl0KICAgICAgICBpZiBsZW4ocGFyYW1zdHJpbmcpPj0yOgogICAgICAgICAgICBwYXJhbXM9c3lzLmFyZ3ZbMl0KICAgICAgICAgICAgY2xlYW5lZHBhcmFtcz1wYXJhbXMucmVwbGFjZSgnPycsJycpCiAgICAgICAgICAgIGlmIChwYXJhbXNbbGVuKHBhcmFtcyktMV09PScvJyk6CiAgICAgICAgICAgICAgICBwYXJhbXM9cGFyYW1zWzA6bGVuKHBhcmFtcyktMl0KICAgICAgICAgICAgcGFpcnNvZnBhcmFtcz1jbGVhbmVkcGFyYW1zLnNwbGl0KCcmJykKICAgICAgICAgICAgcGFyYW09e30KICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2UobGVuKHBhaXJzb2ZwYXJhbXMpKToKICAgICAgICAgICAgICAgIHNwbGl0cGFyYW1zPXt9CiAgICAgICAgICAgICAgICBzcGxpdHBhcmFtcz1wYWlyc29mcGFyYW1zW2ldLnNwbGl0KCc9JykKICAgICAgICAgICAgICAgIGlmIChsZW4oc3BsaXRwYXJhbXMpKT09MjoKICAgICAgICAgICAgICAgICAgICBwYXJhbVtzcGxpdHBhcmFtc1swXV09c3BsaXRwYXJhbXNbMV0KICAgICAgICByZXR1cm4gcGFyYW0KCmRlZiBnZXRGYXZvcml0ZXMoKToKICAgICAgICBpdGVtcyA9IGpzb24ubG9hZHMob3BlbihmYXZvcml0ZXMpLnJlYWQoKSkKICAgICAgICB0b3RhbCA9IGxlbihpdGVtcykKICAgICAgICBmb3IgaSBpbiBpdGVtczoKICAgICAgICAgICAgbmFtZSA9IGlbMF0KICAgICAgICAgICAgdXJsID0gaVsxXQogICAgICAgICAgICBpY29uaW1hZ2UgPSBpWzJdCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGZhbkFydCA9IGlbM10KICAgICAgICAgICAgICAgIGlmIGZhbkFydCA9PSBOb25lOgogICAgICAgICAgICAgICAgICAgIHJhaXNlCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgIGlmIGFkZG9uLmdldFNldHRpbmcoJ3VzZV90aHVtYicpID09ICJ0cnVlIjoKICAgICAgICAgICAgICAgICAgICBmYW5BcnQgPSBpY29uaW1hZ2UKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgZmFuQXJ0ID0gZmFuYXJ0CiAgICAgICAgICAgIHRyeTogcGxheWxpc3QgPSBpWzVdCiAgICAgICAgICAgIGV4Y2VwdDogcGxheWxpc3QgPSBOb25lCiAgICAgICAgICAgIHRyeTogcmVnZXhzID0gaVs2XQogICAgICAgICAgICBleGNlcHQ6IHJlZ2V4cyA9IE5vbmUKCiAgICAgICAgICAgIGlmIGlbNF0gPT0gMDoKICAgICAgICAgICAgICAgIGFkZExpbmsodXJsLG5hbWUsaWNvbmltYWdlLGZhbkFydCwnJywnJywnJywnZmF2JyxwbGF5bGlzdCxyZWdleHMsdG90YWwpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBhZGREaXIobmFtZSx1cmwsaVs0XSxpY29uaW1hZ2UsZmFuYXJ0LCcnLCcnLCcnLCcnLCdmYXYnKQoKZGVmIGFkZEZhdm9yaXRlKG5hbWUsdXJsLGljb25pbWFnZSxmYW5hcnQsbW9kZSxwbGF5bGlzdD1Ob25lLHJlZ2V4cz1Ob25lKToKICAgICAgICBmYXZMaXN0ID0gW10KICAgICAgICB0cnk6CiAgICAgICAgICAgICMgc2VlbXMgdGhhdCBhZnRlcgogICAgICAgICAgICBuYW1lID0gbmFtZS5lbmNvZGUoJ3V0Zi04JywgJ2lnbm9yZScpCiAgICAgICAgZXhjZXB0OgogICAgICAgICAgICBwYXNzCiAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoZmF2b3JpdGVzKT09RmFsc2U6CiAgICAgICAgICAgIGFkZG9uX2xvZygnTWFraW5nIEZhdm9yaXRlcyBGaWxlJykKICAgICAgICAgICAgZmF2TGlzdC5hcHBlbmQoKG5hbWUsdXJsLGljb25pbWFnZSxmYW5hcnQsbW9kZSxwbGF5bGlzdCxyZWdleHMpKQogICAgICAgICAgICBhID0gb3BlbihmYXZvcml0ZXMsICJ3IikKICAgICAgICAgICAgYS53cml0ZShqc29uLmR1bXBzKGZhdkxpc3QpKQogICAgICAgICAgICBhLmNsb3NlKCkKICAgICAgICBlbHNlOgogICAgICAgICAgICBhZGRvbl9sb2coJ0FwcGVuZGluZyBGYXZvcml0ZXMnKQogICAgICAgICAgICBhID0gb3BlbihmYXZvcml0ZXMpLnJlYWQoKQogICAgICAgICAgICBkYXRhID0ganNvbi5sb2FkcyhhKQogICAgICAgICAgICBkYXRhLmFwcGVuZCgobmFtZSx1cmwsaWNvbmltYWdlLGZhbmFydCxtb2RlKSkKICAgICAgICAgICAgYiA9IG9wZW4oZmF2b3JpdGVzLCAidyIpCiAgICAgICAgICAgIGIud3JpdGUoanNvbi5kdW1wcyhkYXRhKSkKICAgICAgICAgICAgYi5jbG9zZSgpCgpkZWYgcm1GYXZvcml0ZShuYW1lKToKICAgICAgICBkYXRhID0ganNvbi5sb2FkcyhvcGVuKGZhdm9yaXRlcykucmVhZCgpKQogICAgICAgIGZvciBpbmRleCBpbiByYW5nZShsZW4oZGF0YSkpOgogICAgICAgICAgICBpZiBkYXRhW2luZGV4XVswXT09bmFtZToKICAgICAgICAgICAgICAgIGRlbCBkYXRhW2luZGV4XQogICAgICAgICAgICAgICAgYiA9IG9wZW4oZmF2b3JpdGVzLCAidyIpCiAgICAgICAgICAgICAgICBiLndyaXRlKGpzb24uZHVtcHMoZGF0YSkpCiAgICAgICAgICAgICAgICBiLmNsb3NlKCkKICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgeGJtYy5leGVjdXRlYnVpbHRpbigiWEJNQy5Db250YWluZXIuUmVmcmVzaCIpCgpkZWYgdXJsc29sdmVyKHVybCk6CiAgICBpbXBvcnQgcmVzb2x2ZXVybAogICAgaG9zdCA9IHJlc29sdmV1cmwuSG9zdGVkTWVkaWFGaWxlKHVybCkKICAgIGlmIGhvc3Q6CiAgICAgICAgcmVzb2x2ZXIgPSByZXNvbHZldXJsLnJlc29sdmUodXJsKQogICAgICAgIHJlc29sdmVkID0gcmVzb2x2ZXIKICAgICAgICBpZiBpc2luc3RhbmNlKHJlc29sdmVkLGxpc3QpOgogICAgICAgICAgICBmb3IgayBpbiByZXNvbHZlZDoKICAgICAgICAgICAgICAgIHF1YWxpdHkgPSBhZGRvbi5nZXRTZXR0aW5nKCdxdWFsaXR5JykKICAgICAgICAgICAgICAgIGlmIGtbJ3F1YWxpdHknXSA9PSAnSEQnICA6CiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXIgPSBrWyd1cmwnXQogICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICBlbGlmIGtbJ3F1YWxpdHknXSA9PSAnU0QnIDoKICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IGtbJ3VybCddCiAgICAgICAgICAgICAgICBlbGlmIGtbJ3F1YWxpdHknXSA9PSAnMTA4MHAnIGFuZCBhZGRvbi5nZXRTZXR0aW5nKCcxMDgwcHF1YWxpdHknKSA9PSAndHJ1ZScgOgogICAgICAgICAgICAgICAgICAgIHJlc29sdmVyID0ga1sndXJsJ10KICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHJlc29sdmVyID0gcmVzb2x2ZWQKICAgIGVsc2U6CiAgICAgICAgeGJtYy5leGVjdXRlYnVpbHRpbigiWEJNQy5Ob3RpZmljYXRpb24oRmlyZVRWLHJlc29sdmV1cmwgZG9ub3Qgc3VwcG9ydCB0aGlzIGRvbWFpbi4gLSAsNTAwMCkiKQogICAgICAgIHJlc29sdmVyPXVybAogICAgcmV0dXJuIHJlc29sdmVyCgpkZWYgdHJ5cGxheSh1cmwsbGlzdGl0ZW0scGRpYWxvZ3VlPU5vbmUpOiAgICAKCiAgICBpZiB1cmwubG93ZXIoKS5zdGFydHN3aXRoKCdwbHVnaW4nKSBhbmQgJ3lvdXR1YmUnIG5vdCBpbiAgdXJsLmxvd2VyKCk6CiAgICAgICAgcHJpbnQgJ3BsYXlpbmcgdmlhIHJ1bnBsdWdpbicKICAgICAgICB4Ym1jLmV4ZWN1dGVidWlsdGluKCdYQk1DLlJ1blBsdWdpbignK3VybCsnKScpIAogICAgICAgIGZvciBpIGluIHJhbmdlKDgpOgogICAgICAgICAgICB4Ym1jLnNsZWVwKDUwMCkgIyNzbGVlcCBmb3IgMTAgc2Vjb25kcywgaGFsZiBlYWNoIHRpbWUKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgI3ByaW50ICdjb25kaScKICAgICAgICAgICAgICAgIGlmIHhibWMuZ2V0Q29uZFZpc2liaWxpdHkoIlBsYXllci5IYXNNZWRpYSIpIGFuZCB4Ym1jLlBsYXllcigpLmlzUGxheWluZygpOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBUcnVlCiAgICAgICAgICAgIGV4Y2VwdDogcGFzcwogICAgICAgIHByaW50ICdyZXR1cm5pbmcgbm93JwogICAgICAgIHJldHVybiBGYWxzZQogICAgaW1wb3J0ICBDdXN0b21QbGF5ZXIsdGltZQoKICAgIHBsYXllciA9IEN1c3RvbVBsYXllci5NeVhCTUNQbGF5ZXIoKQogICAgcGxheWVyLnBkaWFsb2d1ZT1wZGlhbG9ndWUKICAgIHN0YXJ0ID0gdGltZS50aW1lKCkgCiAgICAjeGJtYy5QbGF5ZXIoKS5wbGF5KCBsaXZlTGluayxsaXN0aXRlbSkKICAgIHByaW50ICdnb2luZyB0byBwbGF5JwogICAgaW1wb3J0IHRpbWUKICAgIGJlZm9yZXN0YXJ0PXRpbWUudGltZSgpCiAgICBwbGF5ZXIucGxheSggdXJsLCBsaXN0aXRlbSkKICAgIHhibWMuc2xlZXAoMTAwMCkKICAgIAogICAgdHJ5OgogICAgICAgIHdoaWxlIHBsYXllci5pc19hY3RpdmU6CiAgICAgICAgICAgIHhibWMuc2xlZXAoNDAwKQogICAgICAgICAgIAogICAgICAgICAgICBpZiBwbGF5ZXIudXJscGxheWVkOgogICAgICAgICAgICAgICAgcHJpbnQgJ3llcyBwbGF5ZWQnCiAgICAgICAgICAgICAgICByZXR1cm4gVHJ1ZQogICAgICAgICAgICBpZiB0aW1lLnRpbWUoKS1iZWZvcmVzdGFydD40OiByZXR1cm4gRmFsc2UKICAgICAgICAgICAgI3hibWMuc2xlZXAoMTAwMCkKICAgIGV4Y2VwdDogcGFzcwogICAgcHJpbnQgJ25vdCBwbGF5ZWQnLHVybAogICAgcmV0dXJuIEZhbHNlCgpkZWYgcGxheV9wbGF5bGlzdChuYW1lLCBtdV9wbGF5bGlzdCxxdWV1ZVZpZGVvPU5vbmUpOgogICAgICAgIHBsYXlsaXN0ID0geGJtYy5QbGF5TGlzdCh4Ym1jLlBMQVlMSVNUX1ZJREVPKQogICAgICAgICNwcmludCAnbXVfcGxheWxpc3QnLG11X3BsYXlsaXN0CiAgICAgICAgaWYgJyQkTFNQbGF5T25seU9uZSQkJyBpbiBtdV9wbGF5bGlzdFswXToKICAgICAgICAgICAgbXVfcGxheWxpc3RbMF09bXVfcGxheWxpc3RbMF0ucmVwbGFjZSgnJCRMU1BsYXlPbmx5T25lJCQnLCcnKQogICAgICAgICAgICBpbXBvcnQgdXJscGFyc2UKICAgICAgICAgICAgbmFtZXMgPSBbXQogICAgICAgICAgICBpbG9vcD0wCiAgICAgICAgICAgIHByb2dyZXNzID0geGJtY2d1aS5EaWFsb2dQcm9ncmVzcygpCiAgICAgICAgICAgIHByb2dyZXNzLmNyZWF0ZSgnUHJvZ3Jlc3MnLCAnVHJ5aW5nIE11bHRpcGxlIExpbmtzJykKICAgICAgICAgICAgZm9yIGkgaW4gbXVfcGxheWxpc3Q6CiAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICBpZiAnJCRsc25hbWU9JyBpbiBpOgogICAgICAgICAgICAgICAgICAgIGRfbmFtZT1pLnNwbGl0KCckJGxzbmFtZT0nKVsxXS5zcGxpdCgnJnJlZ2V4cycpWzBdCiAgICAgICAgICAgICAgICAgICAgbmFtZXMuYXBwZW5kKGRfbmFtZSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBtdV9wbGF5bGlzdFtpbG9vcF09aS5zcGxpdCgnJCRsc25hbWU9JylbMF0rKCcmcmVnZXhzJytpLnNwbGl0KCcmcmVnZXhzJylbMV0gaWYgJyZyZWdleHMnIGluIGkgZWxzZSAnJykgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBkX25hbWU9dXJscGFyc2UudXJscGFyc2UoaSkubmV0bG9jCiAgICAgICAgICAgICAgICAgICAgaWYgZF9uYW1lID09ICcnOgogICAgICAgICAgICAgICAgICAgICAgICBuYW1lcy5hcHBlbmQobmFtZSkKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICBuYW1lcy5hcHBlbmQoZF9uYW1lKQogICAgICAgICAgICAgICAgaW5kZXg9aWxvb3AKICAgICAgICAgICAgICAgIGlsb29wKz0xCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIHBsYXluYW1lPW5hbWVzW2luZGV4XQogICAgICAgICAgICAgICAgaWYgcHJvZ3Jlc3MuaXNjYW5jZWxlZCgpOiByZXR1cm4gCiAgICAgICAgICAgICAgICBwcm9ncmVzcy51cGRhdGUoIGlsb29wL2xlbihtdV9wbGF5bGlzdCkqMTAwLCIiLCAiTGluayMlZCIlKGlsb29wKSxwbGF5bmFtZSAgKQogICAgICAgICAgICAgICAgcHJpbnQgJ2F1dG8gcGxheW5hbWV4eCcscGxheW5hbWUKICAgICAgICAgICAgICAgIGlmICImbW9kZT0xOSIgaW4gbXVfcGxheWxpc3RbaW5kZXhdOgogICAgICAgICAgICAgICAgICAgICAgICAjcGxheXNldHJlc29sdmVkICh1cmxzb2x2ZXIobXVfcGxheWxpc3RbaW5kZXhdLnJlcGxhY2UoJyZtb2RlPTE5JywnJykpLG5hbWUsaWNvbmltYWdlLFRydWUpCiAgICAgICAgICAgICAgICAgICAgbGl6ID0geGJtY2d1aS5MaXN0SXRlbShwbGF5bmFtZSwgaWNvbkltYWdlPWljb25pbWFnZSwgdGh1bWJuYWlsSW1hZ2U9aWNvbmltYWdlKQogICAgICAgICAgICAgICAgICAgIGxpei5zZXRJbmZvKHR5cGU9J1ZpZGVvJywgaW5mb0xhYmVscz17J1RpdGxlJzpwbGF5bmFtZSwnbWVkaWF0eXBlJzondmlkZW8nfSkKICAgICAgICAgICAgICAgICAgICBsaXouc2V0UHJvcGVydHkoIklzUGxheWFibGUiLCJ0cnVlIikKICAgICAgICAgICAgICAgICAgICB1cmx0b3BsYXk9dXJsc29sdmVyKG11X3BsYXlsaXN0W2luZGV4XS5yZXBsYWNlKCcmbW9kZT0xOScsJycpLnJlcGxhY2UoJzsnLCcnKSkKICAgICAgICAgICAgICAgICAgICBsaXouc2V0UGF0aCh1cmx0b3BsYXkpCiAgICAgICAgICAgICAgICAgICAgI3hibWMuUGxheWVyKCkucGxheSh1cmx0b3BsYXksbGl6KQogICAgICAgICAgICAgICAgICAgIHBsYXllZD10cnlwbGF5KHVybHRvcGxheSxsaXopCiAgICAgICAgICAgICAgICBlbGlmICIkZG9yZWdleCIgaW4gbXVfcGxheWxpc3RbaW5kZXhdIDoKIyAgICAgICAgICAgICAgICAgICAgcHJpbnQgbXVfcGxheWxpc3RbaW5kZXhdCiAgICAgICAgICAgICAgICAgICAgc2VwYXRlID0gbXVfcGxheWxpc3RbaW5kZXhdLnNwbGl0KCcmcmVnZXhzPScpCiMgICAgICAgICAgICAgICAgICAgIHByaW50IHNlcGF0ZQogICAgICAgICAgICAgICAgICAgIHVybCxzZXRyZXNvbHZlZCA9IGdldFJlZ2V4UGFyc2VkKHNlcGF0ZVsxXSwgc2VwYXRlWzBdKQogICAgICAgICAgICAgICAgICAgIHVybDIgPSB1cmwucmVwbGFjZSgnOycsJycpCiAgICAgICAgICAgICAgICAgICAgbGl6ID0geGJtY2d1aS5MaXN0SXRlbShwbGF5bmFtZSwgaWNvbkltYWdlPWljb25pbWFnZSwgdGh1bWJuYWlsSW1hZ2U9aWNvbmltYWdlKQogICAgICAgICAgICAgICAgICAgIGxpei5zZXRJbmZvKHR5cGU9J1ZpZGVvJywgaW5mb0xhYmVscz17J1RpdGxlJzpwbGF5bmFtZSwnbWVkaWF0eXBlJzondmlkZW8nfSkKICAgICAgICAgICAgICAgICAgICBsaXouc2V0UHJvcGVydHkoIklzUGxheWFibGUiLCJ0cnVlIikKICAgICAgICAgICAgICAgICAgICBsaXouc2V0UGF0aCh1cmwyKQogICAgICAgICAgICAgICAgICAgICN4Ym1jLlBsYXllcigpLnBsYXkodXJsMixsaXopCiAgICAgICAgICAgICAgICAgICAgcGxheWVkPXRyeXBsYXkodXJsMixsaXopCgogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICB1cmwgPSBtdV9wbGF5bGlzdFtpbmRleF0KICAgICAgICAgICAgICAgICAgICB1cmw9dXJsLnNwbGl0KCcmcmVnZXhzPScpWzBdCiAgICAgICAgICAgICAgICAgICAgbGl6ID0geGJtY2d1aS5MaXN0SXRlbShwbGF5bmFtZSwgaWNvbkltYWdlPWljb25pbWFnZSwgdGh1bWJuYWlsSW1hZ2U9aWNvbmltYWdlKQogICAgICAgICAgICAgICAgICAgIGxpei5zZXRJbmZvKHR5cGU9J1ZpZGVvJywgaW5mb0xhYmVscz17J1RpdGxlJzpwbGF5bmFtZSwnbWVkaWF0eXBlJzondmlkZW8nfSkKICAgICAgICAgICAgICAgICAgICBsaXouc2V0UHJvcGVydHkoIklzUGxheWFibGUiLCJ0cnVlIikKICAgICAgICAgICAgICAgICAgICBsaXouc2V0UGF0aCh1cmwpCiAgICAgICAgICAgICAgICAgICAgI3hibWMuUGxheWVyKCkucGxheSh1cmwsbGl6KQogICAgICAgICAgICAgICAgICAgIHBsYXllZD10cnlwbGF5KHVybCxsaXopCiAgICAgICAgICAgICAgICAgICAgcHJpbnQgJ3BsYXllZCcscGxheWVkCiAgICAgICAgICAgICAgICBwcmludCAncGxheWVkJyxwbGF5ZWQKICAgICAgICAgICAgICAgIGlmIHBsYXllZDogcmV0dXJuCiAgICAgICAgICAgIHJldHVybiAgICAgCiAgICAgICAgaWYgYWRkb24uZ2V0U2V0dGluZygnYXNrX3BsYXlsaXN0X2l0ZW1zJykgPT0gJ3RydWUnIGFuZCBub3QgcXVldWVWaWRlbyA6CiAgICAgICAgICAgIGltcG9ydCB1cmxwYXJzZQogICAgICAgICAgICBuYW1lcyA9IFtdCiAgICAgICAgICAgIGlsb29wPTAKICAgICAgICAgICAgZm9yIGkgaW4gbXVfcGxheWxpc3Q6CiAgICAgICAgICAgICAgICBpZiAnJCRsc25hbWU9JyBpbiBpOgogICAgICAgICAgICAgICAgICAgIGRfbmFtZT1pLnNwbGl0KCckJGxzbmFtZT0nKVsxXS5zcGxpdCgnJnJlZ2V4cycpWzBdCiAgICAgICAgICAgICAgICAgICAgbmFtZXMuYXBwZW5kKGRfbmFtZSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBtdV9wbGF5bGlzdFtpbG9vcF09aS5zcGxpdCgnJCRsc25hbWU9JylbMF0rKCcmcmVnZXhzJytpLnNwbGl0KCcmcmVnZXhzJylbMV0gaWYgJyZyZWdleHMnIGluIGkgZWxzZSAnJykgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBkX25hbWU9dXJscGFyc2UudXJscGFyc2UoaSkubmV0bG9jCiAgICAgICAgICAgICAgICAgICAgaWYgZF9uYW1lID09ICcnOgogICAgICAgICAgICAgICAgICAgICAgICBuYW1lcy5hcHBlbmQobmFtZSkKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICBuYW1lcy5hcHBlbmQoZF9uYW1lKQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWxvb3ArPTEKICAgICAgICAgICAgZGlhbG9nID0geGJtY2d1aS5EaWFsb2coKQogICAgICAgICAgICBpbmRleCA9IGRpYWxvZy5zZWxlY3QoJ0Nob29zZSBhIHZpZGVvIHNvdXJjZScsIG5hbWVzKQogICAgICAgICAgICBpZiBpbmRleCA+PSAwOgogICAgICAgICAgICAgICAgcGxheW5hbWU9bmFtZXNbaW5kZXhdCiAgICAgICAgICAgICAgICBwcmludCAncGxheW5hbWV4eCcscGxheW5hbWUKICAgICAgICAgICAgICAgIGlmICImbW9kZT0xOSIgaW4gbXVfcGxheWxpc3RbaW5kZXhdOgogICAgICAgICAgICAgICAgICAgICAgICAjcGxheXNldHJlc29sdmVkICh1cmxzb2x2ZXIobXVfcGxheWxpc3RbaW5kZXhdLnJlcGxhY2UoJyZtb2RlPTE5JywnJykpLG5hbWUsaWNvbmltYWdlLFRydWUpCiAgICAgICAgICAgICAgICAgICAgbGl6ID0geGJtY2d1aS5MaXN0SXRlbShwbGF5bmFtZSwgaWNvbkltYWdlPWljb25pbWFnZSwgdGh1bWJuYWlsSW1hZ2U9aWNvbmltYWdlKQogICAgICAgICAgICAgICAgICAgIGxpei5zZXRJbmZvKHR5cGU9J1ZpZGVvJywgaW5mb0xhYmVscz17J1RpdGxlJzpwbGF5bmFtZSwnbWVkaWF0eXBlJzondmlkZW8nfSkKICAgICAgICAgICAgICAgICAgICBsaXouc2V0UHJvcGVydHkoIklzUGxheWFibGUiLCJ0cnVlIikKICAgICAgICAgICAgICAgICAgICB1cmx0b3BsYXk9dXJsc29sdmVyKG11X3BsYXlsaXN0W2luZGV4XS5yZXBsYWNlKCcmbW9kZT0xOScsJycpLnJlcGxhY2UoJzsnLCcnKSkKICAgICAgICAgICAgICAgICAgICBsaXouc2V0UGF0aCh1cmx0b3BsYXkpCiAgICAgICAgICAgICAgICAgICAgeGJtYy5QbGF5ZXIoKS5wbGF5KHVybHRvcGxheSxsaXopCiAgICAgICAgICAgICAgICBlbGlmICIkZG9yZWdleCIgaW4gbXVfcGxheWxpc3RbaW5kZXhdIDoKIyAgICAgICAgICAgICAgICAgICAgcHJpbnQgbXVfcGxheWxpc3RbaW5kZXhdCiAgICAgICAgICAgICAgICAgICAgc2VwYXRlID0gbXVfcGxheWxpc3RbaW5kZXhdLnNwbGl0KCcmcmVnZXhzPScpCiMgICAgICAgICAgICAgICAgICAgIHByaW50IHNlcGF0ZQogICAgICAgICAgICAgICAgICAgIHVybCxzZXRyZXNvbHZlZCA9IGdldFJlZ2V4UGFyc2VkKHNlcGF0ZVsxXSwgc2VwYXRlWzBdKQogICAgICAgICAgICAgICAgICAgIHVybDIgPSB1cmwucmVwbGFjZSgnOycsJycpCiAgICAgICAgICAgICAgICAgICAgbGl6ID0geGJtY2d1aS5MaXN0SXRlbShwbGF5bmFtZSwgaWNvbkltYWdlPWljb25pbWFnZSwgdGh1bWJuYWlsSW1hZ2U9aWNvbmltYWdlKQogICAgICAgICAgICAgICAgICAgIGxpei5zZXRJbmZvKHR5cGU9J1ZpZGVvJywgaW5mb0xhYmVscz17J1RpdGxlJzpwbGF5bmFtZSwnbWVkaWF0eXBlJzondmlkZW8nfSkKICAgICAgICAgICAgICAgICAgICBsaXouc2V0UHJvcGVydHkoIklzUGxheWFibGUiLCJ0cnVlIikKICAgICAgICAgICAgICAgICAgICBsaXouc2V0UGF0aCh1cmwyKQogICAgICAgICAgICAgICAgICAgIHhibWMuUGxheWVyKCkucGxheSh1cmwyLGxpeikKCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIHVybCA9IG11X3BsYXlsaXN0W2luZGV4XQogICAgICAgICAgICAgICAgICAgIHVybD11cmwuc3BsaXQoJyZyZWdleHM9JylbMF0KICAgICAgICAgICAgICAgICAgICBsaXogPSB4Ym1jZ3VpLkxpc3RJdGVtKHBsYXluYW1lLCBpY29uSW1hZ2U9aWNvbmltYWdlLCB0aHVtYm5haWxJbWFnZT1pY29uaW1hZ2UpCiAgICAgICAgICAgICAgICAgICAgbGl6LnNldEluZm8odHlwZT0nVmlkZW8nLCBpbmZvTGFiZWxzPXsnVGl0bGUnOnBsYXluYW1lLCdtZWRpYXR5cGUnOid2aWRlbyd9KQogICAgICAgICAgICAgICAgICAgIGxpei5zZXRQcm9wZXJ0eSgiSXNQbGF5YWJsZSIsInRydWUiKQogICAgICAgICAgICAgICAgICAgIGxpei5zZXRQYXRoKHVybCkKICAgICAgICAgICAgICAgICAgICB4Ym1jLlBsYXllcigpLnBsYXkodXJsLGxpeikKICAgICAgICBlbGlmIG5vdCBxdWV1ZVZpZGVvOgogICAgICAgICAgICAjcGxheWxpc3QgPSB4Ym1jLlBsYXlMaXN0KDEpICMgMSBtZWFucyB2aWRlbwogICAgICAgICAgICBwbGF5bGlzdC5jbGVhcigpCiAgICAgICAgICAgIGl0ZW0gPSAwCiAgICAgICAgICAgIGZvciBpIGluIG11X3BsYXlsaXN0OgogICAgICAgICAgICAgICAgaXRlbSArPSAxCiAgICAgICAgICAgICAgICBpbmZvID0geGJtY2d1aS5MaXN0SXRlbSgnJXMpICVzJyAlKHN0cihpdGVtKSxuYW1lKSkKICAgICAgICAgICAgICAgICMgRG9uJ3QgZG8gdGhpcyBhcyByZWdleCBwYXJzZWQgbWlnaHQgdGFrZSBsb25nZXIKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICBpZiAiJGRvcmVnZXgiIGluIGk6CiAgICAgICAgICAgICAgICAgICAgICAgIHNlcGF0ZSA9IGkuc3BsaXQoJyZyZWdleHM9JykKIyAgICAgICAgICAgICAgICAgICAgICAgIHByaW50IHNlcGF0ZQogICAgICAgICAgICAgICAgICAgICAgICB1cmwsc2V0cmVzb2x2ZWQgPSBnZXRSZWdleFBhcnNlZChzZXBhdGVbMV0sIHNlcGF0ZVswXSkKICAgICAgICAgICAgICAgICAgICBlbGlmICImbW9kZT0xOSIgaW4gaToKICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdXJsc29sdmVyKGkucmVwbGFjZSgnJm1vZGU9MTknLCcnKS5yZXBsYWNlKCc7JywnJykpICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgaWYgdXJsOgogICAgICAgICAgICAgICAgICAgICAgICBwbGF5bGlzdC5hZGQodXJsLCBpbmZvKQogICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgIHJhaXNlCiAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgIHBsYXlsaXN0LmFkZChpLCBpbmZvKQogICAgICAgICAgICAgICAgICAgIHBhc3MgI3hibWMuUGxheWVyKCkucGxheSh1cmwpCgogICAgICAgICAgICB4Ym1jLmV4ZWN1dGVidWlsdGluKCdwbGF5bGlzdC5wbGF5b2Zmc2V0KHZpZGVvLDApJykKICAgICAgICBlbHNlOgoKICAgICAgICAgICAgICAgIGxpc3RpdGVtID0geGJtY2d1aS5MaXN0SXRlbShuYW1lKQogICAgICAgICAgICAgICAgcGxheWxpc3QuYWRkKG11X3BsYXlsaXN0LCBsaXN0aXRlbSkKCmRlZiBkb3dubG9hZF9maWxlKG5hbWUsIHVybCk6CiAgICAgICAgCiAgICAgICAgaWYgYWRkb24uZ2V0U2V0dGluZygnc2F2ZV9sb2NhdGlvbicpID09ICIiOgogICAgICAgICAgICB4Ym1jLmV4ZWN1dGVidWlsdGluKCJYQk1DLk5vdGlmaWNhdGlvbignRmlyZVRWJywnQ2hvb3NlIGEgbG9jYXRpb24gdG8gc2F2ZSBmaWxlcy4nLDE1MDAwLCIraWNvbisiKSIpCiAgICAgICAgICAgIGFkZG9uLm9wZW5TZXR0aW5ncygpCiAgICAgICAgcGFyYW1zID0geyd1cmwnOiB1cmwsICdkb3dubG9hZF9wYXRoJzogYWRkb24uZ2V0U2V0dGluZygnc2F2ZV9sb2NhdGlvbicpfQogICAgICAgIGRvd25sb2FkZXIuZG93bmxvYWQobmFtZSwgcGFyYW1zKQogICAgICAgIGRpYWxvZyA9IHhibWNndWkuRGlhbG9nKCkKICAgICAgICByZXQgPSBkaWFsb2cueWVzbm8oJ0ZpcmVUVicsICdEbyB5b3Ugd2FudCB0byBhZGQgdGhpcyBmaWxlIGFzIGEgc291cmNlPycpCiAgICAgICAgaWYgcmV0OgogICAgICAgICAgICBhZGRTb3VyY2Uob3MucGF0aC5qb2luKGFkZG9uLmdldFNldHRpbmcoJ3NhdmVfbG9jYXRpb24nKSwgbmFtZSkpCgpkZWYgX3NlYXJjaCh1cmwsbmFtZSk6CiAgICMgcHJpbnQgdXJsLG5hbWUKICAgIHBsdWdpbnNlYXJjaHVybHMgPSBbJ3BsdWdpbjovL3BsdWdpbi52aWRlby5nZW5lc2lzLz9hY3Rpb249c2hvd3Nfc2VhcmNoJyxcCiAgICAgICAgICAgICAncGx1Z2luOi8vcGx1Z2luLnZpZGVvLmdlbmVzaXMvP2FjdGlvbj1tb3ZpZXNfc2VhcmNoJyxcCiAgICAgICAgICAgICAncGx1Z2luOi8vcGx1Z2luLnZpZGVvLnNhbHRzLz9tb2RlPXNlYXJjaCZhbXA7c2VjdGlvbj1Nb3ZpZXMnLFwKICAgICAgICAgICAgICdwbHVnaW46Ly9wbHVnaW4udmlkZW8uc2FsdHMvP21vZGU9c2VhcmNoJmFtcDtzZWN0aW9uPVRWJyxcCiAgICAgICAgICAgICAncGx1Z2luOi8vcGx1Z2luLnZpZGVvLm11Y2htb3ZpZXMuaGQvP2FjdGlvbj1tb3ZpZXNfc2VhcmNoJyxcCiAgICAgICAgICAgICAncGx1Z2luOi8vcGx1Z2luLnZpZGVvLnZpb296LmNvLz9hY3Rpb249cm9vdF9zZWFyY2gnLFwKICAgICAgICAgICAgICdwbHVnaW46Ly9wbHVnaW4udmlkZW8ub3Jvcm90di8/YWN0aW9uPXNob3dzX3NlYXJjaCcsXAogICAgICAgICAgICAgJ3BsdWdpbjovL3BsdWdpbi52aWRlby55aWZ5bW92aWVzLmhkLz9hY3Rpb249bW92aWVzX3NlYXJjaCcsXAogICAgICAgICAgICAgJ3BsdWdpbjovL3BsdWdpbi52aWRlby5jYXJ0b29uaGR0d28vP2Rlc2NyaXB0aW9uJmFtcDtmYW5hcnQmYW1wO2ljb25pbWFnZSZhbXA7bW9kZT0zJmFtcDtuYW1lPVNlYXJjaCZhbXA7dXJsPXVybCcsXAogICAgICAgICAgICAgJ3BsdWdpbjovL3BsdWdpbi52aWRlby55b3V0dWJlL2tvZGlvbi9zZWFyY2gvbGlzdC8nLFwKICAgICAgICAgICAgICdwbHVnaW46Ly9wbHVnaW4udmlkZW8uZGFpbHltb3Rpb25fY29tLz9tb2RlPXNlYXJjaCZhbXA7dXJsJyxcCiAgICAgICAgICAgICAncGx1Z2luOi8vcGx1Z2luLnZpZGVvLnZpbWVvL2tvZGlvbi9zZWFyY2gvbGlzdC8nXAogICAgICAgICAgICAgXQogICAgbmFtZXMgPSBbJ0dlbnNpcyBUVicsJ0dlbmVzaXMgTW92aWUnLCdTYWx0IG1vdmllJywnc2FsdCBUVicsJ011Y2htb3ZpZXMnLCd2aW9veicsJ09Sb3JvVFYnLFwKICAgICAgICAgICAgICdZaWZ5bW92aWVzJywnY2FydG9vbkhEJywnWW91dHViZScsJ0RhaWx5TW90aW9uJywnVmltZW8nXQogICAgZGlhbG9nID0geGJtY2d1aS5EaWFsb2coKQogICAgaW5kZXggPSBkaWFsb2cuc2VsZWN0KCdDaG9vc2UgYSB2aWRlbyBzb3VyY2UnLCBuYW1lcykKCiAgICBpZiBpbmRleCA+PSAwOgogICAgICAgIHVybCA9IHBsdWdpbnNlYXJjaHVybHNbaW5kZXhdCiMgICAgICAgIHByaW50ICd1cmwnLHVybAogICAgICAgIHBsdWdpbnF1ZXJ5YnlKU09OKHVybCkKCmRlZiBhZGREaXIobmFtZSx1cmwsbW9kZSxpY29uaW1hZ2UsZmFuYXJ0LGRlc2NyaXB0aW9uLGdlbnJlLGRhdGUsY3JlZGl0cyxzaG93Y29udGV4dD1GYWxzZSxyZWdleHM9Tm9uZSxyZWdfdXJsPU5vbmUsYWxsaW5mbz17fSk6CgogICAgICAgICNwcmludCAnYWRkRGlyJwoKICAgICAgICBpZiByZWdleHMgYW5kIGxlbihyZWdleHMpPjA6CiAgICAgICAgICAgIHU9c3lzLmFyZ3ZbMF0rIj91cmw9Iit1cmxsaWIucXVvdGVfcGx1cyh1cmwpKyImbW9kZT0iK3N0cihtb2RlKSsiJm5hbWU9Iit1cmxsaWIucXVvdGVfcGx1cyhuYW1lKSsiJmZhbmFydD0iK3VybGxpYi5xdW90ZV9wbHVzKGZhbmFydCkrIiZyZWdleHM9IityZWdleHMKICAgICAgICBlbHNlOgogICAgICAgICAgICB1PXN5cy5hcmd2WzBdKyI/dXJsPSIrdXJsbGliLnF1b3RlX3BsdXModXJsKSsiJm1vZGU9IitzdHIobW9kZSkrIiZuYW1lPSIrdXJsbGliLnF1b3RlX3BsdXMobmFtZSkrIiZmYW5hcnQ9Iit1cmxsaWIucXVvdGVfcGx1cyhmYW5hcnQpCiAgICAgICAgCiAgICAgICAgb2s9VHJ1ZQogICAgICAgIGlmIGRhdGUgPT0gJyc6CiAgICAgICAgICAgIGRhdGUgPSBOb25lCiAgICAgICAgZWxzZToKICAgICAgICAgICAgZGVzY3JpcHRpb24gKz0gJ1xuXG5EYXRlOiAlcycgJWRhdGUKICAgICAgICBsaXo9eGJtY2d1aS5MaXN0SXRlbShuYW1lLCBpY29uSW1hZ2U9IkRlZmF1bHRGb2xkZXIucG5nIiwgdGh1bWJuYWlsSW1hZ2U9aWNvbmltYWdlKQogICAgICAgIGlmIGxlbihhbGxpbmZvKSA8MSA6CiAgICAgICAgICAgIGxpei5zZXRJbmZvKHR5cGU9IlZpZGVvIiwgaW5mb0xhYmVscz17ICJUaXRsZSI6IG5hbWUsICdtZWRpYXR5cGUnOid2aWRlbycsICJQbG90IjogZGVzY3JpcHRpb24sICJHZW5yZSI6IGdlbnJlLCAiZGF0ZWFkZGVkIjogZGF0ZSwgImNyZWRpdHMiOiBjcmVkaXRzIH0pCiAgICAgICAgZWxzZToKICAgICAgICAgICAgYWxsaW5mby51cGRhdGUoeydtZWRpYXR5cGUnOid2aWRlbyd9KQogICAgICAgICAgICBsaXouc2V0SW5mbyh0eXBlPSJWaWRlbyIsIGluZm9MYWJlbHM9IGFsbGluZm8pCiAgICAgICAgbGl6LnNldFByb3BlcnR5KCJGYW5hcnRfSW1hZ2UiLCBmYW5hcnQpCiAgICAgICAgaWYgc2hvd2NvbnRleHQ6CiAgICAgICAgICAgIGNvbnRleHRNZW51ID0gW10KICAgICAgICAgICAgcGFyZW50YWxibG9jayA9YWRkb24uZ2V0U2V0dGluZygncGFyZW50YWxibG9ja2VkJykKICAgICAgICAgICAgcGFyZW50YWxibG9jaz0gcGFyZW50YWxibG9jaz09InRydWUiCiAgICAgICAgICAgIHBhcmVudGFsYmxvY2tlZHBpbiA9YWRkb24uZ2V0U2V0dGluZygncGFyZW50YWxibG9ja2VkcGluJykKIyAgICAgICAgICAgIHByaW50ICdwYXJlbnRhbGJsb2NrZWRwaW4nLHBhcmVudGFsYmxvY2tlZHBpbgogICAgICAgICAgICBpZiBsZW4ocGFyZW50YWxibG9ja2VkcGluKT4wOgogICAgICAgICAgICAgICAgaWYgcGFyZW50YWxibG9jazoKICAgICAgICAgICAgICAgICAgICBjb250ZXh0TWVudS5hcHBlbmQoKCdEaXNhYmxlIFBhcmVudGFsIEJsb2NrJywnWEJNQy5SdW5QbHVnaW4oJXM/bW9kZT01NSZuYW1lPSVzKScgJShzeXMuYXJndlswXSwgdXJsbGliLnF1b3RlX3BsdXMobmFtZSkpKSkKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgY29udGV4dE1lbnUuYXBwZW5kKCgnRW5hYmxlIFBhcmVudGFsIEJsb2NrJywnWEJNQy5SdW5QbHVnaW4oJXM/bW9kZT01NiZuYW1lPSVzKScgJShzeXMuYXJndlswXSwgdXJsbGliLnF1b3RlX3BsdXMobmFtZSkpKSkKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgaWYgc2hvd2NvbnRleHQgPT0gJ3NvdXJjZSc6CiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYgbmFtZSBpbiBzdHIoU09VUkNFUyk6CiAgICAgICAgICAgICAgICAgICAgY29udGV4dE1lbnUuYXBwZW5kKCgnUmVtb3ZlIGZyb20gU291cmNlcycsJ1hCTUMuUnVuUGx1Z2luKCVzP21vZGU9OCZuYW1lPSVzKScgJShzeXMuYXJndlswXSwgdXJsbGliLnF1b3RlX3BsdXMobmFtZSkpKSkKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgZWxpZiBzaG93Y29udGV4dCA9PSAnZG93bmxvYWQnOgogICAgICAgICAgICAgICAgY29udGV4dE1lbnUuYXBwZW5kKCgnRG93bmxvYWQnLCdYQk1DLlJ1blBsdWdpbiglcz91cmw9JXMmbW9kZT05Jm5hbWU9JXMpJwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlKHN5cy5hcmd2WzBdLCB1cmxsaWIucXVvdGVfcGx1cyh1cmwpLCB1cmxsaWIucXVvdGVfcGx1cyhuYW1lKSkpKQogICAgICAgICAgICBlbGlmIHNob3djb250ZXh0ID09ICdmYXYnOgogICAgICAgICAgICAgICAgY29udGV4dE1lbnUuYXBwZW5kKCgnUmVtb3ZlIGZyb20gRmlyZVRWIEZhdm9yaXRlcycsJ1hCTUMuUnVuUGx1Z2luKCVzP21vZGU9NiZuYW1lPSVzKScKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJShzeXMuYXJndlswXSwgdXJsbGliLnF1b3RlX3BsdXMobmFtZSkpKSkKICAgICAgICAgICAgaWYgc2hvd2NvbnRleHQgPT0gJyEhdXBkYXRlJzoKICAgICAgICAgICAgICAgIGZhdl9wYXJhbXMyID0gKAogICAgICAgICAgICAgICAgICAgICclcz91cmw9JXMmbW9kZT0xNyZyZWdleHM9JXMnCiAgICAgICAgICAgICAgICAgICAgJShzeXMuYXJndlswXSwgdXJsbGliLnF1b3RlX3BsdXMocmVnX3VybCksIHJlZ2V4cykKICAgICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICBjb250ZXh0TWVudS5hcHBlbmQoKCdbQ09MT1IgeWVsbG93XSEhdXBkYXRlWy9DT0xPUl0nLCdYQk1DLlJ1blBsdWdpbiglcyknICVmYXZfcGFyYW1zMikpCiAgICAgICAgICAgIGlmIG5vdCBuYW1lIGluIEZBVjoKICAgICAgICAgICAgICAgIGNvbnRleHRNZW51LmFwcGVuZCgoJ0FkZCB0byBGaXJlVFYgRmF2b3JpdGVzJywnWEJNQy5SdW5QbHVnaW4oJXM/bW9kZT01Jm5hbWU9JXMmdXJsPSVzJmljb25pbWFnZT0lcyZmYW5hcnQ9JXMmZmF2X21vZGU9JXMpJwogICAgICAgICAgICAgICAgICAgICAgICAgJShzeXMuYXJndlswXSwgdXJsbGliLnF1b3RlX3BsdXMobmFtZSksIHVybGxpYi5xdW90ZV9wbHVzKHVybCksIHVybGxpYi5xdW90ZV9wbHVzKGljb25pbWFnZSksIHVybGxpYi5xdW90ZV9wbHVzKGZhbmFydCksIG1vZGUpKSkKICAgICAgICAgICAgbGl6LmFkZENvbnRleHRNZW51SXRlbXMoY29udGV4dE1lbnUpCiAgICAgICAgb2s9eGJtY3BsdWdpbi5hZGREaXJlY3RvcnlJdGVtKGhhbmRsZT1pbnQoc3lzLmFyZ3ZbMV0pLHVybD11LGxpc3RpdGVtPWxpeixpc0ZvbGRlcj1UcnVlKQogICAgICAgIHJldHVybiBvawoKZGVmIHl0ZGxfZG93bmxvYWQodXJsLHRpdGxlLG1lZGlhX3R5cGU9J3ZpZGVvJyk6CiAgICAjIHBsYXkgaW4geGJtYyB3aGlsZSBwbGF5aW5nIGdvIGJhY2sgdG8gY29udGV4dE1lbnUoYykgdG8gIiEhRG93bmxvYWQhISIKICAgICMgVHJpYWwgeWFzY2Vlbjogc2VwZXJhdGUgfFVzZXItQWdlbnQ9CiAgICBpbXBvcnQgeW91dHViZWRsCiAgICAKICAgIGlmIG5vdCB1cmwgPT0gJyc6CiAgICAgICAgaWYgbWVkaWFfdHlwZT09ICdhdWRpbyc6CiAgICAgICAgICAgIHlvdXR1YmVkbC5zaW5nbGVfWUQodXJsLGRvd25sb2FkPVRydWUsYXVkaW89VHJ1ZSkKICAgICAgICBlbHNlOgogICAgICAgICAgICB5b3V0dWJlZGwuc2luZ2xlX1lEKHVybCxkb3dubG9hZD1UcnVlKQogICAgZWxpZiB4Ym1jLlBsYXllcigpLmlzUGxheWluZygpID09IFRydWUgOgogICAgICAgIGltcG9ydCBZRFN0cmVhbUV4dHJhY3RvcgogICAgICAgIGlmIFlEU3RyZWFtRXh0cmFjdG9yLmlzRG93bmxvYWRpbmcoKSA9PSBUcnVlOgoKICAgICAgICAgICAgWURTdHJlYW1FeHRyYWN0b3IubWFuYWdlRG93bmxvYWRzKCkKICAgICAgICBlbHNlOgogICAgICAgICAgICB4Ym1jX3VybCA9IHhibWMuUGxheWVyKCkuZ2V0UGxheWluZ0ZpbGUoKQoKICAgICAgICAgICAgeGJtY191cmwgPSB4Ym1jX3VybC5zcGxpdCgnfFVzZXItQWdlbnQ9JylbMF0KICAgICAgICAgICAgaW5mbyA9IHsndXJsJzp4Ym1jX3VybCwndGl0bGUnOnRpdGxlLCdtZWRpYV90eXBlJzptZWRpYV90eXBlfQogICAgICAgICAgICB5b3V0dWJlZGwuc2luZ2xlX1lEKCcnLGRvd25sb2FkPVRydWUsZGxfaW5mbz1pbmZvKQogICAgZWxzZToKICAgICAgICB4Ym1jLmV4ZWN1dGVidWlsdGluKCJYQk1DLk5vdGlmaWNhdGlvbihET1dOTE9BRCxGaXJzdCBQbGF5IFtDT0xPUiB5ZWxsb3ddV0hJTEUgcGxheWluZyBkb3dubG9hZFsvQ09MT1JdICwxMDAwMCkiKQoKIyMgTHVuYXRpeHogUHNldWRvVFYgZmVhdHVyZQpkZWYgYXNjaWkoc3RyaW5nKToKICAgIGlmIGlzaW5zdGFuY2Uoc3RyaW5nLCBiYXNlc3RyaW5nKToKICAgICAgICBpZiBpc2luc3RhbmNlKHN0cmluZywgdW5pY29kZSk6CiAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLmVuY29kZSgnYXNjaWknLCAnaWdub3JlJykKICAgIHJldHVybiBzdHJpbmcKCmRlZiB1bmkoc3RyaW5nLCBlbmNvZGluZyA9ICd1dGYtOCcpOgogICAgaWYgaXNpbnN0YW5jZShzdHJpbmcsIGJhc2VzdHJpbmcpOgogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKHN0cmluZywgdW5pY29kZSk6CiAgICAgICAgICAgIHN0cmluZyA9IHVuaWNvZGUoc3RyaW5nLCBlbmNvZGluZywgJ2lnbm9yZScpCiAgICByZXR1cm4gc3RyaW5nCgpkZWYgcmVtb3ZlTm9uQXNjaWkocyk6IHJldHVybiAiIi5qb2luKGZpbHRlcihsYW1iZGEgeDogb3JkKHgpPDEyOCwgcykpCgpkZWYgc2VuZEpTT04oIGNvbW1hbmQpOgogICAgZGF0YSA9ICcnCiAgICB0cnk6CiAgICAgICAgZGF0YSA9IHhibWMuZXhlY3V0ZUpTT05SUEModW5pKGNvbW1hbmQpKQogICAgZXhjZXB0IFVuaWNvZGVFbmNvZGVFcnJvcjoKICAgICAgICBkYXRhID0geGJtYy5leGVjdXRlSlNPTlJQQyhhc2NpaShjb21tYW5kKSkKCiAgICByZXR1cm4gdW5pKGRhdGEpCgpkZWYgcGx1Z2lucXVlcnlieUpTT04odXJsLGdpdmVfbWVfcmVzdWx0PU5vbmUscGxheWxpc3Q9RmFsc2UpOgogICAgaWYgJ2F1ZGlvJyBpbiB1cmw6CiAgICAgICAganNvbl9xdWVyeSA9IHVuaSgneyJqc29ucnBjIjoiMi4wIiwibWV0aG9kIjoiRmlsZXMuR2V0RGlyZWN0b3J5IiwicGFyYW1zIjogeyJkaXJlY3RvcnkiOiIlcyIsIm1lZGlhIjoidmlkZW8iLCAicHJvcGVydGllcyI6IFsidGl0bGUiLCAiYWxidW0iLCAiYXJ0aXN0IiwgImR1cmF0aW9uIiwidGh1bWJuYWlsIiwgInllYXIiXX0sICJpZCI6IDF9JykgJXVybAogICAgZWxzZToKICAgICAgICBqc29uX3F1ZXJ5ID0gdW5pKCd7Impzb25ycGMiOiIyLjAiLCJtZXRob2QiOiJGaWxlcy5HZXREaXJlY3RvcnkiLCJwYXJhbXMiOnsiZGlyZWN0b3J5IjoiJXMiLCJtZWRpYSI6InZpZGVvIiwicHJvcGVydGllcyI6WyAicGxvdCIsInBsYXljb3VudCIsImRpcmVjdG9yIiwgImdlbnJlIiwidm90ZXMiLCJkdXJhdGlvbiIsInRyYWlsZXIiLCJwcmVtaWVyZWQiLCJ0aHVtYm5haWwiLCJ0aXRsZSIsInllYXIiLCJkYXRlYWRkZWQiLCJmYW5hcnQiLCJyYXRpbmciLCJzZWFzb24iLCJlcGlzb2RlIiwic3R1ZGlvIiwibXBhYSJdfSwiaWQiOjF9JykgJXVybAogICAganNvbl9mb2xkZXJfZGV0YWlsID0ganNvbi5sb2FkcyhzZW5kSlNPTihqc29uX3F1ZXJ5KSkKICAgICNwcmludCBqc29uX2ZvbGRlcl9kZXRhaWwKICAgIGlmIGdpdmVfbWVfcmVzdWx0OgogICAgICAgIHJldHVybiBqc29uX2ZvbGRlcl9kZXRhaWwKICAgIGlmIGpzb25fZm9sZGVyX2RldGFpbC5oYXNfa2V5KCdlcnJvcicpOgogICAgICAgIHJldHVybgogICAgZWxzZToKCiAgICAgICAgZm9yIGkgaW4ganNvbl9mb2xkZXJfZGV0YWlsWydyZXN1bHQnXVsnZmlsZXMnXSA6CiAgICAgICAgICAgIG1ldGEgPXt9CiAgICAgICAgICAgIHVybCA9IGlbJ2ZpbGUnXQogICAgICAgICAgICBuYW1lID0gcmVtb3ZlTm9uQXNjaWkoaVsnbGFiZWwnXSkKICAgICAgICAgICAgdGh1bWJuYWlsID0gcmVtb3ZlTm9uQXNjaWkoaVsndGh1bWJuYWlsJ10pCiAgICAgICAgICAgIGZhbmFydCA9IHJlbW92ZU5vbkFzY2lpKGlbJ2ZhbmFydCddKQogICAgICAgICAgICBtZXRhID0gZGljdCgoayx2KSBmb3IgaywgdiBpbiBpLml0ZXJpdGVtcygpIGlmIG5vdCB2ID09ICcwJyBvciBub3QgdiA9PSAtMSBvciB2ID09ICcnKQogICAgICAgICAgICBtZXRhLnBvcCgiZmlsZSIsIE5vbmUpCiAgICAgICAgICAgIGlmIGlbJ2ZpbGV0eXBlJ10gPT0gJ2ZpbGUnOgogICAgICAgICAgICAgICAgaWYgcGxheWxpc3Q6CiAgICAgICAgICAgICAgICAgICAgcGxheV9wbGF5bGlzdChuYW1lLHVybCxxdWV1ZVZpZGVvPScxJykKICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBhZGRMaW5rKHVybCxuYW1lLHRodW1ibmFpbCxmYW5hcnQsJycsJycsJycsJycsTm9uZSwnJyx0b3RhbD1sZW4oanNvbl9mb2xkZXJfZGV0YWlsWydyZXN1bHQnXVsnZmlsZXMnXSksYWxsaW5mbz1tZXRhKQogICAgICAgICAgICAgICAgICAgICN4Ym1jLmV4ZWN1dGVidWlsdGluKCJDb250YWluZXIuU2V0Vmlld01vZGUoNTAwKSIpCiAgICAgICAgICAgICAgICAgICAgaWYgaVsndHlwZSddIGFuZCBpWyd0eXBlJ10gPT0gJ3R2c2hvdycgOgogICAgICAgICAgICAgICAgICAgICAgICB4Ym1jcGx1Z2luLnNldENvbnRlbnQoaW50KHN5cy5hcmd2WzFdKSwgJ3R2c2hvd3MnKQogICAgICAgICAgICAgICAgICAgIGVsaWYgaVsnZXBpc29kZSddID4gMCA6CiAgICAgICAgICAgICAgICAgICAgICAgIHhibWNwbHVnaW4uc2V0Q29udGVudChpbnQoc3lzLmFyZ3ZbMV0pLCAnZXBpc29kZXMnKQoKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGFkZERpcihuYW1lLHVybCw1Myx0aHVtYm5haWwsZmFuYXJ0LCcnLCcnLCcnLCcnLGFsbGluZm89bWV0YSkKICAgICAgICB4Ym1jcGx1Z2luLmVuZE9mRGlyZWN0b3J5KGludChzeXMuYXJndlsxXSkpCgpkZWYgYWRkTGluayh1cmwsbmFtZSxpY29uaW1hZ2UsZmFuYXJ0LGRlc2NyaXB0aW9uLGdlbnJlLGRhdGUsc2hvd2NvbnRleHQscGxheWxpc3QscmVnZXhzLHRvdGFsLHNldENvb2tpZT0iIixhbGxpbmZvPXt9KToKICAgICAgICAjcHJpbnQgJ3VybCxuYW1lLHJlZ2V4Jyx1cmwsbmFtZSxpY29uaW1hZ2UscmVnZXhzCiAgICAgICAgY29udGV4dE1lbnUgPVtdCiAgICAgICAgcGFyZW50YWxibG9jayA9YWRkb24uZ2V0U2V0dGluZygncGFyZW50YWxibG9ja2VkJykKICAgICAgICBwYXJlbnRhbGJsb2NrPSBwYXJlbnRhbGJsb2NrPT0idHJ1ZSIKICAgICAgICBwYXJlbnRhbGJsb2NrZWRwaW4gPWFkZG9uLmdldFNldHRpbmcoJ3BhcmVudGFsYmxvY2tlZHBpbicpCiMgICAgICAgIHByaW50ICdwYXJlbnRhbGJsb2NrZWRwaW4nLHBhcmVudGFsYmxvY2tlZHBpbgogICAgICAgIGlmIGxlbihwYXJlbnRhbGJsb2NrZWRwaW4pPjA6CiAgICAgICAgICAgIGlmIHBhcmVudGFsYmxvY2s6CiAgICAgICAgICAgICAgICBjb250ZXh0TWVudS5hcHBlbmQoKCdEaXNhYmxlIFBhcmVudGFsIEJsb2NrJywnWEJNQy5SdW5QbHVnaW4oJXM/bW9kZT01NSZuYW1lPSVzKScgJShzeXMuYXJndlswXSwgdXJsbGliLnF1b3RlX3BsdXMobmFtZSkpKSkKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGNvbnRleHRNZW51LmFwcGVuZCgoJ0VuYWJsZSBQYXJlbnRhbCBCbG9jaycsJ1hCTUMuUnVuUGx1Z2luKCVzP21vZGU9NTYmbmFtZT0lcyknICUoc3lzLmFyZ3ZbMF0sIHVybGxpYi5xdW90ZV9wbHVzKG5hbWUpKSkpCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgdHJ5OgogICAgICAgICAgICBuYW1lID0gbmFtZS5lbmNvZGUoJ3V0Zi04JykKICAgICAgICBleGNlcHQ6IHBhc3MKICAgICAgICBvayA9IFRydWUKICAgICAgICBpc0ZvbGRlcj1GYWxzZQogICAgICAgIGlmIHJlZ2V4czoKICAgICAgICAgICAgbW9kZSA9ICcxNycKICAgICAgICAgICAgaWYgJ2xpc3RyZXBlYXQnIGluIHJlZ2V4czoKICAgICAgICAgICAgICAgIGlzRm9sZGVyPVRydWUKIyAgICAgICAgICAgICAgIHByaW50ICdzZXR0aW5nIGFzIGZvbGRlciBpbiBsaW5rJwogICAgICAgICAgICBjb250ZXh0TWVudS5hcHBlbmQoKCdbQ09MT1Igd2hpdGVdISFEb3dubG9hZCBDdXJyZW50bHkgUGxheWluZyEhWy9DT0xPUl0nLCdYQk1DLlJ1blBsdWdpbiglcz91cmw9JXMmbW9kZT0yMSZuYW1lPSVzKScKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJShzeXMuYXJndlswXSwgdXJsbGliLnF1b3RlX3BsdXModXJsKSwgdXJsbGliLnF1b3RlX3BsdXMobmFtZSkpKSkKICAgICAgICBlbGlmICAoYW55KHggaW4gdXJsIGZvciB4IGluIHJlc29sdmVfdXJsKSBhbmQgIHVybC5zdGFydHN3aXRoKCdodHRwJykpIG9yIHVybC5lbmRzd2l0aCgnJm1vZGU9MTknKToKICAgICAgICAgICAgdXJsPXVybC5yZXBsYWNlKCcmbW9kZT0xOScsJycpCiAgICAgICAgICAgIG1vZGUgPSAnMTknCiAgICAgICAgICAgIGNvbnRleHRNZW51LmFwcGVuZCgoJ1tDT0xPUiB3aGl0ZV0hIURvd25sb2FkIEN1cnJlbnRseSBQbGF5aW5nISFbL0NPTE9SXScsJ1hCTUMuUnVuUGx1Z2luKCVzP3VybD0lcyZtb2RlPTIxJm5hbWU9JXMpJwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlKHN5cy5hcmd2WzBdLCB1cmxsaWIucXVvdGVfcGx1cyh1cmwpLCB1cmxsaWIucXVvdGVfcGx1cyhuYW1lKSkpKQogICAgICAgIGVsaWYgdXJsLmVuZHN3aXRoKCcmbW9kZT0xOCcpOgogICAgICAgICAgICB1cmw9dXJsLnJlcGxhY2UoJyZtb2RlPTE4JywnJykKICAgICAgICAgICAgbW9kZSA9ICcxOCcKICAgICAgICAgICAgY29udGV4dE1lbnUuYXBwZW5kKCgnW0NPTE9SIHdoaXRlXSEhRG93bmxvYWQhIVsvQ09MT1JdJywnWEJNQy5SdW5QbHVnaW4oJXM/dXJsPSVzJm1vZGU9MjMmbmFtZT0lcyknCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICUoc3lzLmFyZ3ZbMF0sIHVybGxpYi5xdW90ZV9wbHVzKHVybCksIHVybGxpYi5xdW90ZV9wbHVzKG5hbWUpKSkpCiAgICAgICAgICAgIGlmIGFkZG9uLmdldFNldHRpbmcoJ2RsYXVkaW9vbmx5JykgPT0gJ3RydWUnOgogICAgICAgICAgICAgICAgY29udGV4dE1lbnUuYXBwZW5kKCgnISFEb3dubG9hZCBbQ09MT1Igc2VhYmx1ZV1BdWRpbyEhWy9DT0xPUl0nLCdYQk1DLlJ1blBsdWdpbiglcz91cmw9JXMmbW9kZT0yNCZuYW1lPSVzKScKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICUoc3lzLmFyZ3ZbMF0sIHVybGxpYi5xdW90ZV9wbHVzKHVybCksIHVybGxpYi5xdW90ZV9wbHVzKG5hbWUpKSkpCiAgICAgICAgZWxpZiB1cmwuZW5kc3dpdGgoJyZtb2RlPTIwJyk6CiAgICAgICAgICAgIHVybD11cmwucmVwbGFjZSgnJm1vZGU9MjAnLCcnKQogICAgICAgICAgICBtb2RlID0gJzIwJwogICAgICAgIGVsaWYgdXJsLmVuZHN3aXRoKCcmbW9kZT0yMicpOgogICAgICAgICAgICB1cmw9dXJsLnJlcGxhY2UoJyZtb2RlPTIyJywnJykKICAgICAgICAgICAgbW9kZSA9ICcyMicKICAgICAgICBlbGlmIHVybC5zdGFydHN3aXRoKCdtYWduZXQ6P3h0PScpOgogICAgICAgICAgICBpZiAnJicgaW4gdXJsIGFuZCBub3QgJyZhbXA7JyBpbiB1cmwgOgogICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJyYnLCcmYW1wOycpCiAgICAgICAgICAgIHVybCA9ICdwbHVnaW46Ly9wbHVnaW4udmlkZW8ucHVsc2FyL3BsYXk/dXJpPScgKyB1cmwKICAgICAgICAgICAgbW9kZSA9ICcxMicKICAgICAgICBlbHNlOgogICAgICAgICAgICBtb2RlID0gJzEyJwogICAgICAgICAgICBjb250ZXh0TWVudS5hcHBlbmQoKCdbQ09MT1Igd2hpdGVdISFEb3dubG9hZCBDdXJyZW50bHkgUGxheWluZyEhWy9DT0xPUl0nLCdYQk1DLlJ1blBsdWdpbiglcz91cmw9JXMmbW9kZT0yMSZuYW1lPSVzKScKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJShzeXMuYXJndlswXSwgdXJsbGliLnF1b3RlX3BsdXModXJsKSwgdXJsbGliLnF1b3RlX3BsdXMobmFtZSkpKSkKICAgICAgICBpZiAncGx1Z2luOi8vcGx1Z2luLnZpZGVvLnlvdXR1YmUvcGxheS8/dmlkZW9faWQ9JyBpbiB1cmw6CiAgICAgICAgICAgICAgeXRfYXVkaW9fdXJsID0gdXJsLnJlcGxhY2UoJ3BsdWdpbjovL3BsdWdpbi52aWRlby55b3V0dWJlL3BsYXkvP3ZpZGVvX2lkPScsJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9JykKICAgICAgICAgICAgICBjb250ZXh0TWVudS5hcHBlbmQoKCchIURvd25sb2FkIFtDT0xPUiBibHVlXUF1ZGlvISFbL0NPTE9SXScsJ1hCTUMuUnVuUGx1Z2luKCVzP3VybD0lcyZtb2RlPTI0Jm5hbWU9JXMpJwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICUoc3lzLmFyZ3ZbMF0sIHVybGxpYi5xdW90ZV9wbHVzKHl0X2F1ZGlvX3VybCksIHVybGxpYi5xdW90ZV9wbHVzKG5hbWUpKSkpCiAgICAgICAgdT1zeXMuYXJndlswXSsiPyIKICAgICAgICBwbGF5X2xpc3QgPSBGYWxzZQogICAgICAgIAogICAgICAgIGlmIHBsYXlsaXN0OgogICAgICAgICAgICBpZiBhZGRvbi5nZXRTZXR0aW5nKCdhZGRfcGxheWxpc3QnKSA9PSAiZmFsc2UiIGFuZCAnJCRMU1BsYXlPbmx5T25lJCQnIG5vdCBpbiBwbGF5bGlzdFswXSA6CiAgICAgICAgICAgICAgICB1ICs9ICJ1cmw9Iit1cmxsaWIucXVvdGVfcGx1cyh1cmwpKyImbW9kZT0iK21vZGUKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIHUgKz0gIm1vZGU9MTMmbmFtZT0lcyZwbGF5bGlzdD0lcyIgJSh1cmxsaWIucXVvdGVfcGx1cyhuYW1lKSwgdXJsbGliLnF1b3RlX3BsdXMoc3RyKHBsYXlsaXN0KS5yZXBsYWNlKCcsJywnfHwnKSkpCiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZSArICdbQ09MT1IgbWFnZW50YV0gKCcgKyBzdHIobGVuKHBsYXlsaXN0KSkgKyAnIGl0ZW1zIClbL0NPTE9SXScKICAgICAgICAgICAgICAgIHBsYXlfbGlzdCA9IFRydWUKICAgICAgICBlbGlmIG1vZGU9PScyMicgb3IgKG1vZGU9PScxNycgYW5kIHVybC5lbmRzd2l0aCgnJm1vZGU9MjInKSk6ICAgICAgICAgICAgIAogICAgICAgICAgICB1ICs9ICJ1cmw9Iit1cmxsaWIucXVvdGVfcGx1cyh1cmwpKyImbmFtZT0iK3VybGxpYi5xdW90ZShuYW1lKSsiJm1vZGU9Iittb2RlCiAgICAgICAgZWxzZToKICAgICAgICAgICAgdSArPSAidXJsPSIrdXJsbGliLnF1b3RlX3BsdXModXJsKSsiJm1vZGU9Iittb2RlCiAgICAgICAgaWYgcmVnZXhzOgogICAgICAgICAgICB1ICs9ICImcmVnZXhzPSIrcmVnZXhzCiAgICAgICAgaWYgbm90IHNldENvb2tpZSA9PSAnJzoKICAgICAgICAgICAgdSArPSAiJnNldENvb2tpZT0iK3VybGxpYi5xdW90ZV9wbHVzKHNldENvb2tpZSkKICAgICAgICBpZiBpY29uaW1hZ2UgYW5kICBub3QgaWNvbmltYWdlID09ICcnOgogICAgICAgICAgICB1ICs9ICImaWNvbmltYWdlPSIrdXJsbGliLnF1b3RlX3BsdXMoaWNvbmltYWdlKQogICAgICAgICAgICAKICAgICAgICBpZiBkYXRlID09ICcnOgogICAgICAgICAgICBkYXRlID0gTm9uZQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGRlc2NyaXB0aW9uICs9ICdcblxuRGF0ZTogJXMnICVkYXRlCiAgICAgICAgbGl6PXhibWNndWkuTGlzdEl0ZW0obmFtZSwgaWNvbkltYWdlPSJEZWZhdWx0VmlkZW8ucG5nIiwgdGh1bWJuYWlsSW1hZ2U9aWNvbmltYWdlKQoKICAgICAgICAjaWYgaXNGb2xkZXI6CiAgICAgICAgaWYgYWxsaW5mbz09Tm9uZSBvciBsZW4oYWxsaW5mbykgPDE6CiAgICAgICAgICAgIGxpei5zZXRJbmZvKHR5cGU9IlZpZGVvIiwgaW5mb0xhYmVscz17ICJUaXRsZSI6IG5hbWUsICdtZWRpYXR5cGUnOid2aWRlbycsICJQbG90IjogZGVzY3JpcHRpb24sICJHZW5yZSI6IGdlbnJlLCAiZGF0ZWFkZGVkIjogZGF0ZSB9KQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGFsbGluZm8udXBkYXRlKHsnbWVkaWF0eXBlJzondmlkZW8nfSkKICAgICAgICAgICAgbGl6LnNldEluZm8odHlwZT0iVmlkZW8iLCBpbmZvTGFiZWxzPWFsbGluZm8pCiAgICAgICAgbGl6LnNldFByb3BlcnR5KCJGYW5hcnRfSW1hZ2UiLCBmYW5hcnQpCgogICAgICAgIGlmICckJFJFU09MVkVPTkxZJCQnIGluIHVybDoKICAgICAgICAgICAgbGl6LnNldFByb3BlcnR5KCdJc1BsYXlhYmxlJywgJ3RydWUnKQogCiAgICAgICAgaWYgKG5vdCBwbGF5X2xpc3QpIGFuZCBub3QgYW55KHggaW4gdXJsIGZvciB4IGluIGdfaWdub3JlU2V0UmVzb2x2ZWQpIGFuZCBub3QgJyRQTEFZRVJQUk9YWSQ9JyBpbiB1cmwgYW5kIG5vdCAobW9kZT09JzIyJyBvciAobW9kZT09JzE3JyBhbmQgdXJsLmVuZHN3aXRoKCcmbW9kZT0yMicpKSk6IyAgKG5vdCB1cmwuc3RhcnRzd2l0aCgncGx1Z2luOi8vcGx1Z2luLnZpZGVvLmY0bVRlc3RlcicpKToKICAgICAgICAgICAgaWYgcmVnZXhzOgogICAgICAgICAgICAgICAgI3ByaW50IHVybGxpYi51bnF1b3RlX3BsdXMocmVnZXhzKQogICAgICAgICAgICAgICAgaWYgJyRweUZ1bmN0aW9uOnBsYXltZWRpYSgnIG5vdCBpbiB1cmxsaWIudW5xdW90ZV9wbHVzKHJlZ2V4cykgYW5kICdub3RwbGF5YWJsZScgbm90IGluIHVybGxpYi51bnF1b3RlX3BsdXMocmVnZXhzKSBhbmQgJ2xpc3RyZXBlYXQnIG5vdCBpbiAgdXJsbGliLnVucXVvdGVfcGx1cyhyZWdleHMpIDoKICAgICAgICAgICAgICAgICAgICAjcHJpbnQgJ3NldHRpbmcgaXNwbGF5YWJsZScsdXJsLCB1cmxsaWIudW5xdW90ZV9wbHVzKHJlZ2V4cyksdXJsCiAgICAgICAgICAgICAgICAgICAgbGl6LnNldFByb3BlcnR5KCdJc1BsYXlhYmxlJywgJ3RydWUnKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgbGl6LnNldFByb3BlcnR5KCdJc1BsYXlhYmxlJywgJ3RydWUnKQogICAgICAgICAgICAgICAgCiAgICAgICAgZWxzZToKICAgICAgICAgICAgYWRkb25fbG9nKCdOT1Qgc2V0dGluZyBpc3BsYXlhYmxlJyt1cmwpCiAgICAgICAgCiAgICAgICAgaWYgc2hvd2NvbnRleHQ6CiAgICAgICAgICAgICNjb250ZXh0TWVudSA9IFtdCiAgICAgICAgICAgIGlmIHNob3djb250ZXh0ID09ICdmYXYnOgogICAgICAgICAgICAgICAgY29udGV4dE1lbnUuYXBwZW5kKAogICAgICAgICAgICAgICAgICAgICgnUmVtb3ZlIGZyb20gRmlyZVRWIEZhdm9yaXRlcycsJ1hCTUMuUnVuUGx1Z2luKCVzP21vZGU9NiZuYW1lPSVzKScKICAgICAgICAgICAgICAgICAgICAgJShzeXMuYXJndlswXSwgdXJsbGliLnF1b3RlX3BsdXMobmFtZSkpKQogICAgICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgIGVsaWYgbm90IG5hbWUgaW4gRkFWOgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIGZhdl9wYXJhbXMgPSAoCiAgICAgICAgICAgICAgICAgICAgICAgICclcz9tb2RlPTUmbmFtZT0lcyZ1cmw9JXMmaWNvbmltYWdlPSVzJmZhbmFydD0lcyZmYXZfbW9kZT0wJwogICAgICAgICAgICAgICAgICAgICAgICAlKHN5cy5hcmd2WzBdLCB1cmxsaWIucXVvdGVfcGx1cyhuYW1lKSwgdXJsbGliLnF1b3RlX3BsdXModXJsKSwgdXJsbGliLnF1b3RlX3BsdXMoaWNvbmltYWdlKSwgdXJsbGliLnF1b3RlX3BsdXMoZmFuYXJ0KSkKICAgICAgICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgIGZhdl9wYXJhbXMgPSAoCiAgICAgICAgICAgICAgICAgICAgICAgICclcz9tb2RlPTUmbmFtZT0lcyZ1cmw9JXMmaWNvbmltYWdlPSVzJmZhbmFydD0lcyZmYXZfbW9kZT0wJwogICAgICAgICAgICAgICAgICAgICAgICAlKHN5cy5hcmd2WzBdLCB1cmxsaWIucXVvdGVfcGx1cyhuYW1lKSwgdXJsbGliLnF1b3RlX3BsdXModXJsKSwgdXJsbGliLnF1b3RlX3BsdXMoaWNvbmltYWdlLmVuY29kZSgidXRmLTgiKSksIHVybGxpYi5xdW90ZV9wbHVzKGZhbmFydC5lbmNvZGUoInV0Zi04IikpKQogICAgICAgICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICBpZiBwbGF5bGlzdDoKICAgICAgICAgICAgICAgICAgICBmYXZfcGFyYW1zICs9ICdwbGF5bGlzdD0nK3VybGxpYi5xdW90ZV9wbHVzKHN0cihwbGF5bGlzdCkucmVwbGFjZSgnLCcsJ3x8JykpCiAgICAgICAgICAgICAgICBpZiByZWdleHM6CiAgICAgICAgICAgICAgICAgICAgZmF2X3BhcmFtcyArPSAiJnJlZ2V4cz0iK3JlZ2V4cwogICAgICAgICAgICAgICAgY29udGV4dE1lbnUuYXBwZW5kKCgnQWRkIHRvIEZpcmVUViBGYXZvcml0ZXMnLCdYQk1DLlJ1blBsdWdpbiglcyknICVmYXZfcGFyYW1zKSkKICAgICAgICAgICAgbGl6LmFkZENvbnRleHRNZW51SXRlbXMoY29udGV4dE1lbnUpCiAgICAgICAgdHJ5OgogICAgICAgICAgICBpZiBub3QgcGxheWxpc3QgaXMgTm9uZToKICAgICAgICAgICAgICAgIGlmIGFkZG9uLmdldFNldHRpbmcoJ2FkZF9wbGF5bGlzdCcpID09ICJmYWxzZSI6CiAgICAgICAgICAgICAgICAgICAgcGxheWxpc3RfbmFtZSA9IG5hbWUuc3BsaXQoJykgJylbMV0KICAgICAgICAgICAgICAgICAgICBjb250ZXh0TWVudV8gPSBbCiAgICAgICAgICAgICAgICAgICAgICAgICgnUGxheSAnK3BsYXlsaXN0X25hbWUrJyBQbGF5TGlzdCcsJ1hCTUMuUnVuUGx1Z2luKCVzP21vZGU9MTMmbmFtZT0lcyZwbGF5bGlzdD0lcyknCiAgICAgICAgICAgICAgICAgICAgICAgICAlKHN5cy5hcmd2WzBdLCB1cmxsaWIucXVvdGVfcGx1cyhwbGF5bGlzdF9uYW1lKSwgdXJsbGliLnF1b3RlX3BsdXMoc3RyKHBsYXlsaXN0KS5yZXBsYWNlKCcsJywnfHwnKSkpKQogICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgIGxpei5hZGRDb250ZXh0TWVudUl0ZW1zKGNvbnRleHRNZW51XykKICAgICAgICBleGNlcHQ6IHBhc3MKICAgICAgICAjcHJpbnQgJ2FkZGluZycsbmFtZQogICAgICAgIAogICAgICAgIG9rPXhibWNwbHVnaW4uYWRkRGlyZWN0b3J5SXRlbShoYW5kbGU9aW50KHN5cy5hcmd2WzFdKSx1cmw9dSxsaXN0aXRlbT1saXosdG90YWxJdGVtcz10b3RhbCxpc0ZvbGRlcj1pc0ZvbGRlcikKCiAgICAgICAgI3ByaW50ICdhZGRlZCcsbmFtZQogICAgICAgIHJldHVybiBvawoKZGVmIHBsYXlzZXRyZXNvbHZlZCh1cmwsbmFtZSxpY29uaW1hZ2Usc2V0cmVzb2x2ZWQ9VHJ1ZSxyZWc9Tm9uZSk6CiAgICAjcHJpbnQgJ3BsYXlzZXRyZXNvbHZlZCcsdXJsLG5hbWUsc2V0cmVzb2x2ZWQKICAgIHByaW50ICdwbGF5c2V0cmVzb2x2ZWQnCiAgICBpZiB1cmw9PU5vbmU6IAogICAgICAgIHhibWNwbHVnaW4uZW5kT2ZEaXJlY3RvcnkoaW50KHN5cy5hcmd2WzFdKSkKICAgICAgICByZXR1cm4KCiAgICBpZiAnJm1vZGU9MjInIGluIHVybDoKICAgICAgICBzZXRyZXNvbHZlZD1GYWxzZQogICAgICAgIHVybD11cmwucmVwbGFjZSgnJm1vZGU9MjInLCcnKQogICAgICAgIHU9c3lzLmFyZ3ZbMF0rIj8iCiAgICAgICAgdSArPSAidXJsPSIrdXJsbGliLnF1b3RlX3BsdXModXJsKSsiJm5hbWU9Iit1cmxsaWIucXVvdGUobmFtZSkrIiZtb2RlPTIyIgogICAgICAgIHVybCA9IHUKCiAgICBpZiBzZXRyZXNvbHZlZDoKICAgICAgICBzZXRyZXM9VHJ1ZQogICAgICAgIGlmICckJExTRGlyZWN0JCQnIGluIHVybDoKICAgICAgICAgICAgdXJsPXVybC5yZXBsYWNlKCckJExTRGlyZWN0JCQnLCcnKQogICAgICAgICAgICBzZXRyZXM9RmFsc2UKICAgICAgICBpZiByZWcgYW5kICdub3RwbGF5YWJsZScgaW4gcmVnOgogICAgICAgICAgICBzZXRyZXM9RmFsc2UKCiAgICAgICAgbGl6ID0geGJtY2d1aS5MaXN0SXRlbShuYW1lLCBpY29uSW1hZ2U9aWNvbmltYWdlLCB0aHVtYm5haWxJbWFnZT1pY29uaW1hZ2UpCiAgICAgICAgbGl6LnNldEluZm8odHlwZT0nVmlkZW8nLCBpbmZvTGFiZWxzPXsnVGl0bGUnOm5hbWUsJ21lZGlhdHlwZSc6J3ZpZGVvJ30pCiAgICAgICAgbGl6LnNldFByb3BlcnR5KCJJc1BsYXlhYmxlIiwidHJ1ZSIpCiAgICAgICAgaWYgJyZtb2RlPTE5JyBpbiB1cmw6CiAgICAgICAgICAgIHVybD11cmxzb2x2ZXIodXJsLnJlcGxhY2UoJyZtb2RlPTE5JywnJykucmVwbGFjZSgnOycsJycpKQogICAgICAgIGVsaWYgJyZtb2RlPTIwJyBpbiB1cmw6CiAgICAgICAgICAgIHVybD11cmwucmVwbGFjZSgnJm1vZGU9MjAnLCcnKQogICAgICAgICAgICBpZiAnfCcgaW4gdXJsOgogICAgICAgICAgICAgICAgdXJsLHN0cmhkciA9IHVybC5zcGxpdCgnfCcpCiAgICAgICAgICAgICAgICBsaXouc2V0UHJvcGVydHkoJ2lucHV0c3RyZWFtLmFkYXB0aXZlLnN0cmVhbV9oZWFkZXJzJywgc3RyaGRyKQoJCQkJCiAgICAgICAgICAgIGlmICcubTN1OCcgaW4gdXJsOgogICAgICAgICAgICAgICAgbGl6LnNldFByb3BlcnR5KCdpbnB1dHN0cmVhbWFkZG9uJywgJ2lucHV0c3RyZWFtLmFkYXB0aXZlJykKICAgICAgICAgICAgICAgIGxpei5zZXRQcm9wZXJ0eSgnaW5wdXRzdHJlYW0uYWRhcHRpdmUubWFuaWZlc3RfdHlwZScsICdobHMnKQogICAgICAgICAgICAgICAgbGl6LnNldE1pbWVUeXBlKCdhcHBsaWNhdGlvbi92bmQuYXBwbGUubXBlZ3N0cmVhbV91cmwnKQogICAgICAgICAgICAgICAgbGl6LnNldENvbnRlbnRMb29rdXAoRmFsc2UpCgogICAgICAgICAgICAKICAgICAgICAgICAgZWxpZiAnLm1wZCcgaW4gdXJsOgogICAgICAgICAgICAgICAgbGl6LnNldFByb3BlcnR5KCdpbnB1dHN0cmVhbWFkZG9uJywgJ2lucHV0c3RyZWFtLmFkYXB0aXZlJykKICAgICAgICAgICAgICAgIGxpei5zZXRQcm9wZXJ0eSgnaW5wdXRzdHJlYW0uYWRhcHRpdmUubWFuaWZlc3RfdHlwZScsICdtcGQnKQogICAgICAgICAgICAgICAgbGl6LnNldE1pbWVUeXBlKCdhcHBsaWNhdGlvbi9kYXNoK3htbCcpCiAgICAgICAgICAgICAgICBsaXouc2V0Q29udGVudExvb2t1cChGYWxzZSkKICAgICAgICAgICAgCiAgICAgICAgICAgIGVsaWYgJy5pc20nIGluIHVybDoKICAgICAgICAgICAgICAgIGxpei5zZXRQcm9wZXJ0eSgnaW5wdXRzdHJlYW1hZGRvbicsICdpbnB1dHN0cmVhbS5hZGFwdGl2ZScpCiAgICAgICAgICAgICAgICBsaXouc2V0UHJvcGVydHkoJ2lucHV0c3RyZWFtLmFkYXB0aXZlLm1hbmlmZXN0X3R5cGUnLCAnaXNtJykKICAgICAgICAgICAgICAgIGxpei5zZXRNaW1lVHlwZSgnYXBwbGljYXRpb24vdm5kLm1zLXNzdHIreG1sJykKICAgICAgICAgICAgICAgIGxpei5zZXRDb250ZW50TG9va3VwKEZhbHNlKQogICAgICAgIAogICAgICAgICMgZWxpZiAnJm1vZGU9MjInIGluIHVybDoKICAgICAgICAjICAgICBwcmludCAic2xwcm94eSIKICAgICAgICAjICAgICB1cmw9dXJsLnJlcGxhY2UoJyZtb2RlPTIyJywnJykKICAgICAgICAjICAgICB0cnk6CiAgICAgICAgIyAgICAgICAgIGZyb20gZHNwIGltcG9ydCBzdHJlYW1saW5rX3Byb3h5CiAgICAgICAgIyAgICAgICAgIHNsUHJveHkgPSBzdHJlYW1saW5rX3Byb3h5LlNMUHJveHlfSGVscGVyKCkKICAgICAgICAjICAgICAgICAgdHJ5OgogICAgICAgICMgICAgICAgICAgICAgcSA9ICByZS5maW5kYWxsKHInXCRcJFFVQUxJVFk9KFteXCRcJF0rKVwkXCQnLCB1cmwpWzBdCiAgICAgICAgIyAgICAgICAgIGV4Y2VwdDoKICAgICAgICAjICAgICAgICAgICAgIHEgPSAnYmVzdCcKICAgICAgICAjICAgICAgICAgdXJsID0gcmUuc3ViKHInXCRcJFFVQUxJVFk9Lio/XCRcJCcsICcnLCB1cmwpCiAgICAgICAgIyAgICAgICAgIHVybCA9IHVybGxpYi5xdW90ZSh1cmwpKycmYW1wO3E9JXMnJXEKICAgICAgICAjICAgICAgICAgbGl6LnNldFBhdGgodXJsKQogICAgICAgICMgICAgICAgICBsaXouc2V0UHJvcGVydHkoIklzUGxheWFibGUiLCJmYWxzZSIpCiAgICAgICAgIyAgICAgICAgIHNsUHJveHkucGxheVNMaW5rKHVybCwgbGl6KQogICAgICAgICMgICAgICAgICByZXR1cm4KICAgICAgICAjICAgIGV4Y2VwdDoKICAgICAgICAjICAgICAgICBwYXNzCgogICAgICAgIGxpei5zZXRQYXRoKHVybCkKICAgICAgICBpZiBub3Qgc2V0cmVzOgogICAgICAgICAgICB4Ym1jLlBsYXllcigpLnBsYXkodXJsKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHhibWNwbHVnaW4uc2V0UmVzb2x2ZWRVcmwoaW50KHN5cy5hcmd2WzFdKSwgVHJ1ZSwgbGl6KQogICAgICAgICAgIAogICAgZWxzZToKICAgICAgICB4Ym1jLmV4ZWN1dGVidWlsdGluKCdYQk1DLlJ1blBsdWdpbignK3VybCsnKScpCgojIyBUaGFua3MgdG8gZGFzY2hhY2thLCBhbiBlcGcgc2NyYXBlciBmb3IgaHR0cDovL2kudGVsZWJveS5jaC9wcm9ncmFtbS9zdGF0aW9uX3NlbGVjdC5waHAKIyMgIGh0dHA6Ly9mb3J1bS54Ym1jLm9yZy9wb3N0LnBocD9wPTkzNjIyOCZwb3N0Y291bnQ9MTA3NgpkZWYgZ2V0ZXBnKGxpbmspOgogICAgICAgIHVybD11cmxsaWIudXJsb3BlbihsaW5rKQogICAgICAgIHNvdXJjZT11cmwucmVhZCgpCiAgICAgICAgdXJsLmNsb3NlKCkKICAgICAgICBzb3VyY2UyID0gc291cmNlLnNwbGl0KCJKZXR6dCIpCiAgICAgICAgc291cmNlMyA9IHNvdXJjZTJbMV0uc3BsaXQoJ3Byb2dyYW1tL2RldGFpbC5waHA/Y29uc3RfaWQ9JykKICAgICAgICBzb3VyY2V1aHJ6ZWl0ID0gc291cmNlM1sxXS5zcGxpdCgnPGJyIC8+PGEgaHJlZj0iLycpCiAgICAgICAgbm93dGltZSA9IHNvdXJjZXVocnplaXRbMF1bNDA6bGVuKHNvdXJjZXVocnplaXRbMF0pXQogICAgICAgIHNvdXJjZXRpdGxlID0gc291cmNlM1syXS5zcGxpdCgiPC9hPjwvcD48L2Rpdj4iKQogICAgICAgIG5vd3RpdGxlID0gc291cmNldGl0bGVbMF1bMTc6bGVuKHNvdXJjZXRpdGxlWzBdKV0KICAgICAgICBub3d0aXRsZSA9IG5vd3RpdGxlLmVuY29kZSgndXRmLTgnKQogICAgICAgIHJldHVybiAiICAtICIrbm93dGl0bGUrIiAtICIrbm93dGltZQoKZGVmIGdldF9lcGcodXJsLCByZWdleCk6CiAgICAgICAgZGF0YSA9IG1ha2VSZXF1ZXN0KHVybCkKICAgICAgICB0cnk6CiAgICAgICAgICAgIGl0ZW0gPSByZS5maW5kYWxsKHJlZ2V4LCBkYXRhKVswXQogICAgICAgICAgICByZXR1cm4gaXRlbQogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgYWRkb25fbG9nKCdyZWdleCBmYWlsZWQnKQogICAgICAgICAgICBhZGRvbl9sb2cocmVnZXgpCiAgICAgICAgICAgIHJldHVybgoJCQkKZGVmIG1ha2VfcmVxdWVzdCh1cmwpOgojI0VTVEEgRlVOQ0lPTiBsZWUgbGFzIHVybCBkZWNsYXJhZGFzIGRvbmRlIGVzdGFuIGxvcyB2aWRlb3MuIHx8Cgl0cnk6CgkJcmVxID0gdXJsbGliMi5SZXF1ZXN0KHVybCkKCQlyZXEuYWRkX2hlYWRlcignVXNlci1BZ2VudCcsICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCA2LjM7IFdPVzY0OyBydjo1NS4wKSBHZWNrby8yMDEwMDEwMSBGaXJlZm94LzU1LjAnKQoJCXJlc3BvbnNlID0gdXJsbGliMi51cmxvcGVuKHJlcSkJICAKCQlsaW5rID0gcmVzcG9uc2UucmVhZCgpCgkJcmVzcG9uc2UuY2xvc2UoKSAgCgkJcmV0dXJuIGxpbmsKCWV4Y2VwdCB1cmxsaWIyLlVSTEVycm9yLCBlOgoJCXByaW50ICdXZSBmYWlsZWQgdG8gb3BlbiAiJXMiLicgJSB1cmwKCQlpZiBoYXNhdHRyKGUsICdjb2RlJyk6CgkJCXByaW50ICdXZSBmYWlsZWQgd2l0aCBlcnJvciBjb2RlIC0gJXMuJyAlIGUuY29kZQkKCQlpZiBoYXNhdHRyKGUsICdyZWFzb24nKToKCQkJcHJpbnQgJ1dlIGZhaWxlZCB0byByZWFjaCBhIHNlcnZlci4nCgkJCXByaW50ICdSZWFzb246ICcsIGUucmVhc29uCgkJCQpkZWYgT1BFTl9VUkwodXJsKToKICAgICAgICByZXEgPSB1cmxsaWIyLlJlcXVlc3QodXJsKQogICAgICAgIHJlcS5hZGRfaGVhZGVyKCdVc2VyLUFnZW50JywgJ01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjApIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS80NS4wLjI0NTQuODUgU2FmYXJpLzUzNy4zNicpCiAgICAgICAgcmVxLmFkZF9oZWFkZXIoJ1JlZmVyZXInLCAnJXMnJXVybCkKICAgICAgICByZXEuYWRkX2hlYWRlcignQ29ubmVjdGlvbicsICdrZWVwLWFsaXZlJykKICAgICAgICByZXNwb25zZSA9IHVybGxpYjIudXJsb3BlbihyZXEpCiAgICAgICAgbGluaz1yZXNwb25zZS5yZWFkKCkKICAgICAgICByZXNwb25zZS5jbG9zZSgpCiAgICAgICAgcmV0dXJuIGxpbmsKCiMjbm90IGEgZ2VuZXJpYyBpbXBsZW1lbmF0aW9uIGFzIGl0IG5lZWRzIHRvIGNvbnZlcnQgICAgICAgICAgICAKZGVmIGQyeChkLCByb290PSJyb290IixuZXN0ZWQ9MCk6CgogICAgb3AgPSBsYW1iZGEgdGFnOiAnPCcgKyB0YWcgKyAnPicKICAgIGNsID0gbGFtYmRhIHRhZzogJzwvJyArIHRhZyArICc+XG4nCgogICAgbWwgPSBsYW1iZGEgdix4bWw6IHhtbCArIG9wKGtleSkgKyBzdHIodikgKyBjbChrZXkpCiAgICB4bWwgPSBvcChyb290KSArICdcbicgaWYgcm9vdCBlbHNlICIiCgogICAgZm9yIGtleSx2bCBpbiBkLml0ZXJpdGVtcygpOgogICAgICAgIHZ0eXBlID0gdHlwZSh2bCkKICAgICAgICBpZiBuZXN0ZWQ9PTA6IGtleT0ncmVnZXgnICNlbmZvcmNpbmcgYWxsIHRvcCBsZXZlbCB0YWdzIHRvIGJlIG5hbWVkIGFzIHJlZ2V4CiAgICAgICAgaWYgdnR5cGUgaXMgbGlzdDogCiAgICAgICAgICAgIGZvciB2IGluIHZsOgogICAgICAgICAgICAgICAgdj1lc2NhcGUodikKICAgICAgICAgICAgICAgIHhtbCA9IG1sKHYseG1sKSAgICAgICAgIAogICAgICAgIAogICAgICAgIGlmIHZ0eXBlIGlzIGRpY3Q6IAogICAgICAgICAgICB4bWwgPSBtbCgnXG4nICsgZDJ4KHZsLE5vbmUsbmVzdGVkKzEpLHhtbCkgICAgICAgICAKICAgICAgICBpZiB2dHlwZSBpcyBub3QgbGlzdCBhbmQgdnR5cGUgaXMgbm90IGRpY3Q6IAogICAgICAgICAgICBpZiBub3QgdmwgaXMgTm9uZTogdmw9ZXNjYXBlKHZsKQogICAgICAgICAgICAjcHJpbnQgcmVwcih2bCkKICAgICAgICAgICAgaWYgdmwgaXMgTm9uZToKICAgICAgICAgICAgICAgIHhtbCA9IG1sKHZsLHhtbCkKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICN4bWwgPSBtbChlc2NhcGUodmwuZW5jb2RlKCJ1dGYtOCIpKSx4bWwpCiAgICAgICAgICAgICAgICB4bWwgPSBtbCh2bC5lbmNvZGUoInV0Zi04IikseG1sKQoKICAgIHhtbCArPSBjbChyb290KSBpZiByb290IGVsc2UgIiIKCiAgICByZXR1cm4geG1sCgp4Ym1jcGx1Z2luLnNldENvbnRlbnQoaW50KHN5cy5hcmd2WzFdKSwgJ21vdmllcycpCgp0cnk6CiAgICB4Ym1jcGx1Z2luLmFkZFNvcnRNZXRob2QoaW50KHN5cy5hcmd2WzFdKSwgeGJtY3BsdWdpbi5TT1JUX01FVEhPRF9VTlNPUlRFRCkKZXhjZXB0OgogICAgcGFzcwp0cnk6CiAgICB4Ym1jcGx1Z2luLmFkZFNvcnRNZXRob2QoaW50KHN5cy5hcmd2WzFdKSwgeGJtY3BsdWdpbi5TT1JUX01FVEhPRF9MQUJFTCkKZXhjZXB0OgogICAgcGFzcwp0cnk6CiAgICB4Ym1jcGx1Z2luLmFkZFNvcnRNZXRob2QoaW50KHN5cy5hcmd2WzFdKSwgeGJtY3BsdWdpbi5TT1JUX01FVEhPRF9EQVRFKQpleGNlcHQ6CiAgICBwYXNzCnRyeToKICAgIHhibWNwbHVnaW4uYWRkU29ydE1ldGhvZChpbnQoc3lzLmFyZ3ZbMV0pLCB4Ym1jcGx1Z2luLlNPUlRfTUVUSE9EX0dFTlJFKQpleGNlcHQ6CiAgICBwYXNzCgpwYXJhbXM9Z2V0X3BhcmFtcygpCiNwcmludCAncGFyYW1zICcsIHJlcHIocGFyYW1zKQoKdXJsPU5vbmUKbmFtZT1Ob25lCm1vZGU9Tm9uZQpwbGF5bGlzdD1Ob25lCmljb25pbWFnZT1Ob25lCmZhbmFydD1GQU5BUlQKcGxheWxpc3Q9Tm9uZQpmYXZfbW9kZT1Ob25lCnJlZ2V4cz1Ob25lCgp0cnk6CiAgICB1cmw9dXJsbGliLnVucXVvdGVfcGx1cyhwYXJhbXNbInVybCJdKS5kZWNvZGUoJ3V0Zi04JykKZXhjZXB0OgogICAgcGFzcwp0cnk6CiAgICBuYW1lPXVybGxpYi51bnF1b3RlX3BsdXMocGFyYW1zWyJuYW1lIl0pCmV4Y2VwdDoKICAgIHBhc3MKdHJ5OgogICAgaWNvbmltYWdlPXVybGxpYi51bnF1b3RlX3BsdXMocGFyYW1zWyJpY29uaW1hZ2UiXSkKZXhjZXB0OgogICAgcGFzcwp0cnk6CiAgICBmYW5hcnQ9dXJsbGliLnVucXVvdGVfcGx1cyhwYXJhbXNbImZhbmFydCJdKQpleGNlcHQ6CiAgICBwYXNzCnRyeToKICAgIG1vZGU9aW50KHBhcmFtc1sibW9kZSJdKQpleGNlcHQ6CiAgICBwYXNzCnRyeToKICAgIHBsYXlsaXN0PWV2YWwodXJsbGliLnVucXVvdGVfcGx1cyhwYXJhbXNbInBsYXlsaXN0Il0pLnJlcGxhY2UoJ3x8JywnLCcpKQpleGNlcHQ6CiAgICBwYXNzCnRyeToKICAgIGZhdl9tb2RlPWludChwYXJhbXNbImZhdl9tb2RlIl0pCmV4Y2VwdDoKICAgIHBhc3MKdHJ5OgogICAgcmVnZXhzPXBhcmFtc1sicmVnZXhzIl0KZXhjZXB0OgogICAgcGFzcwpwbGF5aXRlbT0nJwp0cnk6CiAgICBwbGF5aXRlbT11cmxsaWIudW5xdW90ZV9wbHVzKHBhcmFtc1sicGxheWl0ZW0iXSkKZXhjZXB0OgogICAgcGFzcwogICAKYWRkb25fbG9nKCJNb2RlOiAiK3N0cihtb2RlKSkKCgoKaWYgbm90IHVybCBpcyBOb25lOgogICAgYWRkb25fbG9nKCJVUkw6ICIrc3RyKHVybC5lbmNvZGUoJ3V0Zi04JykpKQphZGRvbl9sb2coIk5hbWU6ICIrc3RyKG5hbWUpKQoKaWYgbm90IHBsYXlpdGVtID09Jyc6CiAgICBzPWdldFNvdXAoJycsZGF0YT1wbGF5aXRlbSkKICAgIG5hbWUsdXJsLHJlZ2V4cz1nZXRJdGVtcyhzLE5vbmUsZG9udExpbms9VHJ1ZSkKICAgIG1vZGU9MTE3CgppZiBtb2RlPT1Ob25lOgogICAgYWRkb25fbG9nKCJnZXRTb3VyY2VzIikKICAgIGdldFNvdXJjZXMoKQoJCgkKICAgIHhibWNwbHVnaW4uZW5kT2ZEaXJlY3RvcnkoaW50KHN5cy5hcmd2WzFdKSkKCgplbGlmIG1vZGU9PTE6CiAgICBhZGRvbl9sb2coImdldERhdGEiKQogICAgZGF0YT1Ob25lCiAgICAKICAgIGlmIHJlZ2V4cyBhbmQgbGVuKHJlZ2V4cyk+MDoKICAgICAgICBkYXRhLHNldHJlc29sdmVkPWdldFJlZ2V4UGFyc2VkKHJlZ2V4cywgdXJsKQogICAgICAgICNwcmludCBkYXRhCiAgICAgICAgI3VybD0nJwogICAgICAgIGlmIGRhdGEuc3RhcnRzd2l0aCgnaHR0cCcpIG9yIGRhdGEuc3RhcnRzd2l0aCgnc21iJykgb3IgZGF0YS5zdGFydHN3aXRoKCduZnMnKSBvciBkYXRhLnN0YXJ0c3dpdGgoJy8nKToKICAgICAgICAgICAgdXJsPWRhdGEKICAgICAgICAgICAgZGF0YT1Ob25lCiAgICAgICAgI2NyZWF0ZSB4bWwgaGVyZQogICAgCiAgICBnZXREYXRhKHVybCxmYW5hcnQsZGF0YSkKICAgIHhibWNwbHVnaW4uZW5kT2ZEaXJlY3RvcnkoaW50KHN5cy5hcmd2WzFdKSkKCmVsaWYgbW9kZT09MjoKICAgIGFkZG9uX2xvZygiZ2V0Q2hhbm5lbEl0ZW1zIikKICAgIGdldENoYW5uZWxJdGVtcyhuYW1lLHVybCxmYW5hcnQpCiAgICB4Ym1jcGx1Z2luLmVuZE9mRGlyZWN0b3J5KGludChzeXMuYXJndlsxXSkpCgplbGlmIG1vZGU9PTM6CiAgICBhZGRvbl9sb2coImdldFN1YkNoYW5uZWxJdGVtcyIpCiAgICBnZXRTdWJDaGFubmVsSXRlbXMobmFtZSx1cmwsZmFuYXJ0KQogICAgeGJtY3BsdWdpbi5lbmRPZkRpcmVjdG9yeShpbnQoc3lzLmFyZ3ZbMV0pKQoKZWxpZiBtb2RlPT00OgogICAgYWRkb25fbG9nKCJnZXRGYXZvcml0ZXMiKQogICAgZ2V0RmF2b3JpdGVzKCkKICAgIHhibWNwbHVnaW4uZW5kT2ZEaXJlY3RvcnkoaW50KHN5cy5hcmd2WzFdKSkKCmVsaWYgbW9kZT09NToKICAgIGFkZG9uX2xvZygiYWRkRmF2b3JpdGUiKQogICAgdHJ5OgogICAgICAgIG5hbWUgPSBuYW1lLnNwbGl0KCdcXCAnKVsxXQogICAgZXhjZXB0OgogICAgICAgIHBhc3MKICAgIHRyeToKICAgICAgICBuYW1lID0gbmFtZS5zcGxpdCgnICAtICcpWzBdCiAgICBleGNlcHQ6CiAgICAgICAgcGFzcwogICAgYWRkRmF2b3JpdGUobmFtZSx1cmwsaWNvbmltYWdlLGZhbmFydCxmYXZfbW9kZSkKCmVsaWYgbW9kZT09NjoKICAgIGFkZG9uX2xvZygicm1GYXZvcml0ZSIpCiAgICB0cnk6CiAgICAgICAgbmFtZSA9IG5hbWUuc3BsaXQoJ1xcICcpWzFdCiAgICBleGNlcHQ6CiAgICAgICAgcGFzcwogICAgdHJ5OgogICAgICAgIG5hbWUgPSBuYW1lLnNwbGl0KCcgIC0gJylbMF0KICAgIGV4Y2VwdDoKICAgICAgICBwYXNzCiAgICBybUZhdm9yaXRlKG5hbWUpCgplbGlmIG1vZGU9PTc6CiAgICBhZGRvbl9sb2coImFkZFNvdXJjZSIpCiAgICBhZGRTb3VyY2UodXJsKQoKZWxpZiBtb2RlPT04OgogICAgYWRkb25fbG9nKCJybVNvdXJjZSIpCiAgICBybVNvdXJjZShuYW1lKQoKZWxpZiBtb2RlPT05OgogICAgYWRkb25fbG9nKCJkb3dubG9hZF9maWxlIikKICAgIGRvd25sb2FkX2ZpbGUobmFtZSwgdXJsKQoKZWxpZiBtb2RlPT0xMDoKICAgIGFkZG9uX2xvZygiZ2V0Q29tbXVuaXR5U291cmNlcyIpCiAgICBnZXRDb21tdW5pdHlTb3VyY2VzKCkKCmVsaWYgbW9kZT09MTE6CiAgICBhZGRvbl9sb2coImFkZFNvdXJjZSIpCiAgICBhZGRTb3VyY2UodXJsKQoKZWxpZiBtb2RlPT0xMjoKICAgIGFkZG9uX2xvZygic2V0UmVzb2x2ZWRVcmwiKQogICAgaWYgbm90IHVybC5zdGFydHN3aXRoKCJwbHVnaW46Ly9wbHVnaW4iKSBvciBub3QgYW55KHggaW4gdXJsIGZvciB4IGluIGdfaWdub3JlU2V0UmVzb2x2ZWQpOiNub3QgdXJsLnN0YXJ0c3dpdGgoInBsdWdpbjovL3BsdWdpbi52aWRlby5mNG1UZXN0ZXIiKSA6CiAgICAgICAgc2V0cmVzPVRydWUKICAgICAgICBpZiAnJCRMU0RpcmVjdCQkJyBpbiB1cmw6CiAgICAgICAgICAgIHVybD11cmwucmVwbGFjZSgnJCRMU0RpcmVjdCQkJywnJykKICAgICAgICAgICAgc2V0cmVzPUZhbHNlCiAgICAgICAgaWYgJyRQTEFZRVJQUk9YWSQ9JyBpbiB1cmw6CiAgICAgICAgICAgIHVybCxwcm94eT11cmwuc3BsaXQoJyRQTEFZRVJQUk9YWSQ9JykKICAgICAgICAgICAgcHJpbnQgJ3Byb3h5Jyxwcm94eQogICAgICAgICAgICAjSmFpcm94IG1vZCBmb3IgcHJveHkgYXV0aAogICAgICAgICAgICBwcm94eXVzZXIgPSBOb25lCiAgICAgICAgICAgIHByb3h5cGFzcyA9IE5vbmUKICAgICAgICAgICAgaWYgbGVuKHByb3h5KSA+IDAgYW5kICdAJyBpbiBwcm94eToKICAgICAgICAgICAgICAgIHByb3h5ID0gcHJveHkuc3BsaXQoJzonKQogICAgICAgICAgICAgICAgcHJveHl1c2VyID0gcHJveHlbMF0KICAgICAgICAgICAgICAgIHByb3h5cGFzcyA9IHByb3h5WzFdLnNwbGl0KCdAJylbMF0KICAgICAgICAgICAgICAgIHByb3h5aXAgPSBwcm94eVsxXS5zcGxpdCgnQCcpWzFdCiAgICAgICAgICAgICAgICBwb3J0ID0gcHJveHlbMl0KICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIHByb3h5aXAscG9ydD1wcm94eS5zcGxpdCgnOicpCiAgICAgICAgICAgIHBsYXltZWRpYXdpdGhwcm94eSh1cmwsbmFtZSxpY29uaW1hZ2UscHJveHlpcCxwb3J0LCBwcm94eXVzZXIscHJveHlwYXNzKSAjamFpcm94CiAgICAgICAgICAgIAogICAgICAgIGl0ZW0gPSB4Ym1jZ3VpLkxpc3RJdGVtKHBhdGg9dXJsKSAgICAgICAgCiAgICAgICAgaWYgbm90IHNldHJlczoKICAgICAgICAgICAgeGJtYy5QbGF5ZXIoKS5wbGF5KHVybCkKICAgICAgICBlbHNlOiAKICAgICAgICAgICAgeGJtY3BsdWdpbi5zZXRSZXNvbHZlZFVybChpbnQoc3lzLmFyZ3ZbMV0pLCBUcnVlLCBpdGVtKQogICAgZWxzZToKIyAgICAgICAgcHJpbnQgJ05vdCBzZXR0aW5nIHNldFJlc29sdmVkVXJsJwogICAgICAgIHhibWMuZXhlY3V0ZWJ1aWx0aW4oJ1hCTUMuUnVuUGx1Z2luKCcrdXJsKycpJykKCmVsaWYgbW9kZT09MTM6CiAgICBhZGRvbl9sb2coInBsYXlfcGxheWxpc3QiKQogICAgcGxheV9wbGF5bGlzdChuYW1lLCBwbGF5bGlzdCkKCmVsaWYgbW9kZT09MTQ6CiAgICBhZGRvbl9sb2coImdldF94bWxfZGF0YWJhc2UiKQogICAgZ2V0X3htbF9kYXRhYmFzZSh1cmwpCiAgICB4Ym1jcGx1Z2luLmVuZE9mRGlyZWN0b3J5KGludChzeXMuYXJndlsxXSkpCgplbGlmIG1vZGU9PTE1OgogICAgYWRkb25fbG9nKCJicm93c2VfeG1sX2RhdGFiYXNlIikKICAgIGdldF94bWxfZGF0YWJhc2UodXJsLCBUcnVlKQogICAgeGJtY3BsdWdpbi5lbmRPZkRpcmVjdG9yeShpbnQoc3lzLmFyZ3ZbMV0pKQoKZWxpZiBtb2RlPT0xNjoKICAgIGFkZG9uX2xvZygiYnJvd3NlX2NvbW11bml0eSIpCiAgICBnZXRDb21tdW5pdHlTb3VyY2VzKHVybCxicm93c2U9VHJ1ZSkKICAgIHhibWNwbHVnaW4uZW5kT2ZEaXJlY3RvcnkoaW50KHN5cy5hcmd2WzFdKSkKCmVsaWYgbW9kZT09MTcgb3IgbW9kZT09MTE3OgogICAgYWRkb25fbG9nKCJnZXRSZWdleFBhcnNlZCIpCiAgICAjcHJpbnQgJ2dldFJlZ2V4UGFyc2VkJwogICAgZGF0YT1Ob25lCiAgICBpZiByZWdleHMgYW5kICdsaXN0cmVwZWF0JyBpbiB1cmxsaWIudW5xdW90ZV9wbHVzKHJlZ2V4cyk6CiAgICAgICAgbGlzdHJlcGVhdCxyZXQsbSxyZWdleHMsIGNvb2tpZUphciA9Z2V0UmVnZXhQYXJzZWQocmVnZXhzLCB1cmwpCiAgICAgICAgI3ByaW50IGxpc3RyZXBlYXQscmV0LG0scmVnZXhzCiAgICAgICAgZD0nJwojICAgICAgICBwcmludCAnbSBpcycgLCBtCiMgICAgICAgIHByaW50ICdyZWdleHMnLHJlZ2V4cwogICAgICAgIHJlZ2V4bmFtZT1tWyduYW1lJ10KICAgICAgICBleGlzdGluZ19saXN0PXJlZ2V4cy5wb3AocmVnZXhuYW1lKQogIyAgICAgICBwcmludCAnZmluYWwgcmVnZXhzJyxyZWdleHMscmVnZXhuYW1lCiAgICAgICAgdXJsPScnCiAgICAgICAgaW1wb3J0IGNvcHkKICAgICAgICBsbj0nJwogICAgICAgIHJudW1iZXI9MAogICAgICAgIGZvciBvYmogaW4gcmV0OgogICAgICAgICAgICAjcHJpbnQgJ29iaicsb2JqCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIHJudW1iZXIrPTEKICAgICAgICAgICAgICAgIG5ld2NvcHk9Y29weS5kZWVwY29weShyZWdleHMpCiAgICAjICAgICAgICAgICAgcHJpbnQgJ25ld2NvcHknLG5ld2NvcHksIGxlbihuZXdjb3B5KQogICAgICAgICAgICAgICAgbGlzdHJlcGVhdFQ9bGlzdHJlcGVhdAogICAgICAgICAgICAgICAgaT0wCiAgICAgICAgICAgICAgICBmb3IgaSBpbiByYW5nZShsZW4ob2JqKSk6CiAgICAjICAgICAgICAgICAgICAgIHByaW50ICdpIGlzICcsaSwgbGVuKG9iaiksIGxlbihuZXdjb3B5KQogICAgICAgICAgICAgICAgICAgIGlmIGxlbihuZXdjb3B5KT4wOgogICAgICAgICAgICAgICAgICAgICAgICBmb3IgdGhlX2tleU8sIHRoZV92YWx1ZU8gaW4gbmV3Y29weS5pdGVyaXRlbXMoKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHRoZV92YWx1ZU8gaXMgbm90IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHRoZV9rZXksIHRoZV92YWx1ZSBpbiB0aGVfdmFsdWVPLml0ZXJpdGVtcygpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiB0aGVfdmFsdWUgaXMgbm90IE5vbmU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAjICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAgJ2tleSBhbmQgdmFsJyx0aGVfa2V5LCB0aGVfdmFsdWUKICAgICAgICAjICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAnYWEnCiAgICAgICAgIyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgJ1snICsgcmVnZXhuYW1lKycucGFyYW0nK3N0cihpKzEpICsgJ10nCiAgICAgICAgIyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgcmVwcihvYmpbaV0pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiB0eXBlKHRoZV92YWx1ZSkgaXMgZGljdDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgdGhlX2tleWwsIHRoZV92YWx1ZWwgaW4gdGhlX3ZhbHVlLml0ZXJpdGVtcygpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiB0aGVfdmFsdWVsIGlzIG5vdCBOb25lOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsPU5vbmUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2Uob2JqLHR1cGxlKTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbD0gb2JqW2ldLmRlY29kZSgndXRmLTgnKSAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw9IG9ialtpXSAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw9IG9iai5kZWNvZGUoJ3V0Zi04JykgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw9IG9iagogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAnWycgKyByZWdleG5hbWUrJy5wYXJhbScrc3RyKGkrMSkgKyAnXVtERV0nIGluIHRoZV92YWx1ZWw6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlX3ZhbHVlbD10aGVfdmFsdWVsLnJlcGxhY2UoJ1snICsgcmVnZXhuYW1lKycucGFyYW0nK3N0cihpKzEpICsgJ11bREVdJywgdW5lc2NhcGUodmFsKSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZV92YWx1ZVt0aGVfa2V5bF09dGhlX3ZhbHVlbC5yZXBsYWNlKCdbJyArIHJlZ2V4bmFtZSsnLnBhcmFtJytzdHIoaSsxKSArICddJywgdmFsKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50ICdmaXJzdCBzZWMnLHRoZV92YWx1ZVt0aGVfa2V5bF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw9Tm9uZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2Uob2JqLHR1cGxlKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbD1vYmpbaV0uZGVjb2RlKCd1dGYtOCcpIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw9b2JqW2ldIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbD0gb2JqLmRlY29kZSgndXRmLTgnKSAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsPSBvYmoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAnWycgKyByZWdleG5hbWUrJy5wYXJhbScrc3RyKGkrMSkgKyAnXVtERV0nIGluIHRoZV92YWx1ZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50ICdmb3VuZCBERScsdGhlX3ZhbHVlLnJlcGxhY2UoJ1snICsgcmVnZXhuYW1lKycucGFyYW0nK3N0cihpKzEpICsgJ11bREVdJywgdW5lc2NhcGUodmFsKSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlX3ZhbHVlPXRoZV92YWx1ZS5yZXBsYWNlKCdbJyArIHJlZ2V4bmFtZSsnLnBhcmFtJytzdHIoaSsxKSArICddW0RFXScsIHVuZXNjYXBlKHZhbCkpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZV92YWx1ZU9bdGhlX2tleV09dGhlX3ZhbHVlLnJlcGxhY2UoJ1snICsgcmVnZXhuYW1lKycucGFyYW0nK3N0cihpKzEpICsgJ10nLCB2YWwpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI3ByaW50ICdzZWNvbmQgc2VjIHZhbCcsdGhlX3ZhbHVlT1t0aGVfa2V5XQoKICAgICAgICAgICAgICAgICAgICB2YWw9Tm9uZQogICAgICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2Uob2JqLHR1cGxlKToKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsPW9ialtpXS5kZWNvZGUoJ3V0Zi04JykKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsPW9ialtpXQogICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbD1vYmouZGVjb2RlKCd1dGYtOCcpCiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDogCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw9b2JqCiAgICAgICAgICAgICAgICAgICAgaWYgJ1snICsgcmVnZXhuYW1lKycucGFyYW0nK3N0cihpKzEpICsgJ11bREVdJyBpbiBsaXN0cmVwZWF0VDoKICAgICAgICAgICAgICAgICAgICAgICAgbGlzdHJlcGVhdFQ9bGlzdHJlcGVhdFQucmVwbGFjZSgnWycgKyByZWdleG5hbWUrJy5wYXJhbScrc3RyKGkrMSkgKyAnXVtERV0nLHZhbCkKICAgICAgICAgICAgICAgICAgICBsaXN0cmVwZWF0VD1saXN0cmVwZWF0VC5yZXBsYWNlKCdbJyArIHJlZ2V4bmFtZSsnLnBhcmFtJytzdHIoaSsxKSArICddJyxlc2NhcGUodmFsKSkKIyAgICAgICAgICAgICAgICAgICAgcHJpbnQgbGlzdHJlcGVhdFQKICAgICAgICAgICAgICAgIGxpc3RyZXBlYXRUPWxpc3RyZXBlYXRULnJlcGxhY2UoJ1snICsgcmVnZXhuYW1lKycucGFyYW0nK3N0cigwKSArICddJyxzdHIocm51bWJlcikpIAogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgaWYgY29va2llSmFyIGFuZCAnWycgKyByZWdleG5hbWUrJy5jb29raWVzXScgaW4gbGlzdHJlcGVhdFQ6CiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RyZXBlYXRUPWxpc3RyZXBlYXRULnJlcGxhY2UoJ1snICsgcmVnZXhuYW1lKycuY29va2llc10nLGdldENvb2tpZXNTdHJpbmcoY29va2llSmFyKSkgCiAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgI25ld2NvcHkgPSB1cmxsaWIucXVvdGUocmVwcihuZXdjb3B5KSkKICAgICMgICAgICAgICAgICBwcmludCAnbmV3IHJlZ2V4IGxpc3QnLCByZXByKG5ld2NvcHkpLCByZXByKGxpc3RyZXBlYXRUKQogICAgIyAgICAgICAgICAgIGFkZExpbmsobGlzdGxpbmtULGxpc3R0aXRsZVQuZW5jb2RlKCd1dGYtOCcsICdpZ25vcmUnKSxsaXN0dGh1bWJuYWlsVCwnJywnJywnJywnJyxUcnVlLE5vbmUsbmV3Y29weSwgbGVuKHJldCkpCiAgICAgICAgICAgICAgICByZWdleF94bWw9JycKIyAgICAgICAgICAgICAgICBwcmludCAnbmV3Y29weScsbmV3Y29weQogICAgICAgICAgICAgICAgaWYgbGVuKG5ld2NvcHkpPjA6CiAgICAgICAgICAgICAgICAgICAgcmVnZXhfeG1sPWQyeChuZXdjb3B5LCdsc3Byb3Jvb3QnKQogICAgICAgICAgICAgICAgICAgIHJlZ2V4X3htbD1yZWdleF94bWwuc3BsaXQoJzxsc3Byb3Jvb3Q+JylbMV0uc3BsaXQoJzwvbHNwcm9yb290JylbMF0KICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICNsbis9J1xuPGl0ZW0+JXNcbiVzPC9pdGVtPiclKGxpc3RyZXBlYXRULmVuY29kZSgidXRmLTgiKSxyZWdleF94bWwpICAgCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgbG4rPSdcbjxpdGVtPiVzXG4lczwvaXRlbT4nJShsaXN0cmVwZWF0VCxyZWdleF94bWwpCiAgICAgICAgICAgICAgICBleGNlcHQ6IGxuKz0nXG48aXRlbT4lc1xuJXM8L2l0ZW0+JyUobGlzdHJlcGVhdFQuZW5jb2RlKCJ1dGYtOCIpLHJlZ2V4X3htbCkKICAgICAgICAgICAgZXhjZXB0OiB0cmFjZWJhY2sucHJpbnRfZXhjKGZpbGU9c3lzLnN0ZG91dCkKIyAgICAgICAgICAgIHByaW50IHJlcHIobG4pCiMgICAgICAgICAgICBwcmludCBuZXdjb3B5CiAgICAgICAgICAgICAgICAKIyAgICAgICAgICAgIGxuKz0nPC9pdGVtPicKICAgICAgICAKICAgICAgICBhZGRvbl9sb2cocmVwcihsbikpCiAgICAgICAgZ2V0RGF0YSgnJywnJyxsbikKICAgICAgICB4Ym1jcGx1Z2luLmVuZE9mRGlyZWN0b3J5KGludChzeXMuYXJndlsxXSkpCiAgICBlbHNlOgogICAgICAgIHVybCxzZXRyZXNvbHZlZCA9IGdldFJlZ2V4UGFyc2VkKHJlZ2V4cywgdXJsKQogICAgICAgICNwcmludCAnaW1oZXJlJywgcmVwcih1cmwpLHNldHJlc29sdmVkLG5hbWUKICAgICAgICAjcHJpbnQgJ2ltaGVyZScKICAgICAgICBpZiBub3QgKHJlZ2V4cyBhbmQgJ25vdHBsYXlhYmxlJyBpbiByZWdleHMgYW5kIG5vdCB1cmwpOiAgICAgICAgCiAgICAgICAgICAgIGlmIHVybDoKICAgICAgICAgICAgICAgIGlmICckUExBWUVSUFJPWFkkPScgaW4gdXJsOgogICAgICAgICAgICAgICAgICAgIHVybCxwcm94eT11cmwuc3BsaXQoJyRQTEFZRVJQUk9YWSQ9JykKICAgICAgICAgICAgICAgICAgICBwcmludCAncHJveHknLHByb3h5CiAgICAgICAgICAgICAgICAgICAgI0phaXJveCBtb2QgZm9yIHByb3h5IGF1dGgKICAgICAgICAgICAgICAgICAgICBwcm94eXVzZXIgPSBOb25lCiAgICAgICAgICAgICAgICAgICAgcHJveHlwYXNzID0gTm9uZQogICAgICAgICAgICAgICAgICAgIGlmIGxlbihwcm94eSkgPiAwIGFuZCAnQCcgaW4gcHJveHk6CiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5ID0gcHJveHkuc3BsaXQoJzonKQogICAgICAgICAgICAgICAgICAgICAgICBwcm94eXVzZXIgPSBwcm94eVswXQogICAgICAgICAgICAgICAgICAgICAgICBwcm94eXBhc3MgPSBwcm94eVsxXS5zcGxpdCgnQCcpWzBdCiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5aXAgPSBwcm94eVsxXS5zcGxpdCgnQCcpWzFdCiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQgPSBwcm94eVsyXQogICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5aXAscG9ydD1wcm94eS5zcGxpdCgnOicpCgogICAgICAgICAgICAgICAgICAgIHBsYXltZWRpYXdpdGhwcm94eSh1cmwsbmFtZSxpY29uaW1hZ2UscHJveHlpcCxwb3J0LCBwcm94eXVzZXIscHJveHlwYXNzKSAjamFpcm94CiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIHBsYXlzZXRyZXNvbHZlZCh1cmwsbmFtZSxpY29uaW1hZ2Usc2V0cmVzb2x2ZWQscmVnZXhzKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgeGJtYy5leGVjdXRlYnVpbHRpbigiWEJNQy5Ob3RpZmljYXRpb24oRmlyZVRWLEZhaWxlZCB0byBleHRyYWN0IHJlZ2V4LiAtICIrInRoaXMiKyIsNDAwMCwiK2ljb24rIikiKQoKZWxpZiBtb2RlPT0xODoKICAgIGFkZG9uX2xvZygieW91dHViZWRsIikKICAgIHRyeToKICAgICAgICBpbXBvcnQgeW91dHViZWRsCiAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgIHhibWMuZXhlY3V0ZWJ1aWx0aW4oIlhCTUMuTm90aWZpY2F0aW9uKEZpcmVUVixQbGVhc2UgW0NPTE9SIHllbGxvd11pbnN0YWxsIFlvdXR1YmUtZGxbL0NPTE9SXSBtb2R1bGUgLDEwMDAwLCIiKSIpCiAgICBzdHJlYW1fdXJsPXlvdXR1YmVkbC5zaW5nbGVfWUQodXJsKQogICAgcGxheXNldHJlc29sdmVkKHN0cmVhbV91cmwsbmFtZSxpY29uaW1hZ2UpCgplbGlmIG1vZGU9PTE5OgogICAgYWRkb25fbG9nKCJHZW5lc2lzY29tbW9ucmVzb2x2ZXJzIikKICAgIHBsYXlzZXRyZXNvbHZlZCAodXJsc29sdmVyKHVybCksbmFtZSxpY29uaW1hZ2UsVHJ1ZSkKCmVsaWYgbW9kZT09MjA6CiAgICBhZGRvbl9sb2coInNldFJlc29sdmVkVXJsIikKICAgIGl0ZW0gPSB4Ym1jZ3VpLkxpc3RJdGVtKHBhdGg9dXJsKQogICAgaWYgJ3wnIGluIHVybDoKICAgICAgICB1cmwsc3RyaGRyID0gdXJsLnNwbGl0KCd8JykKICAgICAgICBpdGVtLnNldFByb3BlcnR5KCdpbnB1dHN0cmVhbS5hZGFwdGl2ZS5zdHJlYW1faGVhZGVycycsIHN0cmhkcikKICAgICAgICBpdGVtLnNldFBhdGgodXJsKQogICAgaWYgJy5tM3U4JyBpbiB1cmw6CiAgICAgICAgaXRlbS5zZXRQcm9wZXJ0eSgnaW5wdXRzdHJlYW1hZGRvbicsICdpbnB1dHN0cmVhbS5hZGFwdGl2ZScpCiAgICAgICAgaXRlbS5zZXRQcm9wZXJ0eSgnaW5wdXRzdHJlYW0uYWRhcHRpdmUubWFuaWZlc3RfdHlwZScsICdobHMnKQogICAgICAgIGl0ZW0uc2V0TWltZVR5cGUoJ2FwcGxpY2F0aW9uL3ZuZC5hcHBsZS5tcGVnc3RyZWFtX3VybCcpCiAgICAgICAgaXRlbS5zZXRDb250ZW50TG9va3VwKEZhbHNlKQogICAKICAgIGVsaWYgJy5tcGQnIGluIHVybDoKICAgICAgICBpdGVtLnNldFByb3BlcnR5KCdpbnB1dHN0cmVhbWFkZG9uJywgJ2lucHV0c3RyZWFtLmFkYXB0aXZlJykKICAgICAgICBpdGVtLnNldFByb3BlcnR5KCdpbnB1dHN0cmVhbS5hZGFwdGl2ZS5tYW5pZmVzdF90eXBlJywgJ21wZCcpCiAgICAgICAgaXRlbS5zZXRNaW1lVHlwZSgnYXBwbGljYXRpb24vZGFzaCt4bWwnKQogICAgICAgIGl0ZW0uc2V0Q29udGVudExvb2t1cChGYWxzZSkKICAgIAogICAgZWxpZiAnLmlzbScgaW4gdXJsOgogICAgICAgIGl0ZW0uc2V0UHJvcGVydHkoJ2lucHV0c3RyZWFtYWRkb24nLCAnaW5wdXRzdHJlYW0uYWRhcHRpdmUnKQogICAgICAgIGl0ZW0uc2V0UHJvcGVydHkoJ2lucHV0c3RyZWFtLmFkYXB0aXZlLm1hbmlmZXN0X3R5cGUnLCAnaXNtJykKICAgICAgICBpdGVtLnNldE1pbWVUeXBlKCdhcHBsaWNhdGlvbi92bmQubXMtc3N0cit4bWwnKQogICAgICAgIGl0ZW0uc2V0Q29udGVudExvb2t1cChGYWxzZSkKCiAgICB4Ym1jcGx1Z2luLnNldFJlc29sdmVkVXJsKGludChzeXMuYXJndlsxXSksIFRydWUsIGl0ZW0pCgplbGlmIG1vZGU9PTIxOgogICAgYWRkb25fbG9nKCJkb3dubG9hZCBjdXJyZW50IGZpbGUgdXNpbmcgeW91dHViZS1kbCBzZXJ2aWNlIikKICAgIG10eXBlPSd2aWRlbycKICAgIGlmICdbbXAzXScgaW4gbmFtZToKICAgICAgICBtdHlwZT0nYXVkaW8nCiAgICAgICAgbmFtZT1uYW1lLnJlcGxhY2UoJ1ttcDNdJywnJykKICAgIHl0ZGxfZG93bmxvYWQoJycsbmFtZSwgbXR5cGUpCgplbGlmIG1vZGU9PTIyOgogICAgcHJpbnQgInNscHJveHkiCiAgICB0cnk6CiAgICAgICAgZnJvbSBkc3AgaW1wb3J0IHN0cmVhbWxpbmtfcHJveHkKICAgICAgICB0cnk6CiAgICAgICAgICAgIHEgPSAgcmUuZmluZGFsbChyJ1wkXCRRVUFMSVRZPShbXlwkXCRdKylcJFwkJywgdXJsKVswXQogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgcSA9ICcnIGlmIHJlLnNlYXJjaChyJ1wkXCRSRVNPTFZFT05MWVwkXCQnLCB1cmwpIGVsc2UgJ2Jlc3QnCiAgICAgICAgdXJsID0gcmUuc3ViKHInXCRcJFFVQUxJVFk9Lio/XCRcJCcsICcnLCB1cmwpCiAgICAgICAgCiAgICAgICAgdHJ5OgogICAgICAgICAgICBwcnh5ID0gIHJlLmZpbmRhbGwocidcJFwkSFRUUFBST1hZPShbXlwkXCRdKylcJFwkJywgdXJsKVswXQogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgcHJ4eSA9ICcnCiAgICAgICAgdXJsID0gcmUuc3ViKHInXCRcJEhUVFBQUk9YWT0uKj9cJFwkJywgJycsIHVybCkKICAgICAgICBwcnh5ID0gJycgaWYgcHJ4eSA9PSAnJyBlbHNlICcmYW1wO3A9JXMnJXByeHkKCiAgICAgICAgaWYgcmUuc2VhcmNoKHInXCRcJFJFU09MVkVPTkxZXCRcJCcsIHVybCk6CiAgICAgICAgICAgIHVybCA9IHJlLnN1YihyJ1wkXCRSRVNPTFZFT05MWVwkXCQnLCAnJywgdXJsKQogICAgICAgICAgICBzbFByb3h5ID0gc3RyZWFtbGlua19wcm94eS5TTFByb3h5X0hlbHBlcigpCiAgICAgICAgICAgIHEgPSAnJyBpZiBxID09ICcnIGVsc2UgJyZhbXA7cT0lcyclcQogICAgICAgICAgICB1cmwgPSBzbFByb3h5LnJlc29sdmVfdXJsKHVybGxpYi5xdW90ZSh1cmwpK3ErcHJ4eSkKICAgICAgICAgICAgYWRkb25fbG9nKCJzZXRSZXNvbHZlZFVybCIpCiAgICAgICAgICAgIGxpc3RpdGVtID0geGJtY2d1aS5MaXN0SXRlbShzdHIobmFtZSkpCiAgICAgICAgICAgIGxpc3RpdGVtLnNldEluZm8oJ3ZpZGVvJywgeydUaXRsZSc6IHN0cihuYW1lKX0pCiAgICAgICAgICAgIGxpc3RpdGVtLnNldFBhdGgodXJsKQogICAgICAgICAgICB4Ym1jcGx1Z2luLnNldFJlc29sdmVkVXJsKGludChzeXMuYXJndlsxXSksIFRydWUsIGxpc3RpdGVtKQoKICAgICAgICBlbHNlOgogICAgICAgICAgICBzbFByb3h5ID0gc3RyZWFtbGlua19wcm94eS5TTFByb3h5X0hlbHBlcigpICAgICAgICAgICAgCiAgICAgICAgICAgIHVybCA9IHVybGxpYi5xdW90ZSh1cmwpKycmYW1wO3E9JXMnJXEgKyBwcnh5CiAgICAgICAgICAgIGxpc3RpdGVtID0geGJtY2d1aS5MaXN0SXRlbShzdHIobmFtZSkpCiAgICAgICAgICAgIGxpc3RpdGVtLnNldEluZm8oJ3ZpZGVvJywgeydUaXRsZSc6IHN0cihuYW1lKX0pCiAgICAgICAgICAgIGxpc3RpdGVtLnNldFBhdGgodXJsKSAgICAgICAgIAogICAgICAgICAgICBzbFByb3h5LnBsYXlTTGluayh1cmwsIGxpc3RpdGVtKQogICAgZXhjZXB0OgogICAgICAgIGltcG9ydCBzeXMKICAgICAgICB0cmFjZWJhY2sucHJpbnRfZXhjKGZpbGU9c3lzLnN0ZG91dCkKICAgICAgICBwYXNzCgplbGlmIG1vZGU9PTIzOgogICAgYWRkb25fbG9nKCJnZXQgaW5mbyB0aGVuIGRvd25sb2FkIikKICAgIG10eXBlPSd2aWRlbycKICAgIGlmICdbbXAzXScgaW4gbmFtZToKICAgICAgICBtdHlwZT0nYXVkaW8nCiAgICAgICAgbmFtZT1uYW1lLnJlcGxhY2UoJ1ttcDNdJywnJykKICAgIHl0ZGxfZG93bmxvYWQodXJsLG5hbWUsbXR5cGUpCgplbGlmIG1vZGU9PTI0OgogICAgYWRkb25fbG9nKCJBdWRpbyBvbmx5IHlvdXR1YmUgZG93bmxvYWQiKQogICAgeXRkbF9kb3dubG9hZCh1cmwsbmFtZSwnYXVkaW8nKQoKZWxpZiBtb2RlPT0yNToKICAgIGFkZG9uX2xvZygiU2VhcmNoaW4gT3RoZXIgcGx1Z2lucyIpCiAgICBfc2VhcmNoKHVybCxuYW1lKQogICAgeGJtY3BsdWdpbi5lbmRPZkRpcmVjdG9yeShpbnQoc3lzLmFyZ3ZbMV0pKQoKZWxpZiBtb2RlPT01NToKICAgIGFkZG9uX2xvZygiZW5hYmxlZCBsb2NrIikKICAgIHBhcmVudGFsYmxvY2tlZHBpbiA9IGFkZG9uLmdldFNldHRpbmcoJ3BhcmVudGFsYmxvY2tlZHBpbicpCiAgICBrZXlib2FyZCA9IHhibWMuS2V5Ym9hcmQoJycsJ0VudGVyIFBpbicpCiAgICBrZXlib2FyZC5kb01vZGFsKCkKICAgIGlmIG5vdCAoa2V5Ym9hcmQuaXNDb25maXJtZWQoKSA9PSBGYWxzZSk6CiAgICAgICAgbmV3U3RyID0ga2V5Ym9hcmQuZ2V0VGV4dCgpCiAgICAgICAgaWYgbmV3U3RyPT1wYXJlbnRhbGJsb2NrZWRwaW46CiAgICAgICAgICAgIGFkZG9uLnNldFNldHRpbmcoJ3BhcmVudGFsYmxvY2tlZCcsICJmYWxzZSIpCiAgICAgICAgICAgIHhibWMuZXhlY3V0ZWJ1aWx0aW4oIlhCTUMuTm90aWZpY2F0aW9uKEZpcmVUViwgem9uYSBwcmVtaXVtIGRlc2FjdGl2YWRhLDUwMDAsIitpY29uKyIpIikKICAgICAgICBlbHNlOgogICAgICAgICAgICB4Ym1jLmV4ZWN1dGVidWlsdGluKCJYQk1DLk5vdGlmaWNhdGlvbihGaXJlVFYsIENvZGlnbyBkZSBhY3RpdmFjaW9uPyw1MDAwLCIraWNvbisiKSIpCiAgICB4Ym1jcGx1Z2luLmVuZE9mRGlyZWN0b3J5KGludChzeXMuYXJndlsxXSkpCiAgICAKZWxpZiBtb2RlPT01NjoKICAgIGFkZG9uX2xvZygiZGlzYWJsZSBsb2NrIikKICAgIGFkZG9uLnNldFNldHRpbmcoJ3BhcmVudGFsYmxvY2tlZCcsICJ0cnVlIikKICAgIHhibWMuZXhlY3V0ZWJ1aWx0aW4oIlhCTUMuTm90aWZpY2F0aW9uKEZpcmVUVixab25hIHByZW1pdW0gYWN0aXZhZGEsNTAwMCwiK2ljb24rIikiKQogICAgeGJtY3BsdWdpbi5lbmRPZkRpcmVjdG9yeShpbnQoc3lzLmFyZ3ZbMV0pKQoKZWxpZiBtb2RlPT01MzoKICAgIGFkZG9uX2xvZygiUmVxdWVzdGluZyBKU09OLVJQQyBJdGVtcyIpCiAgICBwbHVnaW5xdWVyeWJ5SlNPTih1cmwpCiAgICAjeGJtY3BsdWdpbi5lbmRPZkRpcmVjdG9yeShpbnQoc3lzLmFyZ3ZbMV0pKQoKaWYgbm90IHZpZXdtb2RlPT1Ob25lOgogICBwcmludCAnc2V0dGluZyB2aWV3IG1vZGUnCiAgIHhibWMuZXhlY3V0ZWJ1aWx0aW4oIkNvbnRhaW5lci5TZXRWaWV3TW9kZSglcykiJXZpZXdtb2RlKQ==')

# -*- coding: utf-8 -*-
import urllib
import urllib2
import re
import os
import xbmcplugin
import xbmcgui
import xbmcaddon
import xbmcvfs
import traceback
import cookielib,base64
import codecs
import xbmc
import sys
from BeautifulSoup import BeautifulStoneSoup, BeautifulSoup, BeautifulSOAP
viewmode=None
try:
    from xml.sax.saxutils import escape
except: traceback.print_exc()
try:
    import json
except:
    import simplejson as json
import SimpleDownloader as downloader
import time
tsdownloader=False
hlsretry=False
resolve_url=['180upload.com', 'allmyvideos.net', 'bestreams.net', 'clicknupload.com', 'cloudzilla.to', 'movshare.net', 'novamov.com', 'nowvideo.sx', 'videoweed.es', 'daclips.in', 'datemule.com', 'fastvideo.in', 'faststream.in', 'filehoot.com', 'filenuke.com', 'sharesix.com',  'plus.google.com', 'picasaweb.google.com', 'gorillavid.com', 'gorillavid.in', 'grifthost.com', 'hugefiles.net', 'ipithos.to', 'ishared.eu', 'kingfiles.net', 'mail.ru', 'my.mail.ru', 'videoapi.my.mail.ru', 'mightyupload.com', 'mooshare.biz', 'movdivx.com', 'movpod.net', 'movpod.in', 'movreel.com', 'mrfile.me', 'nosvideo.com', 'openload.io', 'played.to', 'bitshare.com', 'filefactory.com', 'k2s.cc', 'oboom.com', 'rapidgator.net', 'primeshare.tv', 'bitshare.com', 'filefactory.com', 'k2s.cc', 'oboom.com', 'rapidgator.net', 'sharerepo.com', 'stagevu.com', 'streamcloud.eu', 'streamin.to', 'thefile.me', 'thevideo.me', 'tusfiles.net', 'uploadc.com', 'zalaa.com', 'uploadrocket.net', 'uptobox.com', 'v-vids.com', 'veehd.com', 'vidbull.com', 'videomega.tv', 'vidplay.net', 'vidspot.net', 'vidto.me', 'vidzi.tv', 'vimeo.com', 'vk.com', 'vodlocker.com', 'xfileload.com', 'xvidstage.com', 'zettahost.tv']
g_ignoreSetResolved=['plugin.video.dramasonline','plugin.video.f4mTester','plugin.video.shahidmbcnet','plugin.video.SportsDevil','plugin.stream.vaughnlive.tv','plugin.video.ZemTV-shani']
global gLSProDynamicCodeNumber
gLSProDynamicCodeNumber=0
class NoRedirection(urllib2.HTTPErrorProcessor):
   def http_response(self, request, response):
       return response
   https_response = http_response
   

REMOTE_DBG=False
if REMOTE_DBG:
    # Make pydev debugger works for auto reload.
    # Note pydevd module need to be copied in XBMC\system\python\Lib\pysrc
    try:
        import pysrc.pydevd as pydevd
    # stdoutToServer and stderrToServer redirect stdout and stderr to eclipse console
        pydevd.settrace('localhost', stdoutToServer=True, stderrToServer=True)
    except ImportError:
        sys.stderr.write("Error: " +
            "You must add org.python.pydev.debug.pysrc to your PYTHONPATH.")
        sys.exit(1)
		


addon = xbmcaddon.Addon('plugin.video.FireTV')
addon_version = addon.getAddonInfo('version')
profile = xbmc.translatePath(addon.getAddonInfo('profile').decode('utf-8'))
home = xbmc.translatePath(addon.getAddonInfo('path').decode('utf-8'))
favorites = os.path.join(profile, 'favorites')
history = os.path.join(profile, 'history')
REV = os.path.join(profile, 'list_revision')
icon = os.path.join(home, 'icon.png')
FANART = os.path.join(home, 'fanart.jpg')
source_file = os.path.join(home, 'source_file')
functions_dir = profile

communityfiles = os.path.join(profile, 'LivewebTV')
downloader = downloader.SimpleDownloader()
debug = addon.getSetting('debug')
texto_regex = 'msg=[\'"](.*?)[\'"]\s*texto1=[\'"](.*?)[\'"]\s*texto2=[\'"](.*?)[\'"]\s*texto3=[\'"](.*?)[\'"]\s*'


exec codecs.decode("63727970746F203D20275C7836385C7836355C7837385C7836385C7836355C783738270D0A623136203D2063727970746F2E7265706C61636528275C7836385C7836355C7837385C7836385C7836355C783738272C275C7836385C7836355C78373827290D0A6269656E76656E696461203D202768747470733A2F2F706173746562696E2E636F6D2F7261772F70504E796A57626E270D0A0D0A0D0A6578656320636F646563732E6465636F6465282236393636323036463733324537303631373436383245363537383639373337343733323836363631373636463732363937343635373332393344334435343732373536353341304430413230323032303230343634313536323033443230364637303635364532383636363137363646373236393734363537333239324537323635363136343238323930443041363536433733363533413230343634313536323033443230354235443044304130443041363936363230364637333245373036313734363832453635373836393733373437333238373336463735373236333635354636363639364336353239334433443534373237353635334130443041323032303230323035333446353535323433343535333230334432303646373036353645323837333646373537323633363535463636363936433635323932453732363536313634323832393044304136353643373336353341323030443041304430413039353334463535353234333435353332303344323035423544222C20275C7836385C7836355C78373827292E6465636F646528277574662D382729", '\x68\x65\x78').decode('\x75\x74\x66\x2d\x38')




"""

Leer Mensaje de entrada:

"""


def read_file(file):
## FUNCION QUE LEE LOS FICHEROS:
    try:
        f = open(file, 'r')
        content = f.read()
        f.close()
        return content
    except:
        pass

def make_request(url):
##ESTA FUNCION lee las url declaradas donde estan los videos. ||
	try:
		req = urllib2.Request(url)
		req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0')
		response = urllib2.urlopen(req)	  
		link = response.read()
		response.close()  
		return link
	except urllib2.URLError, e:
		print 'We failed to open "%s".' % url
		if hasattr(e, 'code'):
			print 'We failed with error code - %s.' % e.code	
		if hasattr(e, 'reason'):
			print 'We failed to reach a server.'
			print 'Reason: ', e.reason
			
def OPEN_URL(url):
        req = urllib2.Request(url)
        req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.85 Safari/537.36')
        req.add_header('Referer', '%s'%url)
        req.add_header('Connection', 'keep-alive')
        response = urllib2.urlopen(req)
        link=response.read()
        response.close()
        return link
		
		
def mensaje():
	
	
		try:
			content = make_request(bienvenida)
			match = re.compile(texto_regex).findall(content)
			for msg,texto1,texto2,texto3 in match:
				
				try:
	
					
				    msg1 = texto1
				    msg2 = texto2
				    msg3 = texto3

	
			
				    line1 = "[B]" + msg1 + "[/B]"
				    line2 = "" + msg2 + ""
				    line3 = "" +msg3 + ""

				    xbmcgui.Dialog().ok("Real Stream", line1, line2, line3)
				
				except:
			           pass
					
		except:
			pass




def addon_log(string):
    if debug == 'true':
        xbmc.log("[addon.FireTV-%s]: %s" %(addon_version, string))

def makeRequest(url, headers=None):
        try:
            if headers is None:
                headers = {'User-Agent' : 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'}
                
            if '|' in url:
                url,header_in_page=url.split('|')
                header_in_page=header_in_page.split('&')
                
                for h in header_in_page:
                    if len(h.split('='))==2:
                        n,v=h.split('=')
                    else:
                        vals=h.split('=')
                        n=vals[0]
                        v='='.join(vals[1:])
                        #n,v=h.split('=')
                    print n,v
                    headers[n]=v
                    
            req = urllib2.Request(url,None,headers)
            response = urllib2.urlopen(req)
            data = response.read()
            response.close()
            return data
        except urllib2.URLError, e:
            addon_log('URL: '+url)
            if hasattr(e, 'code'):
                addon_log('We failed with error code - %s.' % e.code)
                xbmc.executebuiltin("XBMC.Notification(FireTV,We failed with error code - "+str(e.code)+",10000,"+icon+")")
            elif hasattr(e, 'reason'):
                addon_log('We failed to reach a server.')
                addon_log('Reason: %s' %e.reason)
                xbmc.executebuiltin("XBMC.Notification(FireTV,We failed to reach a server. - "+str(e.reason)+",10000,"+icon+")")

def getSources():

        try:
            if os.path.exists(favorites) == True:
                addDir('Favorites','url',4,os.path.join(home, 'resources', 'favorite.png'),FANART,'','','','')
            if addon.getSetting("browse_xml_database") == "true":
                addDir('XML Database','http://xbmcplus.xb.funpic.de/www-data/filesystem/',15,icon,FANART,'','','','')
            if addon.getSetting("browse_community") == "true":
                addDir('Community Files','community_files',16,icon,FANART,'','','','')
            if addon.getSetting("searchotherplugins") == "true":
                addDir('Search Other Plugins','Search Plugins',25,icon,FANART,'','','','')
            if os.path.exists(source_file)==True:
                sources = json.loads(open(source_file,"r").read())
                #print 'sources',sources
                if len(sources) > 1:
                    for i in sources:
                        try:
                            ## for pre 1.0.8 sources
                            if isinstance(i, list):
                                addDir(i[0].encode('utf-8'),i[1].encode('utf-8'),1,icon,FANART,'','','','','source')
                            else:
                                thumb = icon
                                fanart = FANART
                                desc = ''
                                date = ''
                                credits = ''
                                genre = ''
                                if i.has_key('thumbnail'):
                                    thumb = i['thumbnail']
                                if i.has_key('fanart'):
                                    fanart = i['fanart']
                                if i.has_key('description'):
                                    desc = i['description']
                                if i.has_key('date'):
                                    date = i['date']
                                if i.has_key('genre'):
                                    genre = i['genre']
                                if i.has_key('credits'):
                                    credits = i['credits']
                                addDir(i['title'].encode('utf-8'),i['url'].encode('utf-8'),1,thumb,fanart,desc,genre,date,credits,'source')
                        except: traceback.print_exc()
                else:
                    if len(sources) == 1:
                        if isinstance(sources[0], list):
                            getData(sources[0][1].encode('utf-8'),FANART)
                        else:
                            getData(sources[0]['url'], sources[0]['fanart'])
        except: traceback.print_exc()

def addSource(url=None):
        if url is None:
            if not addon.getSetting("new_file_source") == "":
               source_url = addon.getSetting('new_file_source').decode('utf-8')
            elif not addon.getSetting("new_url_source") == "":
               source_url = addon.getSetting('new_url_source').decode('utf-8')
        else:
            source_url = url
        if source_url == '' or source_url is None:
            return
        addon_log('Adding New Source: '+source_url.encode('utf-8'))

        media_info = None
        #print 'source_url',source_url
        data = getSoup(source_url)
                
        if isinstance(data,BeautifulSOAP):
            if data.find('channels_info'):
                media_info = data.channels_info
            elif data.find('items_info'):
                media_info = data.items_info
        if media_info:
            source_media = {}
            source_media['url'] = source_url
            try: source_media['title'] = media_info.title.string
            except: pass
            try: source_media['thumbnail'] = media_info.thumbnail.string
            except: pass
            try: source_media['fanart'] = media_info.fanart.string
            except: pass
            try: source_media['genre'] = media_info.genre.string
            except: pass
            try: source_media['description'] = media_info.description.string
            except: pass
            try: source_media['date'] = media_info.date.string
            except: pass
            try: source_media['credits'] = media_info.credits.string
            except: pass
        else:
            if '/' in source_url:
                nameStr = source_url.split('/')[-1].split('.')[0]
            if '\\' in source_url:
                nameStr = source_url.split('\\')[-1].split('.')[0]
            if '%' in nameStr:
                nameStr = urllib.unquote_plus(nameStr)
            keyboard = xbmc.Keyboard(nameStr,'Displayed Name, Rename?')
            keyboard.doModal()
            if (keyboard.isConfirmed() == False):
                return
            newStr = keyboard.getText()
            if len(newStr) == 0:
                return
            source_media = {}
            source_media['title'] = newStr
            source_media['url'] = source_url
            source_media['fanart'] = fanart

        if os.path.exists(source_file)==False:
            source_list = []
            source_list.append(source_media)
            b = open(source_file,"w")
            b.write(json.dumps(source_list))
            b.close()
        else:
            sources = json.loads(open(source_file,"r").read())
            sources.append(source_media)
            b = open(source_file,"w")
            b.write(json.dumps(sources))
            b.close()
        addon.setSetting('new_url_source', "")
        addon.setSetting('new_file_source', "")
        xbmc.executebuiltin("XBMC.Notification(FireTV,New source added.,5000,"+icon+")")
        if not url is None:
            if 'xbmcplus.xb.funpic.de' in url:
                xbmc.executebuiltin("XBMC.Container.Update(%s?mode=14,replace)" %sys.argv[0])
            elif 'community-links' in url:
                xbmc.executebuiltin("XBMC.Container.Update(%s?mode=10,replace)" %sys.argv[0])
        else: addon.openSettings()

def rmSource(name):
        sources = json.loads(open(source_file,"r").read())
        for index in range(len(sources)):
            if isinstance(sources[index], list):
                if sources[index][0] == name:
                    del sources[index]
                    b = open(source_file,"w")
                    b.write(json.dumps(sources))
                    b.close()
                    break
            else:
                if sources[index]['title'] == name:
                    del sources[index]
                    b = open(source_file,"w")
                    b.write(json.dumps(sources))
                    b.close()
                    break
        xbmc.executebuiltin("XBMC.Container.Refresh")
		


def get_xml_database(url, browse=False):
        if url is None:
            url = 'http://xbmcplus.xb.funpic.de/www-data/filesystem/'
        soup = BeautifulSoup(makeRequest(url), convertEntities=BeautifulSoup.HTML_ENTITIES)
        for i in soup('a'):
            href = i['href']
            if not href.startswith('?'):
                name = i.string
                if name not in ['Parent Directory', 'recycle_bin/']:
                    if href.endswith('/'):
                        if browse:
                            addDir(name,url+href,15,icon,fanart,'','','')
                        else:
                            addDir(name,url+href,14,icon,fanart,'','','')
                    elif href.endswith('.xml'):
                        if browse:
                            addDir(name,url+href,1,icon,fanart,'','','','','download')
                        else:
                            if os.path.exists(source_file)==True:
                                if name in SOURCES:
                                    addDir(name+' (in use)',url+href,11,icon,fanart,'','','','','download')
                                else:
                                    addDir(name,url+href,11,icon,fanart,'','','','','download')
                            else:
                                addDir(name,url+href,11,icon,fanart,'','','','','download')

def getCommunitySources(browse=False):
        url = 'http://community-links.googlecode.com/svn/trunk/'
        soup = BeautifulSoup(makeRequest(url), convertEntities=BeautifulSoup.HTML_ENTITIES)
        files = soup('ul')[0]('li')[1:]
        for i in files:
            name = i('a')[0]['href']
            if browse:
                addDir(name,url+name,1,icon,fanart,'','','','','download')
            else:
                addDir(name,url+name,11,icon,fanart,'','','','','download')

def getSoup(url,data=None):
        global viewmode,tsdownloader, hlsretry
        tsdownloader=False
        hlsretry=False
        if url.startswith('http://') or url.startswith('https://'):
            enckey=False
            if '$$TSDOWNLOADER$$' in url:
                tsdownloader=True
                url=url.replace("$$TSDOWNLOADER$$","")
            if '$$HLSRETRY$$' in url:
                hlsretry=True
                url=url.replace("$$HLSRETRY$$","")
            if '$$LSProEncKey=' in url:
                enckey=url.split('$$LSProEncKey=')[1].split('$$')[0]
                rp='$$LSProEncKey=%s$$'%enckey
                url=url.replace(rp,"")
                
            data =makeRequest(url)
            if enckey:
                    import pyaes
                    enckey=enckey.encode("ascii")
                    print enckey
                    missingbytes=16-len(enckey)
                    enckey=enckey+(chr(0)*(missingbytes))
                    print repr(enckey)
                    data=base64.b64decode(data)
                    decryptor = pyaes.new(enckey , pyaes.MODE_ECB, IV=None)
                    data=decryptor.decrypt(data).split('\0')[0]
                    #print repr(data)
            if re.search("#EXTM3U",data) or 'm3u' in url:
#                print 'found m3u data'
                return data
        elif data == None:
            if not '/'  in url or not '\\' in url:
#                print 'No directory found. Lets make the url to cache dir'
                url = os.path.join(communityfiles,url)
            if xbmcvfs.exists(url):
                if url.startswith("smb://") or url.startswith("nfs://"):
                    copy = xbmcvfs.copy(url, os.path.join(profile, 'temp', 'sorce_temp.txt'))
                    if copy:
                        data = open(os.path.join(profile, 'temp', 'sorce_temp.txt'), "r").read()
                        xbmcvfs.delete(os.path.join(profile, 'temp', 'sorce_temp.txt'))
                    else:
                        addon_log("failed to copy from smb:")
                else:
                    data = open(url, 'r').read()
                    if re.match("#EXTM3U",data)or 'm3u' in url:
#                        print 'found m3u data'
                        return data
            else:
                addon_log("Soup Data not found!")
                return
        if '<SetViewMode>' in data:
            try:
                viewmode=re.findall('<SetViewMode>(.*?)<',data)[0]
                xbmc.executebuiltin("Container.SetViewMode(%s)"%viewmode)
                print 'done setview',viewmode
            except: pass
        return BeautifulSOAP(data, convertEntities=BeautifulStoneSoup.XML_ENTITIES)

def processPyFunction(data):
    try:
        if data and len(data)>0 and data.startswith('$pyFunction:'):
            data=doEval(data.split('$pyFunction:')[1],'',None,None )
    except: pass

    return data

def getData(url,fanart, data=None):

    soup = getSoup(url,data)
    #print type(soup)
    if isinstance(soup,BeautifulSOAP):
    #print 'xxxxxxxxxxsoup',soup
        if len(soup('channels')) > 0 and addon.getSetting('donotshowbychannels') == 'false':
            channels = soup('channel')
            for channel in channels:
#                print channel

                linkedUrl=''
                lcount=0
                try:
                    linkedUrl =  channel('externallink')[0].string
                    lcount=len(channel('externallink'))
                except: pass
                #print 'linkedUrl',linkedUrl,lcount
                if lcount>1: linkedUrl=''

                name = channel('name')[0].string
                try:
                    name=processPyFunction(name)
                except: pass                
                thumbnail = channel('thumbnail')[0].string
                if thumbnail == None:
                    thumbnail = ''
                thumbnail=processPyFunction(thumbnail)
                try:
                    if not channel('fanart'):
                        if addon.getSetting('use_thumb') == "true":
                            fanArt = thumbnail
                        else:
                            fanArt = fanart
                    else:
                        fanArt = channel('fanart')[0].string
                    if fanArt == None:
                        raise
                except:
                    fanArt = fanart

                try:
                    desc = channel('info')[0].string
                    if desc == None:
                        raise
                except:
                    desc = ''

                try:
                    genre = channel('genre')[0].string
                    if genre == None:
                        raise
                except:
                    genre = ''

                try:
                    date = channel('date')[0].string
                    if date == None:
                        raise
                except:
                    date = ''

                try:
                    credits = channel('credits')[0].string
                    if credits == None:
                        raise
                except:
                    credits = ''

                try:
                    if linkedUrl=='':
                        addDir(name.encode('utf-8', 'ignore'),url.encode('utf-8'),2,thumbnail,fanArt,desc,genre,date,credits,True)
                    else:
                        #print linkedUrl
                        addDir(name.encode('utf-8'),linkedUrl.encode('utf-8'),1,thumbnail,fanArt,desc,genre,date,None,'source')
                except:
                    addon_log('There was a problem adding directory from getData(): '+name.encode('utf-8', 'ignore'))
        else:
            addon_log('No Channels: getItems')
            getItems(soup('item'),fanart)
    else:
        parse_m3u(soup)

# borrow from https://github.com/enen92/P2P-Streams-XBMC/blob/master/plugin.video.p2p-streams/resources/core/livestreams.py
# This will not go through the getItems functions ( means you must have ready to play url, no regex)
def parse_m3u(data):
    content = data.rstrip()
    match = re.compile(r'#EXTINF:(.+?),(.*?)[\n\r]+([^\r\n]+)').findall(content)
    total = len(match)
    print 'tsdownloader',tsdownloader
#    print 'total m3u links',total
    for other,channel_name,stream_url in match:
        
        if 'tvg-logo' in other:
            thumbnail = re_me(other,'tvg-logo=[\'"](.*?)[\'"]')
            if thumbnail:
                if thumbnail.startswith('http'):
                    thumbnail = thumbnail

                elif not addon.getSetting('logo-folderPath') == "":
                    logo_url = addon.getSetting('logo-folderPath')
                    thumbnail = logo_url + thumbnail

                else:
                    thumbnail = thumbnail
            #else:

        else:
            thumbnail = ''
        
        if 'type' in other:
            mode_type = re_me(other,'type=[\'"](.*?)[\'"]')
            if mode_type == 'yt-dl':
                stream_url = stream_url +"&mode=18"
            elif mode_type == 'regex':
                url = stream_url.split('&regexs=')
                #print url[0] getSoup(url,data=None)
                regexs = parse_regex(getSoup('',data=url[1]))

                addLink(url[0], channel_name,thumbnail,'','','','','',None,regexs,total)
                continue
            elif mode_type == 'ftv':
                stream_url = 'plugin://plugin.video.F.T.V/?name='+urllib.quote(channel_name) +'&url=' +stream_url +'&mode=125&ch_fanart=na'
        elif tsdownloader and '.ts' in stream_url:
            stream_url = 'plugin://plugin.video.f4mTester/?url='+urllib.quote_plus(stream_url)+'&amp;streamtype=TSDOWNLOADER&name='+urllib.quote(channel_name)
        elif hlsretry and '.m3u8' in stream_url:
            stream_url = 'plugin://plugin.video.f4mTester/?url='+urllib.quote_plus(stream_url)+'&amp;streamtype=HLSRETRY&name='+urllib.quote(channel_name)
        addLink(stream_url, channel_name,thumbnail,'','','','','',None,'',total)

def getChannelItems(name,url,fanart):
        soup = getSoup(url)
        channel_list = soup.find('channel', attrs={'name' : name.decode('utf-8')})
        items = channel_list('item')
        try:
            fanArt = channel_list('fanart')[0].string
            if fanArt == None:
                raise
        except:
            fanArt = fanart
        for channel in channel_list('subchannel'):
            name = channel('name')[0].string
            try:
                name=processPyFunction(name)
            except: pass
            try:
                thumbnail = channel('thumbnail')[0].string
                if thumbnail == None:
                    raise
                thumbnail=processPyFunction(thumbnail)
            except:
                thumbnail = ''
            try:
                if not channel('fanart'):
                    if addon.getSetting('use_thumb') == "true":
                        fanArt = thumbnail
                else:
                    fanArt = channel('fanart')[0].string
                if fanArt == None:
                    raise
            except:
                pass
            try:
                desc = channel('info')[0].string
                if desc == None:
                    raise
            except:
                desc = ''

            try:
                genre = channel('genre')[0].string
                if genre == None:
                    raise
            except:
                genre = ''

            try:
                date = channel('date')[0].string
                if date == None:
                    raise
            except:
                date = ''

            try:
                credits = channel('credits')[0].string
                if credits == None:
                    raise
            except:
                credits = ''

            try:
                addDir(name.encode('utf-8', 'ignore'),url.encode('utf-8'),3,thumbnail,fanArt,desc,genre,credits,date)
            except:
                addon_log('There was a problem adding directory - '+name.encode('utf-8', 'ignore'))
        getItems(items,fanArt)

def getSubChannelItems(name,url,fanart):
        soup = getSoup(url)
        channel_list = soup.find('subchannel', attrs={'name' : name.decode('utf-8')})
        items = channel_list('subitem')
        getItems(items,fanart)

def getItems(items,fanart,dontLink=False):
        total = len(items)
        addon_log('Total Items: %s' %total)
        add_playlist = addon.getSetting('add_playlist')
        ask_playlist_items =addon.getSetting('ask_playlist_items')
        use_thumb = addon.getSetting('use_thumb')
        parentalblock =addon.getSetting('parentalblocked')
        parentalblock= parentalblock=="true"
        for item in items:
            isXMLSource=False
            isJsonrpc = False
            
            applyblock='false'
            try:
                applyblock = item('parentalblock')[0].string
            except:
                addon_log('parentalblock Error')
                applyblock = ''
            if applyblock=='true' and parentalblock: continue
                
            try:
                name = item('title')[0].string
                if name is None:
                    name = 'unknown?'
                try:
                    name=processPyFunction(name)
                except: pass
                
            except:
                addon_log('Name Error')
                name = ''


            try:
                if item('epg'):
                    if item.epg_url:
                        addon_log('Get EPG Regex')
                        epg_url = item.epg_url.string
                        epg_regex = item.epg_regex.string
                        epg_name = get_epg(epg_url, epg_regex)
                        if epg_name:
                            name += ' - ' + epg_name
                    elif item('epg')[0].string > 1:
                        name += getepg(item('epg')[0].string)
                else:
                    pass
            except:
                addon_log('EPG Error')
            try:
                url = []
                if len(item('link')) >0:
                    #print 'item link', item('link')

                    for i in item('link'):
                        if not i.string == None:
                            url.append(i.string)

                elif len(item('sportsdevil')) >0:
                    for i in item('sportsdevil'):
                        if not i.string == None:
                            sportsdevil = 'plugin://plugin.video.SportsDevil/?mode=1&amp;item=catcher%3dstreams%26url=' +i.string +'%26videoTitle=' +name
                            referer = item('referer')[0].string
                            if referer:
                                #print 'referer found'
                                sportsdevil = sportsdevil + '%26referer=' +referer
                            
                            url.append(sportsdevil)
                elif len(item('p2p')) >0:
                    for i in item('p2p'):
                        if not i.string == None:
                            if 'sop://' in i.string:
                                sop = 'plugin://plugin.video.p2p-streams/?mode=2url='+i.string +'&' + 'name='+name
                                url.append(sop)
                            else:
                                p2p='plugin://plugin.video.p2p-streams/?mode=1&url='+i.string +'&' + 'name='+name
                                url.append(p2p)
                elif len(item('vaughn')) >0:
                    for i in item('vaughn'):
                        if not i.string == None:
                            vaughn = 'plugin://plugin.stream.vaughnlive.tv/?mode=PlayLiveStream&amp;channel='+i.string
                            url.append(vaughn)
                elif len(item('ilive')) >0:
                    for i in item('ilive'):
                        if not i.string == None:
                            if not 'http' in i.string:
                                ilive = 'plugin://plugin.video.tbh.ilive/?url=http://www.streamlive.to/view/'+i.string+'&amp;link=99&amp;mode=iLivePlay'
                            else:
                                ilive = 'plugin://plugin.video.tbh.ilive/?url='+i.string+'&amp;link=99&amp;mode=iLivePlay'
                elif len(item('yt-dl')) >0:
                    for i in item('yt-dl'):
                        if not i.string == None:
                            ytdl = i.string + '&mode=18'
                            url.append(ytdl)
                elif len(item('dm')) >0:
                    for i in item('dm'):
                        if not i.string == None:
                            dm = "plugin://plugin.video.dailymotion_com/?mode=playVideo&url=" + i.string
                            url.append(dm)
                elif len(item('dmlive')) >0:
                    for i in item('dmlive'):
                        if not i.string == None:
                            dm = "plugin://plugin.video.dailymotion_com/?mode=playLiveVideo&url=" + i.string
                            url.append(dm)
                elif len(item('utube')) >0:
                    for i in item('utube'):
                        if not i.string == None:
                            if ' ' in i.string :
                                utube = 'plugin://plugin.video.youtube/search/?q='+ urllib.quote_plus(i.string)
                                isJsonrpc=utube
                            elif len(i.string) == 11:
                                utube = 'plugin://plugin.video.youtube/play/?video_id='+ i.string
                            elif (i.string.startswith('PL') and not '&order=' in i.string) or i.string.startswith('UU'):
                                utube = 'plugin://plugin.video.youtube/play/?&order=default&playlist_id=' + i.string
                            elif i.string.startswith('PL') or i.string.startswith('UU'):
                                utube = 'plugin://plugin.video.youtube/play/?playlist_id=' + i.string
                            elif i.string.startswith('UC') and len(i.string) > 12:
                                utube = 'plugin://plugin.video.youtube/channel/' + i.string + '/'
                                isJsonrpc=utube
                            elif not i.string.startswith('UC') and not (i.string.startswith('PL'))  :
                                utube = 'plugin://plugin.video.youtube/user/' + i.string + '/'
                                isJsonrpc=utube
                        url.append(utube)
                elif len(item('imdb')) >0:
                    for i in item('imdb'):
                        if not i.string == None:
                            if addon.getSetting('genesisorpulsar') == '0':
                                imdb = 'plugin://plugin.video.genesis/?action=play&imdb='+i.string
                            else:
                                imdb = 'plugin://plugin.video.pulsar/movie/tt'+i.string+'/play'
                            url.append(imdb)

                elif len(item('f4m')) >0:
                    for i in item('f4m'):
                        if not i.string == None:
                            if '.f4m' in i.string:
                                f4m = 'plugin://plugin.video.f4mTester/?url='+urllib.quote_plus(i.string)
                            elif '.m3u8' in i.string:
                                f4m = 'plugin://plugin.video.f4mTester/?url='+urllib.quote_plus(i.string)+'&amp;streamtype=HLS'

                            else:
                                f4m = 'plugin://plugin.video.f4mTester/?url='+urllib.quote_plus(i.string)+'&amp;streamtype=SIMPLE'
                        url.append(f4m)       
                
                elif len(item('ftv')) >0:
                    for i in item('ftv'):
                        if not i.string == None:
                            ftv = 'plugin://plugin.video.F.T.V/?name='+urllib.quote(name) +'&url=' +i.string +'&mode=125&ch_fanart=na'
                        url.append(ftv)
                elif len(item('urlsolve')) >0:                    
                    for i in item('urlsolve'):
                        if not i.string == None:
                            resolver = i.string +'&mode=19'
                            url.append(resolver)
                elif len(item('inputstream')) >0:                    
                    for i in item('inputstream'):
                        if not i.string == None:
                            istream = i.string +'&mode=20'
                            url.append(istream)
                elif len(item('slproxy')) >0:
                    for i in item('slproxy'):
                        if not i.string == None:
                            istream = i.string +'&mode=22'
                            url.append(istream)       

                if len(url) < 1:
                    raise

            except:
                addon_log('Error <link> element, Passing:'+name.encode('utf-8', 'ignore'))
                continue
            try:
                isXMLSource = item('externallink')[0].string
            except: pass

            if isXMLSource:
                ext_url=[isXMLSource]
                isXMLSource=True
            else:
                isXMLSource=False
            try:
                isJsonrpc = item('jsonrpc')[0].string
            except: pass
            if isJsonrpc:

                ext_url=[isJsonrpc]
                #print 'JSON-RPC ext_url',ext_url
                isJsonrpc=True
            else:
                isJsonrpc=False
            try:
                thumbnail = item('thumbnail')[0].string
                if thumbnail == None:
                    raise
                thumbnail=processPyFunction(thumbnail)
            except:
                thumbnail = ''
            try:
                if not item('fanart'):
                    if addon.getSetting('use_thumb') == "true":
                        fanArt = thumbnail
                    else:
                        fanArt = fanart
                else:
                    fanArt = item('fanart')[0].string
                if fanArt == None:
                    raise
            except:
                fanArt = fanart
            try:
                desc = item('info')[0].string
                if desc == None:
                    raise
            except:
                desc = ''

            try:
                genre = item('genre')[0].string
                if genre == None:
                    raise
            except:
                genre = ''

            try:
                date = item('date')[0].string
                if date == None:
                    raise
            except:
                date = ''

            regexs = None
            if item('regex'):
                try:
                    reg_item = item('regex')
                    regexs = parse_regex(reg_item)
                except:
                    pass
            try:
                
                if len(url) > 1:
                    alt = 0
                    playlist = []
                    ignorelistsetting=True if '$$LSPlayOnlyOne$$' in url[0] else False
                    
                    for i in url:
                            if  add_playlist == "false" and not ignorelistsetting:
                                alt += 1
                                addLink(i,'%s) %s' %(alt, name.encode('utf-8', 'ignore')),thumbnail,fanArt,desc,genre,date,True,playlist,regexs,total)
                            elif  (add_playlist == "true" and  ask_playlist_items == 'true') or ignorelistsetting:
                                if regexs:
                                    playlist.append(i+'&regexs='+regexs)
                                elif  any(x in i for x in resolve_url) and  i.startswith('http'):
                                    playlist.append(i+'&mode=19')
                                else:
                                    playlist.append(i)
                            else:
                                playlist.append(i)
                    
                    if len(playlist) > 1:                        
                        addLink('', name.encode('utf-8'),thumbnail,fanArt,desc,genre,date,True,playlist,regexs,total)
                else:
                    
                    if dontLink:
                        return name,url[0],regexs
                    if isXMLSource:
                            if not regexs == None: #<externallink> and <regex>
                                addDir(name.encode('utf-8'),ext_url[0].encode('utf-8'),1,thumbnail,fanArt,desc,genre,date,None,'!!update',regexs,url[0].encode('utf-8'))
                                #addLink(url[0],name.encode('utf-8', 'ignore')+  '[COLOR yellow]build XML[/COLOR]',thumbnail,fanArt,desc,genre,date,True,None,regexs,total)
                            else:
                                addDir(name.encode('utf-8'),ext_url[0].encode('utf-8'),1,thumbnail,fanArt,desc,genre,date,None,'source',None,None)
                                #addDir(name.encode('utf-8'),url[0].encode('utf-8'),1,thumbnail,fanart,desc,genre,date,None,'source')
                    elif isJsonrpc:
                        addDir(name.encode('utf-8'),ext_url[0],53,thumbnail,fanArt,desc,genre,date,None,'source')
                        #xbmc.executebuiltin("Container.SetViewMode(500)")
                    else:
                        try:
                            if '$doregex' in name and not getRegexParsed==None:
                                
                                tname,setres=getRegexParsed(regexs, name)
                                
                                if not tname==None:
                                    name=tname
                        except: pass
                        try:
                            if '$doregex' in thumbnail and not getRegexParsed==None:
                                tname,setres=getRegexParsed(regexs, thumbnail)
                                if not tname==None:
                                    thumbnail=tname
                        except: pass
                        addLink(url[0],name.encode('utf-8', 'ignore'),thumbnail,fanArt,desc,genre,date,True,None,regexs,total)
                    #print 'success'
            except:
                addon_log('There was a problem adding item - '+name.encode('utf-8', 'ignore'))

def parse_regex(reg_item):
                try:
                    regexs = {}
                    for i in reg_item:
                        regexs[i('name')[0].string] = {}
                        regexs[i('name')[0].string]['name']=i('name')[0].string
                        #regexs[i('name')[0].string]['expres'] = i('expres')[0].string
                        try:
                            regexs[i('name')[0].string]['expres'] = i('expres')[0].string
                            if not regexs[i('name')[0].string]['expres']:
                                regexs[i('name')[0].string]['expres']=''
                        except:
                            addon_log("Regex: -- No Referer --")
                        regexs[i('name')[0].string]['page'] = i('page')[0].string
                        try:
                            regexs[i('name')[0].string]['referer'] = i('referer')[0].string
                        except:
                            addon_log("Regex: -- No Referer --")
                        try:
                            regexs[i('name')[0].string]['connection'] = i('connection')[0].string
                        except:
                            addon_log("Regex: -- No connection --")

                        try:
                            regexs[i('name')[0].string]['notplayable'] = i('notplayable')[0].string
                        except:
                            addon_log("Regex: -- No notplayable --")

                        try:
                            regexs[i('name')[0].string]['noredirect'] = i('noredirect')[0].string
                        except:
                            addon_log("Regex: -- No noredirect --")
                        try:
                            regexs[i('name')[0].string]['origin'] = i('origin')[0].string
                        except:
                            addon_log("Regex: -- No origin --")
                        try:
                            regexs[i('name')[0].string]['accept'] = i('accept')[0].string
                        except:
                            addon_log("Regex: -- No accept --")
                        try:
                            regexs[i('name')[0].string]['includeheaders'] = i('includeheaders')[0].string
                        except:
                            addon_log("Regex: -- No includeheaders --")

                            
                        try:
                            regexs[i('name')[0].string]['listrepeat'] = i('listrepeat')[0].string
#                            print 'listrepeat',regexs[i('name')[0].string]['listrepeat'],i('listrepeat')[0].string, i
                        except:
                            addon_log("Regex: -- No listrepeat --")
                    
                            

                        try:
                            regexs[i('name')[0].string]['proxy'] = i('proxy')[0].string
                        except:
                            addon_log("Regex: -- No proxy --")
                            
                        try:
                            regexs[i('name')[0].string]['x-req'] = i('x-req')[0].string
                        except:
                            addon_log("Regex: -- No x-req --")

                        try:
                            regexs[i('name')[0].string]['x-addr'] = i('x-addr')[0].string
                        except:
                            addon_log("Regex: -- No x-addr --")                            
                            
                        try:
                            regexs[i('name')[0].string]['x-forward'] = i('x-forward')[0].string
                        except:
                            addon_log("Regex: -- No x-forward --")

                        try:
                            regexs[i('name')[0].string]['agent'] = i('agent')[0].string
                        except:
                            addon_log("Regex: -- No User Agent --")
                        try:
                            regexs[i('name')[0].string]['post'] = i('post')[0].string
                        except:
                            addon_log("Regex: -- Not a post")
                        try:
                            regexs[i('name')[0].string]['rawpost'] = i('rawpost')[0].string
                        except:
                            addon_log("Regex: -- Not a rawpost")
                        try:
                            regexs[i('name')[0].string]['htmlunescape'] = i('htmlunescape')[0].string
                        except:
                            addon_log("Regex: -- Not a htmlunescape")


                        try:
                            regexs[i('name')[0].string]['readcookieonly'] = i('readcookieonly')[0].string
                        except:
                            addon_log("Regex: -- Not a readCookieOnly")
                        #print i
                        try:
                            regexs[i('name')[0].string]['cookiejar'] = i('cookiejar')[0].string
                            if not regexs[i('name')[0].string]['cookiejar']:
                                regexs[i('name')[0].string]['cookiejar']=''
                        except:
                            addon_log("Regex: -- Not a cookieJar")
                        try:
                            regexs[i('name')[0].string]['setcookie'] = i('setcookie')[0].string
                        except:
                            addon_log("Regex: -- Not a setcookie")
                        try:
                            regexs[i('name')[0].string]['appendcookie'] = i('appendcookie')[0].string
                        except:
                            addon_log("Regex: -- Not a appendcookie")

                        try:
                            regexs[i('name')[0].string]['ignorecache'] = i('ignorecache')[0].string
                        except:
                            addon_log("Regex: -- no ignorecache")
                        #try:
                        #    regexs[i('name')[0].string]['ignorecache'] = i('ignorecache')[0].string
                        #except:
                        #    addon_log("Regex: -- no ignorecache")

                    regexs = urllib.quote(repr(regexs))
                    return regexs
                    #print regexs
                except:
                    regexs = None
                    addon_log('regex Error: '+name.encode('utf-8', 'ignore'))
#copies from lamda's implementation
def get_ustream(url):
    try:
        for i in range(1, 51):
            result = getUrl(url)
            if "EXT-X-STREAM-INF" in result: return url
            if not "EXTM3U" in result: return
            xbmc.sleep(2000)
        return
    except:
        return

def getRegexParsed(regexs, url,cookieJar=None,forCookieJarOnly=False,recursiveCall=False,cachedPages={}, rawPost=False, cookie_jar_file=None):#0,1,2 = URL, regexOnly, CookieJarOnly
        if not recursiveCall:
            regexs = eval(urllib.unquote(regexs))
        #cachedPages = {}
        #print 'url',url
        doRegexs = re.compile('\$doregex\[([^\]]*)\]').findall(url)
        #print 'doRegexs',doRegexs,regexs
        setresolved=True
        for k in doRegexs:
            if k in regexs:
                #print 'processing ' ,k
                m = regexs[k]
                #print m
                cookieJarParam=False
                if  'cookiejar' in m: # so either create or reuse existing jar
                    #print 'cookiejar exists',m['cookiejar']
                    cookieJarParam=m['cookiejar']
                    if  '$doregex' in cookieJarParam:
                        cookieJar=getRegexParsed(regexs, m['cookiejar'],cookieJar,True, True,cachedPages)
                        
                        cookieJarParam=True
                    else:
                        cookieJarParam=True
                #print 'm[cookiejar]',m['cookiejar'],cookieJar
                if cookieJarParam:
                    if cookieJar==None:
                        #print 'create cookie jar'
                        cookie_jar_file=None
                        if 'open[' in m['cookiejar']:
                            cookie_jar_file=m['cookiejar'].split('open[')[1].split(']')[0]
#                            print 'cookieJar from file name',cookie_jar_file

                        cookieJar=getCookieJar(cookie_jar_file)
#                        print 'cookieJar from file',cookieJar
                        if cookie_jar_file:
                            saveCookieJar(cookieJar,cookie_jar_file)
                        #import cookielib
                        #cookieJar = cookielib.LWPCookieJar()
                        #print 'cookieJar new',cookieJar
                    elif 'save[' in m['cookiejar']:
                        cookie_jar_file=m['cookiejar'].split('save[')[1].split(']')[0]
                        complete_path=os.path.join(profile,cookie_jar_file)
#                        print 'complete_path',complete_path
                        saveCookieJar(cookieJar,cookie_jar_file)
                if  m['page'] and '$doregex' in m['page']:
                    pg=getRegexParsed(regexs, m['page'],cookieJar,recursiveCall=True,cachedPages=cachedPages)
                    if len(pg)==0:
                        pg='http://regexfailed'
                    m['page']=pg

                if 'setcookie' in m and m['setcookie'] and '$doregex' in m['setcookie']:
                    m['setcookie']=getRegexParsed(regexs, m['setcookie'],cookieJar,recursiveCall=True,cachedPages=cachedPages)
                if 'appendcookie' in m and m['appendcookie'] and '$doregex' in m['appendcookie']:
                    m['appendcookie']=getRegexParsed(regexs, m['appendcookie'],cookieJar,recursiveCall=True,cachedPages=cachedPages)


                if  'post' in m and '$doregex' in m['post']:
                    m['post']=getRegexParsed(regexs, m['post'],cookieJar,recursiveCall=True,cachedPages=cachedPages)
#                    print 'post is now',m['post']

                if  'rawpost' in m and '$doregex' in m['rawpost']:
                    m['rawpost']=getRegexParsed(regexs, m['rawpost'],cookieJar,recursiveCall=True,cachedPages=cachedPages,rawPost=True)
                    #print 'rawpost is now',m['rawpost']

                if 'rawpost' in m and '$epoctime$' in m['rawpost']:
                    m['rawpost']=m['rawpost'].replace('$epoctime$',getEpocTime())

                if 'rawpost' in m and '$epoctime2$' in m['rawpost']:
                    m['rawpost']=m['rawpost'].replace('$epoctime2$',getEpocTime2())


                link=''
                if m['page'] and m['page'] in cachedPages and not 'ignorecache' in m and forCookieJarOnly==False :
                    #print 'using cache page',m['page']
                    link = cachedPages[m['page']]
                else:
                    if m['page'] and  not m['page']=='' and  m['page'].startswith('http'):
                        if '$epoctime$' in m['page']:
                            m['page']=m['page'].replace('$epoctime$',getEpocTime())
                        if '$epoctime2$' in m['page']:
                            m['page']=m['page'].replace('$epoctime2$',getEpocTime2())

                        #print 'Ingoring Cache',m['page']
                        page_split=m['page'].split('|')
                        pageUrl=page_split[0]
                        header_in_page=None
                        if len(page_split)>1:
                            header_in_page=page_split[1]

#                            if 
#                             = urllib2.ProxyHandler({ ('https' ? proxytouse[:5]=="https":"http") : proxytouse})
#                            opener = urllib2.build_opener(proxy)
#                            urllib2.install_opener(opener)

                            
                        
#                        import urllib2
#                        print 'urllib2.getproxies',urllib2.getproxies()
                        current_proxies=urllib2.ProxyHandler(urllib2.getproxies())
        
        
                        print 'getting pageUrl',pageUrl
                        req = urllib2.Request(pageUrl)
                        if 'proxy' in m:
                            proxytouse= m['proxy']
                            #print 'proxytouse',proxytouse
#                            urllib2.getproxies= lambda: {}
                            if pageUrl[:5]=="https":
                                proxy = urllib2.ProxyHandler({ 'https' : proxytouse})
                                #req.set_proxy(proxytouse, 'https')
                            else:
                                proxy = urllib2.ProxyHandler({ 'http'  : proxytouse})
                                #req.set_proxy(proxytouse, 'http')
                            
                            # if re.search(r'https?:\/\/.*?@.*:\d+', proxytouse):
                            #     auth = urllib2.HTTPBasicAuthHandler()
                            #     opener = urllib2.build_opener(proxy, auth, urllib2.HTTPHandler)
                            # else:
                            opener = urllib2.build_opener(proxy)
                            urllib2.install_opener(opener)
                            
                        
                        req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 6.1; rv:14.0) Gecko/20100101 Firefox/14.0.1')
                        proxytouse=None

                        if 'referer' in m:
                            req.add_header('Referer', m['referer'])
                        if 'accept' in m:
                            req.add_header('Accept', m['accept'])
                        if 'agent' in m:
                            req.add_header('User-agent', m['agent'])
                        if 'x-req' in m:
                            req.add_header('X-Requested-With', m['x-req'])
                        if 'x-addr' in m:
                            req.add_header('x-addr', m['x-addr'])
                        if 'x-forward' in m:
                            req.add_header('X-Forwarded-For', m['x-forward'])
                        if 'setcookie' in m:
#                            print 'adding cookie',m['setcookie']
                            req.add_header('Cookie', m['setcookie'])
                        if 'appendcookie' in m:
#                            print 'appending cookie to cookiejar',m['appendcookie']
                            cookiestoApend=m['appendcookie']
                            cookiestoApend=cookiestoApend.split(';')
                            for h in cookiestoApend:
                                n,v=h.split('=')
                                w,n= n.split(':')
                                ck = cookielib.Cookie(version=0, name=n, value=v, port=None, port_specified=False, domain=w, domain_specified=False, domain_initial_dot=False, path='/', path_specified=True, secure=False, expires=None, discard=True, comment=None, comment_url=None, rest={'HttpOnly': None}, rfc2109=False)
                                cookieJar.set_cookie(ck)
                        if 'origin' in m:
                            req.add_header('Origin', m['origin'])
                        if header_in_page:
                            header_in_page=header_in_page.split('&')
                            for h in header_in_page:
                                if h.split('=')==2:
                                    n,v=h.split('=')
                                else:
                                    vals=h.split('=')
                                    n=vals[0]
                                    v='='.join(vals[1:])
                                #n,v=h.split('=')
                                req.add_header(n,v)
                        
                        if not cookieJar==None:
#                            print 'cookieJarVal',cookieJar
                            cookie_handler = urllib2.HTTPCookieProcessor(cookieJar)
                            opener = urllib2.build_opener(cookie_handler, urllib2.HTTPBasicAuthHandler(), urllib2.HTTPHandler())
                            opener = urllib2.install_opener(opener)
#                            print 'noredirect','noredirect' in m
                            
                            if 'noredirect' in m:
                                opener = urllib2.build_opener(cookie_handler,NoRedirection, urllib2.HTTPBasicAuthHandler(), urllib2.HTTPHandler())
                                opener = urllib2.install_opener(opener)
                        elif 'noredirect' in m:
                            opener = urllib2.build_opener(NoRedirection, urllib2.HTTPBasicAuthHandler(), urllib2.HTTPHandler())
                            opener = urllib2.install_opener(opener)
                            

                        if 'connection' in m:
#                            print '..........................connection//////.',m['connection']
                            from keepalive import HTTPHandler
                            keepalive_handler = HTTPHandler()
                            opener = urllib2.build_opener(keepalive_handler)
                            urllib2.install_opener(opener)


                        #print 'after cookie jar'
                        post=None

                        if 'post' in m:
                            postData=m['post']
                            #if '$LiveStreamRecaptcha' in postData:
                            #    (captcha_challenge,catpcha_word,idfield)=processRecaptcha(m['page'],cookieJar)
                            #    if captcha_challenge:
                            #        postData=postData.replace('$LiveStreamRecaptcha','manual_recaptcha_challenge_field:'+captcha_challenge+',recaptcha_response_field:'+catpcha_word+',id:'+idfield)
                            splitpost=postData.split(',')
                            post={}
                            for p in splitpost:
                                n=p.split(':')[0]
                                v=p.split(':')[1]
                                post[n]=v
                            post = urllib.urlencode(post)

                        if 'rawpost' in m:
                            post=m['rawpost']
                            #if '$LiveStreamRecaptcha' in post:
                            #    (captcha_challenge,catpcha_word,idfield)=processRecaptcha(m['page'],cookieJar)
                            #    if captcha_challenge:
                            #       post=post.replace('$LiveStreamRecaptcha','&manual_recaptcha_challenge_field='+captcha_challenge+'&recaptcha_response_field='+catpcha_word+'&id='+idfield)
                        link=''
                        try:
                            
                            if post:
                                response = urllib2.urlopen(req,post)
                            else:
                                response = urllib2.urlopen(req)
                            if response.info().get('Content-Encoding') == 'gzip':
                                from StringIO import StringIO
                                import gzip
                                buf = StringIO( response.read())
                                f = gzip.GzipFile(fileobj=buf)
                                link = f.read()
                            else:
                                link=response.read()
                            
                        
                        
                            if 'proxy' in m and not current_proxies is None:
                                urllib2.install_opener(urllib2.build_opener(current_proxies))
                            
                            link=javascriptUnEscape(link)
                            #print repr(link)
                            #print link This just print whole webpage in LOG
                            if 'includeheaders' in m:
                                #link+=str(response.headers.get('Set-Cookie'))
                                link+='$$HEADERS_START$$:'
                                for b in response.headers:
                                    link+= b+':'+response.headers.get(b)+'\n'
                                link+='$$HEADERS_END$$:'
    #                        print link
                            addon_log(link)
                            addon_log(cookieJar )

                            response.close()
                        except: 
                            pass
                        cachedPages[m['page']] = link
                        #print link
                        #print 'store link for',m['page'],forCookieJarOnly

                        if forCookieJarOnly:
                            return cookieJar# do nothing
                    elif m['page'] and  not m['page'].startswith('http'):
                        if m['page'].startswith('$pyFunction:'):
                            val=doEval(m['page'].split('$pyFunction:')[1],'',cookieJar,m )
                            if forCookieJarOnly:
                                return cookieJar# do nothing
                            link=val
                            link=javascriptUnEscape(link)
                        else:
                            link=m['page']

                if '$pyFunction:playmedia(' in m['expres'] or 'ActivateWindow'  in m['expres'] or 'RunPlugin'  in m['expres']  or '$PLAYERPROXY$=' in url  or  any(x in url for x in g_ignoreSetResolved):
                    setresolved=False
                if  '$doregex' in m['expres']:
                    m['expres']=getRegexParsed(regexs, m['expres'],cookieJar,recursiveCall=True,cachedPages=cachedPages)
                  
                if not m['expres']=='':
                    #print 'doing it ',m['expres']
                    if '$LiveStreamCaptcha' in m['expres']:
                        val=askCaptcha(m,link,cookieJar)
                        #print 'url and val',url,val
                        url = url.replace("$doregex[" + k + "]", val)

                    elif m['expres'].startswith('$pyFunction:') or '#$pyFunction' in m['expres']:
                        #print 'expeeeeeeeeeeeeeeeeeee',m['expres']
                        val=''
                        if m['expres'].startswith('$pyFunction:'):
                            val=doEval(m['expres'].split('$pyFunction:')[1],link,cookieJar,m)
                        else:
                            val=doEvalFunction(m['expres'],link,cookieJar,m)
                        if 'ActivateWindow' in m['expres'] or 'RunPlugin' in m['expres']  : return '',False
                        if forCookieJarOnly:
                            return cookieJar# do nothing
                        if 'listrepeat' in m:
                            listrepeat=m['listrepeat']                            
                            #ret=re.findall(m['expres'],link)
                            #print 'ret',val
                            return listrepeat,eval(val), m,regexs,cookieJar
#                        print 'url k val',url,k,val
                        #print 'repr',repr(val)
                        
                        try:
                            url = url.replace(u"$doregex[" + k + "]", val)
                        except: url = url.replace("$doregex[" + k + "]", val.decode("utf-8"))
                    else:
                        if 'listrepeat' in m:
                            listrepeat=m['listrepeat']
                            #print 'listrepeat',m['expres']
                            #print m['expres']
                            #print 'aaaa'
                            #print link
                            ret=re.findall(m['expres'],link)
                            #print 'ret',ret
                            return listrepeat,ret, m,regexs,cookieJar
                             
                        val=''
                        if not link=='':
                            #print 'link',link
                            reg = re.compile(m['expres']).search(link)                            
                            try:
                                val=reg.group(1).strip()
                            except: traceback.print_exc()
                        elif m['page']=='' or m['page']==None:
                            val=m['expres']
                            
                        if rawPost:
#                            print 'rawpost'
                            val=urllib.quote_plus(val)
                        if 'htmlunescape' in m:
                            #val=urllib.unquote_plus(val)
                            import HTMLParser
                            val=HTMLParser.HTMLParser().unescape(val)
                        try:
                            url = url.replace("$doregex[" + k + "]", val)
                        except: url = url.replace("$doregex[" + k + "]", val.decode("utf-8"))
                        #print 'ur',url
                        #return val
                else:
                    url = url.replace("$doregex[" + k + "]",'')

        if '$epoctime$' in url:
            url=url.replace('$epoctime$',getEpocTime())
        if '$epoctime2$' in url:
            url=url.replace('$epoctime2$',getEpocTime2())

        if '$GUID$' in url:
            import uuid
            url=url.replace('$GUID$',str(uuid.uuid1()).upper())
        if '$get_cookies$' in url:
            url=url.replace('$get_cookies$',getCookiesString(cookieJar))

        if recursiveCall: return url
        #print 'final url',repr(url)
        if url=="":
            return
        else:
            return url,setresolved

def getmd5(t):
    import hashlib
    h=hashlib.md5()
    h.update(t)
    return h.hexdigest()

def decrypt_vaughnlive(encrypted):
    retVal=""
#    print 'enc',encrypted
    #for val in encrypted.split(':'):
    #    retVal+=chr(int(val.replace("0m0","")))
    #return retVal

def playmedia(media_url):
    try:
        import  CustomPlayer
        player = CustomPlayer.MyXBMCPlayer()
        listitem = xbmcgui.ListItem( label = str(name), iconImage = "DefaultVideo.png", thumbnailImage = xbmc.getInfoImage( "ListItem.Thumb" ), path=media_url )
        player.play( media_url,listitem)
        xbmc.sleep(1000)
        while player.is_active:
            xbmc.sleep(200)
    except:
        traceback.print_exc()
    return ''

def kodiJsonRequest(params):
    data = json.dumps(params)
    request = xbmc.executeJSONRPC(data)

    try:
        response = json.loads(request)
    except UnicodeDecodeError:
        response = json.loads(request.decode('utf-8', 'ignore'))

    try:
        if 'result' in response:
            return response['result']
        return None
    except KeyError:
        logger.warn("[%s] %s" % (params['method'], response['error']['message']))
        return None

def setKodiProxy(proxysettings=None):

    if proxysettings==None:
#        print 'proxy set to nothing'
        xbmc.executeJSONRPC('{"jsonrpc":"2.0", "method":"Settings.SetSettingValue", "params":{"setting":"network.usehttpproxy", "value":false}, "id":1}')
    else:
        
        ps=proxysettings.split(':')
        proxyURL=ps[0]
        proxyPort=ps[1]
        proxyType=ps[2]
        proxyUsername=None
        proxyPassword=None
        
        if len(ps)>3 and '@' in ps[3]: #jairox ###proxysettings
            proxyUsername=ps[3].split('@')[0] #jairox ###ps[3]
            proxyPassword=ps[3].split('@')[1] #jairox ###proxysettings.split('@')[-1]

        #print 'proxy set to', proxyType, proxyURL,proxyPort
        xbmc.executeJSONRPC('{"jsonrpc":"2.0", "method":"Settings.SetSettingValue", "params":{"setting":"network.usehttpproxy", "value":true}, "id":1}')
        xbmc.executeJSONRPC('{"jsonrpc":"2.0", "method":"Settings.SetSettingValue", "params":{"setting":"network.httpproxytype", "value":' + str(proxyType) +'}, "id":1}')
        xbmc.executeJSONRPC('{"jsonrpc":"2.0", "method":"Settings.SetSettingValue", "params":{"setting":"network.httpproxyserver", "value":"' + str(proxyURL) +'"}, "id":1}')
        xbmc.executeJSONRPC('{"jsonrpc":"2.0", "method":"Settings.SetSettingValue", "params":{"setting":"network.httpproxyport", "value":' + str(proxyPort) +'}, "id":1}')
        
        
        if not proxyUsername==None:
            xbmc.executeJSONRPC('{"jsonrpc":"2.0", "method":"Settings.SetSettingValue", "params":{"setting":"network.httpproxyusername", "value":"' + str(proxyUsername) +'"}, "id":1}')
            xbmc.executeJSONRPC('{"jsonrpc":"2.0", "method":"Settings.SetSettingValue", "params":{"setting":"network.httpproxypassword", "value":"' + str(proxyPassword) +'"}, "id":1}')
       
def getConfiguredProxy():
    proxyActive = kodiJsonRequest({'jsonrpc': '2.0', "method":"Settings.GetSettingValue", "params":{"setting":"network.usehttpproxy"}, 'id': 1})['value']
#    print 'proxyActive',proxyActive
    proxyType = kodiJsonRequest({'jsonrpc': '2.0', "method":"Settings.GetSettingValue", "params":{"setting":"network.httpproxytype"}, 'id': 1})['value']

    if proxyActive: # PROXY_HTTP
        proxyURL = kodiJsonRequest({'jsonrpc': '2.0', "method":"Settings.GetSettingValue", "params":{"setting":"network.httpproxyserver"}, 'id': 1})['value']
        proxyPort = unicode(kodiJsonRequest({'jsonrpc': '2.0', "method":"Settings.GetSettingValue", "params":{"setting":"network.httpproxyport"}, 'id': 1})['value'])
        proxyUsername = kodiJsonRequest({'jsonrpc': '2.0', "method":"Settings.GetSettingValue", "params":{"setting":"network.httpproxyusername"}, 'id': 1})['value']
        proxyPassword = kodiJsonRequest({'jsonrpc': '2.0', "method":"Settings.GetSettingValue", "params":{"setting":"network.httpproxypassword"}, 'id': 1})['value']

        if proxyUsername and proxyPassword and proxyURL and proxyPort:
            return proxyURL + ':' + str(proxyPort)+':'+str(proxyType) + ':' + proxyUsername + '@' + proxyPassword
        elif proxyURL and proxyPort:
            return proxyURL + ':' + str(proxyPort)+':'+str(proxyType)
    else:
        return None
        
def playmediawithproxy(media_url, name, iconImage,proxyip,port, proxyuser=None, proxypass=None): #jairox

    if media_url==None or media_url=='':
        xbmc.executebuiltin("XBMC.Notification(FireTV,Unable to play empty Url,5000,"+icon+")")
        return
    progress = xbmcgui.DialogProgress()
    progress.create('Progress', 'Playing with custom proxy')
    progress.update( 10, "", "setting proxy..", "" )
    proxyset=False
    existing_proxy=''
    #print 'playmediawithproxy'
    try:
        
        existing_proxy=getConfiguredProxy()
        print 'existing_proxy',existing_proxy
        #read and set here
        #jairox
        if not proxyuser == None:
            setKodiProxy( proxyip + ':' + port + ':0:' + proxyuser + '@' + proxypass)
        else:
            setKodiProxy( proxyip + ':' + port + ':0')

        print 'proxy setting complete playing',media_url
        proxyset=True
        progress.update( 80, "", "setting proxy complete, now playing", "" )
        

        import  CustomPlayer
        player = CustomPlayer.MyXBMCPlayer()
        player.pdialogue==progress
        listitem = xbmcgui.ListItem( label = str(name), iconImage = iconImage, thumbnailImage = xbmc.getInfoImage( "ListItem.Thumb" ), path=media_url )
        player.play( media_url,listitem)
        xbmc.sleep(1000)
        #while player.is_active:
        #    xbmc.sleep(200)
        import time
        beforestart=time.time()
        try:
            while player.is_active:
                xbmc.sleep(1000)       
                if player.urlplayed==False and time.time()-beforestart>12:
                    print 'failed!!!'
                    xbmc.executebuiltin("XBMC.Notification(FireTV,Unable to play check proxy,5000,"+icon+")")
                    break
                #xbmc.sleep(1000)
        except: pass

        progress.close()
        progress=None
    except:
        traceback.print_exc()
    if progress:
        progress.close()
    if proxyset:
        print 'now resetting the proxy back'
        setKodiProxy(existing_proxy)
        print 'reset here'
    return ''

def get_saw_rtmp(page_value, referer=None):
    if referer:
        referer=[('Referer',referer)]
    if page_value.startswith("http"):
        page_url=page_value
        page_value= getUrl(page_value,headers=referer)

    str_pattern="(eval\(function\(p,a,c,k,e,(?:r|d).*)"

    reg_res=re.compile(str_pattern).findall(page_value)
    r=""
    if reg_res and len(reg_res)>0:
        for v in reg_res:
            r1=get_unpacked(v)
            r2=re_me(r1,'\'(.*?)\'')
            if 'unescape' in r1:
                r1=urllib.unquote(r2)
            r+=r1+'\n'
#        print 'final value is ',r

        page_url=re_me(r,'src="(.*?)"')

        page_value= getUrl(page_url,headers=referer)

    #print page_value

    rtmp=re_me(page_value,'streamer\'.*?\'(.*?)\'\)')
    playpath=re_me(page_value,'file\',\s\'(.*?)\'')


    return rtmp+' playpath='+playpath +' pageUrl='+page_url

def get_leton_rtmp(page_value, referer=None):
    if referer:
        referer=[('Referer',referer)]
    if page_value.startswith("http"):
        page_value= getUrl(page_value,headers=referer)
    str_pattern="var a = (.*?);\s*var b = (.*?);\s*var c = (.*?);\s*var d = (.*?);\s*var f = (.*?);\s*var v_part = '(.*?)';"
    reg_res=re.compile(str_pattern).findall(page_value)[0]

    a,b,c,d,f,v=(reg_res)
    f=int(f)
    a=int(a)/f
    b=int(b)/f
    c=int(c)/f
    d=int(d)/f

    ret= 'rtmp://' + str(a) + '.' + str(b) + '.' + str(c) + '.' + str(d) + v
    return ret

def createM3uForDash(url,useragent=None):
    str='#EXTM3U'
    str+='\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=361816'
    str+='\n'+url+'&bytes=0-200000'#+'|User-Agent='+useragent
    source_file = os.path.join(profile, 'testfile.m3u')
    str+='\n'
    SaveToFile(source_file,str)
    #return 'C:/Users/shani/Downloads/test.m3u8'
    return source_file

def SaveToFile(file_name,page_data,append=False):
    if append:
        f = open(file_name, 'a')
        f.write(page_data)
        f.close()
    else:
        f=open(file_name,'wb')
        f.write(page_data)
        f.close()
        return ''

def LoadFile(file_name):
    f=open(file_name,'rb')
    d=f.read()
    f.close()
    return d

def get_packed_iphonetv_url(page_data):
    import re,base64,urllib
    s=page_data
    while 'geh(' in s:
        if s.startswith('lol('): s=s[5:-1]
#       print 's is ',s
        s=re.compile('"(.*?)"').findall(s)[0]
        s=  base64.b64decode(s)
        s=urllib.unquote(s)
    print s
    return s

def get_ferrari_url(page_data):
#    print 'get_dag_url2',page_data
    page_data2=getUrl(page_data)
    patt='(http.*)'
    import uuid
    playback=str(uuid.uuid1()).upper()
    links=re.compile(patt).findall(page_data2)
    headers=[('X-Playback-Session-Id',playback)]
    for l in links:
        try:
                page_datatemp=getUrl(l,headers=headers)

        except: pass

    return page_data+'|&X-Playback-Session-Id='+playback

def get_dag_url(page_data):
#    print 'get_dag_url',page_data
    if page_data.startswith('http://dag.total-stream.net'):
        headers=[('User-Agent','Verismo-BlackUI_(2.4.7.5.8.0.34)')]
        page_data=getUrl(page_data,headers=headers)

    if '127.0.0.1' in page_data:
        return revist_dag(page_data)
    elif re_me(page_data, 'wmsAuthSign%3D([^%&]+)') != '':
        final_url = re_me(page_data, '&ver_t=([^&]+)&') + '?wmsAuthSign=' + re_me(page_data, 'wmsAuthSign%3D([^%&]+)') + '==/mp4:' + re_me(page_data, '\\?y=([^&]+)&')
    else:
        final_url = re_me(page_data, 'href="([^"]+)"[^"]+$')
        if len(final_url)==0:
            final_url=page_data
    final_url = final_url.replace(' ', '%20')
    return final_url

def re_me(data, re_patten):
    match = ''
    m = re.search(re_patten, data)
    if m != None:
        match = m.group(1)
    else:
        match = ''
    return match

def revist_dag(page_data):
    final_url = ''
    if '127.0.0.1' in page_data:
        final_url = re_me(page_data, '&ver_t=([^&]+)&') + ' live=true timeout=15 playpath=' + re_me(page_data, '\\?y=([a-zA-Z0-9-_\\.@]+)')

    if re_me(page_data, 'token=([^&]+)&') != '':
        final_url = final_url + '?token=' + re_me(page_data, 'token=([^&]+)&')
    elif re_me(page_data, 'wmsAuthSign%3D([^%&]+)') != '':
        final_url = re_me(page_data, '&ver_t=([^&]+)&') + '?wmsAuthSign=' + re_me(page_data, 'wmsAuthSign%3D([^%&]+)') + '==/mp4:' + re_me(page_data, '\\?y=([^&]+)&')
    else:
        final_url = re_me(page_data, 'HREF="([^"]+)"')

    if 'dag1.asx' in final_url:
        return get_dag_url(final_url)

    if 'devinlivefs.fplive.net' not in final_url:
        final_url = final_url.replace('devinlive', 'flive')
    if 'permlivefs.fplive.net' not in final_url:
        final_url = final_url.replace('permlive', 'flive')
    return final_url

def get_unwise( str_eval):
    page_value=""
    try:
        ss="w,i,s,e=("+str_eval+')'
        exec (ss)
        page_value=unwise_func(w,i,s,e)
    except: traceback.print_exc(file=sys.stdout)
    #print 'unpacked',page_value
    return page_value

def unwise_func( w, i, s, e):
    lIll = 0
    ll1I = 0
    Il1l = 0
    ll1l = []
    l1lI = []
    while True:
        if (lIll < 5):
            l1lI.append(w[lIll])
        elif (lIll < len(w)):
            ll1l.append(w[lIll])
        lIll+=1
        if (ll1I < 5):
            l1lI.append(i[ll1I])
        elif (ll1I < len(i)):
            ll1l.append(i[ll1I])
        ll1I+=1
        if (Il1l < 5):
            l1lI.append(s[Il1l])
        elif (Il1l < len(s)):
            ll1l.append(s[Il1l])
        Il1l+=1
        if (len(w) + len(i) + len(s) + len(e) == len(ll1l) + len(l1lI) + len(e)):
            break

    lI1l = ''.join(ll1l)#.join('');
    I1lI = ''.join(l1lI)#.join('');
    ll1I = 0
    l1ll = []
    for lIll in range(0,len(ll1l),2):
        #print 'array i',lIll,len(ll1l)
        ll11 = -1
        if ( ord(I1lI[ll1I]) % 2):
            ll11 = 1
        #print 'val is ', lI1l[lIll: lIll+2]
        l1ll.append(chr(    int(lI1l[lIll: lIll+2], 36) - ll11))
        ll1I+=1
        if (ll1I >= len(l1lI)):
            ll1I = 0
    ret=''.join(l1ll)
    if 'eval(function(w,i,s,e)' in ret:
#        print 'STILL GOing'
        ret=re.compile('eval\(function\(w,i,s,e\).*}\((.*?)\)').findall(ret)[0]
        return get_unwise(ret)
    else:
#        print 'FINISHED'
        return ret

def get_unpacked( page_value, regex_for_text='', iterations=1, total_iteration=1):
    try:
        reg_data=None
        if page_value.startswith("http"):
            page_value= getUrl(page_value)
#        print 'page_value',page_value
        if regex_for_text and len(regex_for_text)>0:
            try:
                page_value=re.compile(regex_for_text).findall(page_value)[0] #get the js variable
            except: return 'NOTPACKED'

        page_value=unpack(page_value,iterations,total_iteration)
    except:
        page_value='UNPACKEDFAILED'
        traceback.print_exc(file=sys.stdout)
#    print 'unpacked',page_value
    if 'sav1live.tv' in page_value:
        page_value=page_value.replace('sav1live.tv','sawlive.tv') #quick fix some bug somewhere
#        print 'sav1 unpacked',page_value
    return page_value

def unpack(sJavascript,iteration=1, totaliterations=2  ):
#    print 'iteration',iteration
    if sJavascript.startswith('var _0xcb8a='):
        aSplit=sJavascript.split('var _0xcb8a=')
        ss="myarray="+aSplit[1].split("eval(")[0]
        exec(ss)
        a1=62
        c1=int(aSplit[1].split(",62,")[1].split(',')[0])
        p1=myarray[0]
        k1=myarray[3]
        with open('temp file'+str(iteration)+'.js', "wb") as filewriter:
            filewriter.write(str(k1))
        #aa=1/0
    else:

        if "rn p}('" in sJavascript:
            aSplit = sJavascript.split("rn p}('")
        else:
            aSplit = sJavascript.split("rn A}('")
#        print aSplit

        p1,a1,c1,k1=('','0','0','')

        ss="p1,a1,c1,k1=('"+aSplit[1].split(".spli")[0]+')'
        exec(ss)
    k1=k1.split('|')
    aSplit = aSplit[1].split("))'")
#    print ' p array is ',len(aSplit)
#   print len(aSplit )

    #p=str(aSplit[0]+'))')#.replace("\\","")#.replace('\\\\','\\')

    #print aSplit[1]
    #aSplit = aSplit[1].split(",")
    #print aSplit[0]
    #a = int(aSplit[1])
    #c = int(aSplit[2])
    #k = aSplit[3].split(".")[0].replace("'", '').split('|')
    #a=int(a)
    #c=int(c)

    #p=p.replace('\\', '')
#    print 'p val is ',p[0:100],'............',p[-100:],len(p)
#    print 'p1 val is ',p1[0:100],'............',p1[-100:],len(p1)

    #print a,a1
    #print c,a1
    #print 'k val is ',k[-10:],len(k)
#    print 'k1 val is ',k1[-10:],len(k1)
    e = ''
    d = ''#32823

    #sUnpacked = str(__unpack(p, a, c, k, e, d))
    sUnpacked1 = str(__unpack(p1, a1, c1, k1, e, d,iteration))

    #print sUnpacked[:200]+'....'+sUnpacked[-100:], len(sUnpacked)
#    print sUnpacked1[:200]+'....'+sUnpacked1[-100:], len(sUnpacked1)

    #exec('sUnpacked1="'+sUnpacked1+'"')
    if iteration>=totaliterations:
#        print 'final res',sUnpacked1[:200]+'....'+sUnpacked1[-100:], len(sUnpacked1)
        return sUnpacked1#.replace('\\\\', '\\')
    else:
#        print 'final res for this iteration is',iteration
        return unpack(sUnpacked1,iteration+1)#.replace('\\', ''),iteration)#.replace('\\', '');#unpack(sUnpacked.replace('\\', ''))

def __unpack(p, a, c, k, e, d, iteration,v=1):

    #with open('before file'+str(iteration)+'.js', "wb") as filewriter:
    #    filewriter.write(str(p))
    while (c >= 1):
        c = c -1
        if (k[c]):
            aa=str(__itoaNew(c, a))
            if v==1:
                p=re.sub('\\b' + aa +'\\b', k[c], p)# THIS IS Bloody slow!
            else:
                p=findAndReplaceWord(p,aa,k[c])

            #p=findAndReplaceWord(p,aa,k[c])


    #with open('after file'+str(iteration)+'.js', "wb") as filewriter:
    #    filewriter.write(str(p))
    return p

#
#function equalavent to re.sub('\\b' + aa +'\\b', k[c], p)
def findAndReplaceWord(source_str, word_to_find,replace_with):
    splits=None
    splits=source_str.split(word_to_find)
    if len(splits)>1:
        new_string=[]
        current_index=0
        for current_split in splits:
            #print 'here',i
            new_string.append(current_split)
            val=word_to_find#by default assume it was wrong to split

            #if its first one and item is blank then check next item is valid or not
            if current_index==len(splits)-1:
                val='' # last one nothing to append normally
            else:
                if len(current_split)==0: #if blank check next one with current split value
                    if ( len(splits[current_index+1])==0 and word_to_find[0].lower() not in 'abcdefghijklmnopqrstuvwxyz1234567890_') or (len(splits[current_index+1])>0  and splits[current_index+1][0].lower() not in 'abcdefghijklmnopqrstuvwxyz1234567890_'):# first just just check next
                        val=replace_with
                #not blank, then check current endvalue and next first value
                else:
                    if (splits[current_index][-1].lower() not in 'abcdefghijklmnopqrstuvwxyz1234567890_') and (( len(splits[current_index+1])==0 and word_to_find[0].lower() not in 'abcdefghijklmnopqrstuvwxyz1234567890_') or (len(splits[current_index+1])>0  and splits[current_index+1][0].lower() not in 'abcdefghijklmnopqrstuvwxyz1234567890_')):# first just just check next
                        val=replace_with

            new_string.append(val)
            current_index+=1
        #aaaa=1/0
        source_str=''.join(new_string)
    return source_str

def __itoa(num, radix):
#    print 'num red',num, radix
    result = ""
    if num==0: return '0'
    while num > 0:
        result = "0123456789abcdefghijklmnopqrstuvwxyz"[num % radix] + result
        num /= radix
    return result

def __itoaNew(cc, a):
    aa="" if cc < a else __itoaNew(int(cc / a),a)
    cc = (cc % a)
    bb=chr(cc + 29) if cc> 35 else str(__itoa(cc,36))
    return aa+bb

def getCookiesString(cookieJar):
    try:
        cookieString=""
        for index, cookie in enumerate(cookieJar):
            cookieString+=cookie.name + "=" + cookie.value +";"
    except: pass
    #print 'cookieString',cookieString
    return cookieString

def saveCookieJar(cookieJar,COOKIEFILE):
    try:
        complete_path=os.path.join(profile,COOKIEFILE)
        cookieJar.save(complete_path,ignore_discard=True)
    except: pass

def getCookieJar(COOKIEFILE):

    cookieJar=None
    if COOKIEFILE:
        try:
            complete_path=os.path.join(profile,COOKIEFILE)
            cookieJar = cookielib.LWPCookieJar()
            cookieJar.load(complete_path,ignore_discard=True)
        except:
            cookieJar=None

    if not cookieJar:
        cookieJar = cookielib.LWPCookieJar()

    return cookieJar

def doEval(fun_call,page_data,Cookie_Jar,m):
    ret_val=''
    #print fun_call
    if functions_dir not in sys.path:
        sys.path.append(functions_dir)

    if not os.path.exists(functions_dir):
        os.makedirs(functions_dir)
 

    try:
        py_file='import '+fun_call.split('.')[0]
#        print py_file,sys.path
        exec( py_file)
#        print 'done'
    except:
        print 'doEval: error in import'
        #traceback.print_exc(file=sys.stdout)
#    print 'ret_val='+fun_call
    exec ('ret_val='+fun_call)
#   print ret_val
    #exec('ret_val=1+1')
    try:
        return str(ret_val)
    except: return ret_val

def doEvalFunction(fun_call,page_data,Cookie_Jar,m):
#    print 'doEvalFunction'
    try:
        global gLSProDynamicCodeNumber
        gLSProDynamicCodeNumber=gLSProDynamicCodeNumber+1
        ret_val=''
        print 'doooodoo'
        if functions_dir not in sys.path:
            sys.path.append(functions_dir)
            
        if not os.path.exists(functions_dir):
            os.makedirs(functions_dir)

        filename='LSProdynamicCode%s.py'%str(gLSProDynamicCodeNumber)
        filenamewithpath=os.path.join(functions_dir,filename)
        f=open(filenamewithpath,"wb")
        f.write("# -*- coding: utf-8 -*-\n")
        f.write(fun_call.encode("utf-8"))
        f.close()
        print 'before do'
        LSProdynamicCode = import_by_string(filename.split('.')[0],filenamewithpath)
        print 'after'
         
        ret_val=LSProdynamicCode.GetLSProData(page_data,Cookie_Jar,m)
        try:
            return str(ret_val)
        except: return ret_val
    except: traceback.print_exc()
    return ""

def import_by_string(full_name,filenamewithpath):
    try:
        
        import importlib
        return importlib.import_module(full_name, package=None)
    except:
        import imp
        return imp.load_source(full_name,filenamewithpath)

def getGoogleRecaptchaResponse(captchakey, cj,type=1): #1 for get, 2 for post, 3 for rawpost
#    #headers=[('User-Agent','Mozilla/5.0 (Windows NT 6.1; rv:14.0) Gecko/20100101 Firefox/14.0.1')]
#    html_text=getUrl(url,noredir=True, cookieJar=cj,headers=headers)
 #   print 'html_text',html_text
    recapChallenge=""
    solution=""
#    cap_reg="recap.*?\?k=(.*?)\""    
#    match =re.findall(cap_reg, html_text)
    
        
#    print 'match',match
    captcha=False
    captcha_reload_response_chall=None
    solution=None
    if len(captchakey)>0: #new shiny captcha!
        captcha_url=captchakey
        if not captcha_url.startswith('http'):
            captcha_url='http://www.google.com/recaptcha/api/challenge?k='+captcha_url+'&ajax=1'
#        print 'captcha_url',captcha_url
        captcha=True

        cap_chall_reg='challenge.*?\'(.*?)\''
        cap_image_reg='\'(.*?)\''
        captcha_script=getUrl(captcha_url,cookieJar=cj)
        recapChallenge=re.findall(cap_chall_reg, captcha_script)[0]
        captcha_reload='http://www.google.com/recaptcha/api/reload?c='
        captcha_k=captcha_url.split('k=')[1]
        captcha_reload+=recapChallenge+'&k='+captcha_k+'&reason=i&type=image&lang=en'
        captcha_reload_js=getUrl(captcha_reload,cookieJar=cj)
        captcha_reload_response_chall=re.findall(cap_image_reg, captcha_reload_js)[0]
        captcha_image_url='http://www.google.com/recaptcha/api/image?c='+captcha_reload_response_chall
        if not captcha_image_url.startswith("http"):
            captcha_image_url='http://www.google.com/recaptcha/api/'+captcha_image_url
        import random
        n=random.randrange(100,1000,5)
        local_captcha = os.path.join(profile,str(n) +"captcha.img" )
        localFile = open(local_captcha, "wb")
        localFile.write(getUrl(captcha_image_url,cookieJar=cj))
        localFile.close()
        solver = InputWindow(captcha=local_captcha)
        solution = solver.get()
        os.remove(local_captcha)

    if captcha_reload_response_chall:
        if type==1:
            return 'recaptcha_challenge_field='+urllib.quote_plus(captcha_reload_response_chall)+'&recaptcha_response_field='+urllib.quote_plus(solution)
        elif type==2:
            return 'recaptcha_challenge_field:'+captcha_reload_response_chall+',recaptcha_response_field:'+solution
        else:
            return 'recaptcha_challenge_field='+urllib.quote_plus(captcha_reload_response_chall)+'&recaptcha_response_field='+urllib.quote_plus(solution)
    else:
        return ''

def getUrl(url, cookieJar=None,post=None, timeout=20, headers=None, noredir=False):


    cookie_handler = urllib2.HTTPCookieProcessor(cookieJar)

    if noredir:
        opener = urllib2.build_opener(NoRedirection,cookie_handler, urllib2.HTTPBasicAuthHandler(), urllib2.HTTPHandler())
    else:
        opener = urllib2.build_opener(cookie_handler, urllib2.HTTPBasicAuthHandler(), urllib2.HTTPHandler())
    #opener = urllib2.install_opener(opener)
    req = urllib2.Request(url)
    req.add_header('User-Agent','Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.154 Safari/537.36')
    if headers:
        for h,hv in headers:
            req.add_header(h,hv)

    response = opener.open(req,post,timeout=timeout)
    link=response.read()
    response.close()
    return link

def get_decode(str,reg=None):
    if reg:
        str=re.findall(reg, str)[0]
    s1 = urllib.unquote(str[0: len(str)-1])
    t = ''
    for i in range( len(s1)):
        t += chr(ord(s1[i]) - s1[len(s1)-1])
    t=urllib.unquote(t)
#    print t
    return t

def javascriptUnEscape(str):
    js=re.findall('unescape\(\'(.*?)\'',str)
#    print 'js',js
    if (not js==None) and len(js)>0:
        for j in js:
            #print urllib.unquote(j)
            str=str.replace(j ,urllib.unquote(j))
    return str

iid=0
def askCaptcha(m,html_page, cookieJar):
    global iid
    iid+=1
    expre= m['expres']
    page_url = m['page']
    captcha_regex=re.compile('\$LiveStreamCaptcha\[([^\]]*)\]').findall(expre)[0]

    captcha_url=re.compile(captcha_regex).findall(html_page)[0]
#    print expre,captcha_regex,captcha_url
    if not captcha_url.startswith("http"):
        page_='http://'+"".join(page_url.split('/')[2:3])
        if captcha_url.startswith("/"):
            captcha_url=page_+captcha_url
        else:
            captcha_url=page_+'/'+captcha_url

    local_captcha = os.path.join(profile, str(iid)+"captcha.jpg" )
    localFile = open(local_captcha, "wb")
#    print ' c capurl',captcha_url
    req = urllib2.Request(captcha_url)
    req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 6.1; rv:14.0) Gecko/20100101 Firefox/14.0.1')
    if 'referer' in m:
        req.add_header('Referer', m['referer'])
    if 'agent' in m:
        req.add_header('User-agent', m['agent'])
    if 'setcookie' in m:
#        print 'adding cookie',m['setcookie']
        req.add_header('Cookie', m['setcookie'])

    #cookie_handler = urllib2.HTTPCookieProcessor(cookieJar)
    #opener = urllib2.build_opener(cookie_handler, urllib2.HTTPBasicAuthHandler(), urllib2.HTTPHandler())
    #opener = urllib2.install_opener(opener)
    urllib2.urlopen(req)
    response = urllib2.urlopen(req)

    localFile.write(response.read())
    response.close()
    localFile.close()
    solver = InputWindow(captcha=local_captcha)
    solution = solver.get()
    return solution

def askCaptchaNew(imageregex,html_page,cookieJar,m):
    global iid
    iid+=1


    if not imageregex=='':
        if html_page.startswith("http"):
            page_=getUrl(html_page,cookieJar=cookieJar)
        else:
            page_=html_page
        captcha_url=re.compile(imageregex).findall(html_page)[0]
    else:
        captcha_url=html_page
        if 'oneplay.tv/embed' in html_page:
            import oneplay
            page_=getUrl(html_page,cookieJar=cookieJar)
            captcha_url=oneplay.getCaptchaUrl(page_)

    local_captcha = os.path.join(profile, str(iid)+"captcha.jpg" )
    localFile = open(local_captcha, "wb")
#    print ' c capurl',captcha_url
    req = urllib2.Request(captcha_url)
    req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 6.1; rv:14.0) Gecko/20100101 Firefox/14.0.1')
    if 'referer' in m:
        req.add_header('Referer', m['referer'])
    if 'agent' in m:
        req.add_header('User-agent', m['agent'])
    if 'accept' in m:
        req.add_header('Accept', m['accept'])
    if 'setcookie' in m:
#        print 'adding cookie',m['setcookie']
        req.add_header('Cookie', m['setcookie'])

    #cookie_handler = urllib2.HTTPCookieProcessor(cookieJar)
    #opener = urllib2.build_opener(cookie_handler, urllib2.HTTPBasicAuthHandler(), urllib2.HTTPHandler())
    #opener = urllib2.install_opener(opener)
    #urllib2.urlopen(req)
    response = urllib2.urlopen(req)

    localFile.write(response.read())
    response.close()
    localFile.close()
    solver = InputWindow(captcha=local_captcha)
    solution = solver.get()
    return solution

#########################################################
# Function  : GUIEditExportName                         #
#########################################################
# Parameter :                                           #
#                                                       #
# name        sugested name for export                  #
#                                                       # 
# Returns   :                                           #
#                                                       #
# name        name of export excluding any extension    #
#                                                       #
#########################################################
def TakeInput(name, headname):


    kb = xbmc.Keyboard('default', 'heading', True)
    kb.setDefault(name)
    kb.setHeading(headname)
    kb.setHiddenInput(False)
    return kb.getText()
   
#########################################################
class InputWindow(xbmcgui.WindowDialog):
    def __init__(self, *args, **kwargs):
        self.cptloc = kwargs.get('captcha')
        self.img = xbmcgui.ControlImage(335,30,624,60,self.cptloc)
        self.addControl(self.img)
        self.kbd = xbmc.Keyboard()

    def get(self):
        self.show()
        time.sleep(2)
        self.kbd.doModal()
        if (self.kbd.isConfirmed()):
            text = self.kbd.getText()
            self.close()
            return text
        self.close()
        return False

def getEpocTime():
    import time
    return str(int(time.time()*1000))

def getEpocTime2():
    import time
    return str(int(time.time()))

def get_params():
        param=[]
        paramstring=sys.argv[2]
        if len(paramstring)>=2:
            params=sys.argv[2]
            cleanedparams=params.replace('?','')
            if (params[len(params)-1]=='/'):
                params=params[0:len(params)-2]
            pairsofparams=cleanedparams.split('&')
            param={}
            for i in range(len(pairsofparams)):
                splitparams={}
                splitparams=pairsofparams[i].split('=')
                if (len(splitparams))==2:
                    param[splitparams[0]]=splitparams[1]
        return param

def getFavorites():
        items = json.loads(open(favorites).read())
        total = len(items)
        for i in items:
            name = i[0]
            url = i[1]
            iconimage = i[2]
            try:
                fanArt = i[3]
                if fanArt == None:
                    raise
            except:
                if addon.getSetting('use_thumb') == "true":
                    fanArt = iconimage
                else:
                    fanArt = fanart
            try: playlist = i[5]
            except: playlist = None
            try: regexs = i[6]
            except: regexs = None

            if i[4] == 0:
                addLink(url,name,iconimage,fanArt,'','','','fav',playlist,regexs,total)
            else:
                addDir(name,url,i[4],iconimage,fanart,'','','','','fav')

def addFavorite(name,url,iconimage,fanart,mode,playlist=None,regexs=None):
        favList = []
        try:
            # seems that after
            name = name.encode('utf-8', 'ignore')
        except:
            pass
        if os.path.exists(favorites)==False:
            addon_log('Making Favorites File')
            favList.append((name,url,iconimage,fanart,mode,playlist,regexs))
            a = open(favorites, "w")
            a.write(json.dumps(favList))
            a.close()
        else:
            addon_log('Appending Favorites')
            a = open(favorites).read()
            data = json.loads(a)
            data.append((name,url,iconimage,fanart,mode))
            b = open(favorites, "w")
            b.write(json.dumps(data))
            b.close()

def rmFavorite(name):
        data = json.loads(open(favorites).read())
        for index in range(len(data)):
            if data[index][0]==name:
                del data[index]
                b = open(favorites, "w")
                b.write(json.dumps(data))
                b.close()
                break
        xbmc.executebuiltin("XBMC.Container.Refresh")

def urlsolver(url):
    import resolveurl
    host = resolveurl.HostedMediaFile(url)
    if host:
        resolver = resolveurl.resolve(url)
        resolved = resolver
        if isinstance(resolved,list):
            for k in resolved:
                quality = addon.getSetting('quality')
                if k['quality'] == 'HD'  :
                    resolver = k['url']
                    break
                elif k['quality'] == 'SD' :
                    resolver = k['url']
                elif k['quality'] == '1080p' and addon.getSetting('1080pquality') == 'true' :
                    resolver = k['url']
                    break
        else:
            resolver = resolved
    else:
        xbmc.executebuiltin("XBMC.Notification(FireTV,resolveurl donot support this domain. - ,5000)")
        resolver=url
    return resolver

def tryplay(url,listitem,pdialogue=None):    

    if url.lower().startswith('plugin') and 'youtube' not in  url.lower():
        print 'playing via runplugin'
        xbmc.executebuiltin('XBMC.RunPlugin('+url+')') 
        for i in range(8):
            xbmc.sleep(500) ##sleep for 10 seconds, half each time
            try:
                #print 'condi'
                if xbmc.getCondVisibility("Player.HasMedia") and xbmc.Player().isPlaying():
                    return True
            except: pass
        print 'returning now'
        return False
    import  CustomPlayer,time

    player = CustomPlayer.MyXBMCPlayer()
    player.pdialogue=pdialogue
    start = time.time() 
    #xbmc.Player().play( liveLink,listitem)
    print 'going to play'
    import time
    beforestart=time.time()
    player.play( url, listitem)
    xbmc.sleep(1000)
    
    try:
        while player.is_active:
            xbmc.sleep(400)
           
            if player.urlplayed:
                print 'yes played'
                return True
            if time.time()-beforestart>4: return False
            #xbmc.sleep(1000)
    except: pass
    print 'not played',url
    return False

def play_playlist(name, mu_playlist,queueVideo=None):
        playlist = xbmc.PlayList(xbmc.PLAYLIST_VIDEO)
        #print 'mu_playlist',mu_playlist
        if '$$LSPlayOnlyOne$$' in mu_playlist[0]:
            mu_playlist[0]=mu_playlist[0].replace('$$LSPlayOnlyOne$$','')
            import urlparse
            names = []
            iloop=0
            progress = xbmcgui.DialogProgress()
            progress.create('Progress', 'Trying Multiple Links')
            for i in mu_playlist:
                

                if '$$lsname=' in i:
                    d_name=i.split('$$lsname=')[1].split('&regexs')[0]
                    names.append(d_name)                                       
                    mu_playlist[iloop]=i.split('$$lsname=')[0]+('&regexs'+i.split('&regexs')[1] if '&regexs' in i else '')                    
                else:
                    d_name=urlparse.urlparse(i).netloc
                    if d_name == '':
                        names.append(name)
                    else:
                        names.append(d_name)
                index=iloop
                iloop+=1
                
                playname=names[index]
                if progress.iscanceled(): return 
                progress.update( iloop/len(mu_playlist)*100,"", "Link#%d"%(iloop),playname  )
                print 'auto playnamexx',playname
                if "&mode=19" in mu_playlist[index]:
                        #playsetresolved (urlsolver(mu_playlist[index].replace('&mode=19','')),name,iconimage,True)
                    liz = xbmcgui.ListItem(playname, iconImage=iconimage, thumbnailImage=iconimage)
                    liz.setInfo(type='Video', infoLabels={'Title':playname,'mediatype':'video'})
                    liz.setProperty("IsPlayable","true")
                    urltoplay=urlsolver(mu_playlist[index].replace('&mode=19','').replace(';',''))
                    liz.setPath(urltoplay)
                    #xbmc.Player().play(urltoplay,liz)
                    played=tryplay(urltoplay,liz)
                elif "$doregex" in mu_playlist[index] :
#                    print mu_playlist[index]
                    sepate = mu_playlist[index].split('&regexs=')
#                    print sepate
                    url,setresolved = getRegexParsed(sepate[1], sepate[0])
                    url2 = url.replace(';','')
                    liz = xbmcgui.ListItem(playname, iconImage=iconimage, thumbnailImage=iconimage)
                    liz.setInfo(type='Video', infoLabels={'Title':playname,'mediatype':'video'})
                    liz.setProperty("IsPlayable","true")
                    liz.setPath(url2)
                    #xbmc.Player().play(url2,liz)
                    played=tryplay(url2,liz)

                else:
                    url = mu_playlist[index]
                    url=url.split('&regexs=')[0]
                    liz = xbmcgui.ListItem(playname, iconImage=iconimage, thumbnailImage=iconimage)
                    liz.setInfo(type='Video', infoLabels={'Title':playname,'mediatype':'video'})
                    liz.setProperty("IsPlayable","true")
                    liz.setPath(url)
                    #xbmc.Player().play(url,liz)
                    played=tryplay(url,liz)
                    print 'played',played
                print 'played',played
                if played: return
            return     
        if addon.getSetting('ask_playlist_items') == 'true' and not queueVideo :
            import urlparse
            names = []
            iloop=0
            for i in mu_playlist:
                if '$$lsname=' in i:
                    d_name=i.split('$$lsname=')[1].split('&regexs')[0]
                    names.append(d_name)                                       
                    mu_playlist[iloop]=i.split('$$lsname=')[0]+('&regexs'+i.split('&regexs')[1] if '&regexs' in i else '')                    
                else:
                    d_name=urlparse.urlparse(i).netloc
                    if d_name == '':
                        names.append(name)
                    else:
                        names.append(d_name)
                    
                iloop+=1
            dialog = xbmcgui.Dialog()
            index = dialog.select('Choose a video source', names)
            if index >= 0:
                playname=names[index]
                print 'playnamexx',playname
                if "&mode=19" in mu_playlist[index]:
                        #playsetresolved (urlsolver(mu_playlist[index].replace('&mode=19','')),name,iconimage,True)
                    liz = xbmcgui.ListItem(playname, iconImage=iconimage, thumbnailImage=iconimage)
                    liz.setInfo(type='Video', infoLabels={'Title':playname,'mediatype':'video'})
                    liz.setProperty("IsPlayable","true")
                    urltoplay=urlsolver(mu_playlist[index].replace('&mode=19','').replace(';',''))
                    liz.setPath(urltoplay)
                    xbmc.Player().play(urltoplay,liz)
                elif "$doregex" in mu_playlist[index] :
#                    print mu_playlist[index]
                    sepate = mu_playlist[index].split('&regexs=')
#                    print sepate
                    url,setresolved = getRegexParsed(sepate[1], sepate[0])
                    url2 = url.replace(';','')
                    liz = xbmcgui.ListItem(playname, iconImage=iconimage, thumbnailImage=iconimage)
                    liz.setInfo(type='Video', infoLabels={'Title':playname,'mediatype':'video'})
                    liz.setProperty("IsPlayable","true")
                    liz.setPath(url2)
                    xbmc.Player().play(url2,liz)

                else:
                    url = mu_playlist[index]
                    url=url.split('&regexs=')[0]
                    liz = xbmcgui.ListItem(playname, iconImage=iconimage, thumbnailImage=iconimage)
                    liz.setInfo(type='Video', infoLabels={'Title':playname,'mediatype':'video'})
                    liz.setProperty("IsPlayable","true")
                    liz.setPath(url)
                    xbmc.Player().play(url,liz)
        elif not queueVideo:
            #playlist = xbmc.PlayList(1) # 1 means video
            playlist.clear()
            item = 0
            for i in mu_playlist:
                item += 1
                info = xbmcgui.ListItem('%s) %s' %(str(item),name))
                # Don't do this as regex parsed might take longer
                try:
                    if "$doregex" in i:
                        sepate = i.split('&regexs=')
#                        print sepate
                        url,setresolved = getRegexParsed(sepate[1], sepate[0])
                    elif "&mode=19" in i:
                        url = urlsolver(i.replace('&mode=19','').replace(';',''))                        
                    if url:
                        playlist.add(url, info)
                    else:
                        raise
                except Exception:
                    playlist.add(i, info)
                    pass #xbmc.Player().play(url)

            xbmc.executebuiltin('playlist.playoffset(video,0)')
        else:

                listitem = xbmcgui.ListItem(name)
                playlist.add(mu_playlist, listitem)

def download_file(name, url):
        
        if addon.getSetting('save_location') == "":
            xbmc.executebuiltin("XBMC.Notification('FireTV','Choose a location to save files.',15000,"+icon+")")
            addon.openSettings()
        params = {'url': url, 'download_path': addon.getSetting('save_location')}
        downloader.download(name, params)
        dialog = xbmcgui.Dialog()
        ret = dialog.yesno('FireTV', 'Do you want to add this file as a source?')
        if ret:
            addSource(os.path.join(addon.getSetting('save_location'), name))

def _search(url,name):
   # print url,name
    pluginsearchurls = ['plugin://plugin.video.genesis/?action=shows_search',\
             'plugin://plugin.video.genesis/?action=movies_search',\
             'plugin://plugin.video.salts/?mode=search&amp;section=Movies',\
             'plugin://plugin.video.salts/?mode=search&amp;section=TV',\
             'plugin://plugin.video.muchmovies.hd/?action=movies_search',\
             'plugin://plugin.video.viooz.co/?action=root_search',\
             'plugin://plugin.video.ororotv/?action=shows_search',\
             'plugin://plugin.video.yifymovies.hd/?action=movies_search',\
             'plugin://plugin.video.cartoonhdtwo/?description&amp;fanart&amp;iconimage&amp;mode=3&amp;name=Search&amp;url=url',\
             'plugin://plugin.video.youtube/kodion/search/list/',\
             'plugin://plugin.video.dailymotion_com/?mode=search&amp;url',\
             'plugin://plugin.video.vimeo/kodion/search/list/'\
             ]
    names = ['Gensis TV','Genesis Movie','Salt movie','salt TV','Muchmovies','viooz','ORoroTV',\
             'Yifymovies','cartoonHD','Youtube','DailyMotion','Vimeo']
    dialog = xbmcgui.Dialog()
    index = dialog.select('Choose a video source', names)

    if index >= 0:
        url = pluginsearchurls[index]
#        print 'url',url
        pluginquerybyJSON(url)

def addDir(name,url,mode,iconimage,fanart,description,genre,date,credits,showcontext=False,regexs=None,reg_url=None,allinfo={}):

        #print 'addDir'

        if regexs and len(regexs)>0:
            u=sys.argv[0]+"?url="+urllib.quote_plus(url)+"&mode="+str(mode)+"&name="+urllib.quote_plus(name)+"&fanart="+urllib.quote_plus(fanart)+"&regexs="+regexs
        else:
            u=sys.argv[0]+"?url="+urllib.quote_plus(url)+"&mode="+str(mode)+"&name="+urllib.quote_plus(name)+"&fanart="+urllib.quote_plus(fanart)
        
        ok=True
        if date == '':
            date = None
        else:
            description += '\n\nDate: %s' %date
        liz=xbmcgui.ListItem(name, iconImage="DefaultFolder.png", thumbnailImage=iconimage)
        if len(allinfo) <1 :
            liz.setInfo(type="Video", infoLabels={ "Title": name, 'mediatype':'video', "Plot": description, "Genre": genre, "dateadded": date, "credits": credits })
        else:
            allinfo.update({'mediatype':'video'})
            liz.setInfo(type="Video", infoLabels= allinfo)
        liz.setProperty("Fanart_Image", fanart)
        if showcontext:
            contextMenu = []
            parentalblock =addon.getSetting('parentalblocked')
            parentalblock= parentalblock=="true"
            parentalblockedpin =addon.getSetting('parentalblockedpin')
#            print 'parentalblockedpin',parentalblockedpin
            if len(parentalblockedpin)>0:
                if parentalblock:
                    contextMenu.append(('Disable Parental Block','XBMC.RunPlugin(%s?mode=55&name=%s)' %(sys.argv[0], urllib.quote_plus(name))))
                else:
                    contextMenu.append(('Enable Parental Block','XBMC.RunPlugin(%s?mode=56&name=%s)' %(sys.argv[0], urllib.quote_plus(name))))
                    
            if showcontext == 'source':
            
                if name in str(SOURCES):
                    contextMenu.append(('Remove from Sources','XBMC.RunPlugin(%s?mode=8&name=%s)' %(sys.argv[0], urllib.quote_plus(name))))
                    
                    
            elif showcontext == 'download':
                contextMenu.append(('Download','XBMC.RunPlugin(%s?url=%s&mode=9&name=%s)'
                                    %(sys.argv[0], urllib.quote_plus(url), urllib.quote_plus(name))))
            elif showcontext == 'fav':
                contextMenu.append(('Remove from FireTV Favorites','XBMC.RunPlugin(%s?mode=6&name=%s)'
                                    %(sys.argv[0], urllib.quote_plus(name))))
            if showcontext == '!!update':
                fav_params2 = (
                    '%s?url=%s&mode=17&regexs=%s'
                    %(sys.argv[0], urllib.quote_plus(reg_url), regexs)
                    )
                contextMenu.append(('[COLOR yellow]!!update[/COLOR]','XBMC.RunPlugin(%s)' %fav_params2))
            if not name in FAV:
                contextMenu.append(('Add to FireTV Favorites','XBMC.RunPlugin(%s?mode=5&name=%s&url=%s&iconimage=%s&fanart=%s&fav_mode=%s)'
                         %(sys.argv[0], urllib.quote_plus(name), urllib.quote_plus(url), urllib.quote_plus(iconimage), urllib.quote_plus(fanart), mode)))
            liz.addContextMenuItems(contextMenu)
        ok=xbmcplugin.addDirectoryItem(handle=int(sys.argv[1]),url=u,listitem=liz,isFolder=True)
        return ok

def ytdl_download(url,title,media_type='video'):
    # play in xbmc while playing go back to contextMenu(c) to "!!Download!!"
    # Trial yasceen: seperate |User-Agent=
    import youtubedl
    
    if not url == '':
        if media_type== 'audio':
            youtubedl.single_YD(url,download=True,audio=True)
        else:
            youtubedl.single_YD(url,download=True)
    elif xbmc.Player().isPlaying() == True :
        import YDStreamExtractor
        if YDStreamExtractor.isDownloading() == True:

            YDStreamExtractor.manageDownloads()
        else:
            xbmc_url = xbmc.Player().getPlayingFile()

            xbmc_url = xbmc_url.split('|User-Agent=')[0]
            info = {'url':xbmc_url,'title':title,'media_type':media_type}
            youtubedl.single_YD('',download=True,dl_info=info)
    else:
        xbmc.executebuiltin("XBMC.Notification(DOWNLOAD,First Play [COLOR yellow]WHILE playing download[/COLOR] ,10000)")

## Lunatixz PseudoTV feature
def ascii(string):
    if isinstance(string, basestring):
        if isinstance(string, unicode):
           string = string.encode('ascii', 'ignore')
    return string

def uni(string, encoding = 'utf-8'):
    if isinstance(string, basestring):
        if not isinstance(string, unicode):
            string = unicode(string, encoding, 'ignore')
    return string

def removeNonAscii(s): return "".join(filter(lambda x: ord(x)<128, s))

def sendJSON( command):
    data = ''
    try:
        data = xbmc.executeJSONRPC(uni(command))
    except UnicodeEncodeError:
        data = xbmc.executeJSONRPC(ascii(command))

    return uni(data)

def pluginquerybyJSON(url,give_me_result=None,playlist=False):
    if 'audio' in url:
        json_query = uni('{"jsonrpc":"2.0","method":"Files.GetDirectory","params": {"directory":"%s","media":"video", "properties": ["title", "album", "artist", "duration","thumbnail", "year"]}, "id": 1}') %url
    else:
        json_query = uni('{"jsonrpc":"2.0","method":"Files.GetDirectory","params":{"directory":"%s","media":"video","properties":[ "plot","playcount","director", "genre","votes","duration","trailer","premiered","thumbnail","title","year","dateadded","fanart","rating","season","episode","studio","mpaa"]},"id":1}') %url
    json_folder_detail = json.loads(sendJSON(json_query))
    #print json_folder_detail
    if give_me_result:
        return json_folder_detail
    if json_folder_detail.has_key('error'):
        return
    else:

        for i in json_folder_detail['result']['files'] :
            meta ={}
            url = i['file']
            name = removeNonAscii(i['label'])
            thumbnail = removeNonAscii(i['thumbnail'])
            fanart = removeNonAscii(i['fanart'])
            meta = dict((k,v) for k, v in i.iteritems() if not v == '0' or not v == -1 or v == '')
            meta.pop("file", None)
            if i['filetype'] == 'file':
                if playlist:
                    play_playlist(name,url,queueVideo='1')
                    continue
                else:
                    addLink(url,name,thumbnail,fanart,'','','','',None,'',total=len(json_folder_detail['result']['files']),allinfo=meta)
                    #xbmc.executebuiltin("Container.SetViewMode(500)")
                    if i['type'] and i['type'] == 'tvshow' :
                        xbmcplugin.setContent(int(sys.argv[1]), 'tvshows')
                    elif i['episode'] > 0 :
                        xbmcplugin.setContent(int(sys.argv[1]), 'episodes')

            else:
                addDir(name,url,53,thumbnail,fanart,'','','','',allinfo=meta)
        xbmcplugin.endOfDirectory(int(sys.argv[1]))

def addLink(url,name,iconimage,fanart,description,genre,date,showcontext,playlist,regexs,total,setCookie="",allinfo={}):
        #print 'url,name,regex',url,name,iconimage,regexs
        contextMenu =[]
        parentalblock =addon.getSetting('parentalblocked')
        parentalblock= parentalblock=="true"
        parentalblockedpin =addon.getSetting('parentalblockedpin')
#        print 'parentalblockedpin',parentalblockedpin
        if len(parentalblockedpin)>0:
            if parentalblock:
                contextMenu.append(('Disable Parental Block','XBMC.RunPlugin(%s?mode=55&name=%s)' %(sys.argv[0], urllib.quote_plus(name))))
            else:
                contextMenu.append(('Enable Parental Block','XBMC.RunPlugin(%s?mode=56&name=%s)' %(sys.argv[0], urllib.quote_plus(name))))
                    
        try:
            name = name.encode('utf-8')
        except: pass
        ok = True
        isFolder=False
        if regexs:
            mode = '17'
            if 'listrepeat' in regexs:
                isFolder=True
#               print 'setting as folder in link'
            contextMenu.append(('[COLOR white]!!Download Currently Playing!![/COLOR]','XBMC.RunPlugin(%s?url=%s&mode=21&name=%s)'
                                    %(sys.argv[0], urllib.quote_plus(url), urllib.quote_plus(name))))
        elif  (any(x in url for x in resolve_url) and  url.startswith('http')) or url.endswith('&mode=19'):
            url=url.replace('&mode=19','')
            mode = '19'
            contextMenu.append(('[COLOR white]!!Download Currently Playing!![/COLOR]','XBMC.RunPlugin(%s?url=%s&mode=21&name=%s)'
                                    %(sys.argv[0], urllib.quote_plus(url), urllib.quote_plus(name))))
        elif url.endswith('&mode=18'):
            url=url.replace('&mode=18','')
            mode = '18'
            contextMenu.append(('[COLOR white]!!Download!![/COLOR]','XBMC.RunPlugin(%s?url=%s&mode=23&name=%s)'
                                    %(sys.argv[0], urllib.quote_plus(url), urllib.quote_plus(name))))
            if addon.getSetting('dlaudioonly') == 'true':
                contextMenu.append(('!!Download [COLOR seablue]Audio!![/COLOR]','XBMC.RunPlugin(%s?url=%s&mode=24&name=%s)'
                                        %(sys.argv[0], urllib.quote_plus(url), urllib.quote_plus(name))))
        elif url.endswith('&mode=20'):
            url=url.replace('&mode=20','')
            mode = '20'
        elif url.endswith('&mode=22'):
            url=url.replace('&mode=22','')
            mode = '22'
        elif url.startswith('magnet:?xt='):
            if '&' in url and not '&amp;' in url :
                url = url.replace('&','&amp;')
            url = 'plugin://plugin.video.pulsar/play?uri=' + url
            mode = '12'
        else:
            mode = '12'
            contextMenu.append(('[COLOR white]!!Download Currently Playing!![/COLOR]','XBMC.RunPlugin(%s?url=%s&mode=21&name=%s)'
                                    %(sys.argv[0], urllib.quote_plus(url), urllib.quote_plus(name))))
        if 'plugin://plugin.video.youtube/play/?video_id=' in url:
              yt_audio_url = url.replace('plugin://plugin.video.youtube/play/?video_id=','https://www.youtube.com/watch?v=')
              contextMenu.append(('!!Download [COLOR blue]Audio!![/COLOR]','XBMC.RunPlugin(%s?url=%s&mode=24&name=%s)'
                                      %(sys.argv[0], urllib.quote_plus(yt_audio_url), urllib.quote_plus(name))))
        u=sys.argv[0]+"?"
        play_list = False
        
        if playlist:
            if addon.getSetting('add_playlist') == "false" and '$$LSPlayOnlyOne$$' not in playlist[0] :
                u += "url="+urllib.quote_plus(url)+"&mode="+mode
            else:
                u += "mode=13&name=%s&playlist=%s" %(urllib.quote_plus(name), urllib.quote_plus(str(playlist).replace(',','||')))
                name = name + '[COLOR magenta] (' + str(len(playlist)) + ' items )[/COLOR]'
                play_list = True
        elif mode=='22' or (mode=='17' and url.endswith('&mode=22')):             
            u += "url="+urllib.quote_plus(url)+"&name="+urllib.quote(name)+"&mode="+mode
        else:
            u += "url="+urllib.quote_plus(url)+"&mode="+mode
        if regexs:
            u += "&regexs="+regexs
        if not setCookie == '':
            u += "&setCookie="+urllib.quote_plus(setCookie)
        if iconimage and  not iconimage == '':
            u += "&iconimage="+urllib.quote_plus(iconimage)
            
        if date == '':
            date = None
        else:
            description += '\n\nDate: %s' %date
        liz=xbmcgui.ListItem(name, iconImage="DefaultVideo.png", thumbnailImage=iconimage)

        #if isFolder:
        if allinfo==None or len(allinfo) <1:
            liz.setInfo(type="Video", infoLabels={ "Title": name, 'mediatype':'video', "Plot": description, "Genre": genre, "dateadded": date })
        else:
            allinfo.update({'mediatype':'video'})
            liz.setInfo(type="Video", infoLabels=allinfo)
        liz.setProperty("Fanart_Image", fanart)

        if '$$RESOLVEONLY$$' in url:
            liz.setProperty('IsPlayable', 'true')
 
        if (not play_list) and not any(x in url for x in g_ignoreSetResolved) and not '$PLAYERPROXY$=' in url and not (mode=='22' or (mode=='17' and url.endswith('&mode=22'))):#  (not url.startswith('plugin://plugin.video.f4mTester')):
            if regexs:
                #print urllib.unquote_plus(regexs)
                if '$pyFunction:playmedia(' not in urllib.unquote_plus(regexs) and 'notplayable' not in urllib.unquote_plus(regexs) and 'listrepeat' not in  urllib.unquote_plus(regexs) :
                    #print 'setting isplayable',url, urllib.unquote_plus(regexs),url
                    liz.setProperty('IsPlayable', 'true')
            else:
                liz.setProperty('IsPlayable', 'true')
                
        else:
            addon_log('NOT setting isplayable'+url)
        
        if showcontext:
            #contextMenu = []
            if showcontext == 'fav':
                contextMenu.append(
                    ('Remove from FireTV Favorites','XBMC.RunPlugin(%s?mode=6&name=%s)'
                     %(sys.argv[0], urllib.quote_plus(name)))
                     )
            elif not name in FAV:
                try:
                    fav_params = (
                        '%s?mode=5&name=%s&url=%s&iconimage=%s&fanart=%s&fav_mode=0'
                        %(sys.argv[0], urllib.quote_plus(name), urllib.quote_plus(url), urllib.quote_plus(iconimage), urllib.quote_plus(fanart))
                        )
                except:
                    fav_params = (
                        '%s?mode=5&name=%s&url=%s&iconimage=%s&fanart=%s&fav_mode=0'
                        %(sys.argv[0], urllib.quote_plus(name), urllib.quote_plus(url), urllib.quote_plus(iconimage.encode("utf-8")), urllib.quote_plus(fanart.encode("utf-8")))
                        )
                if playlist:
                    fav_params += 'playlist='+urllib.quote_plus(str(playlist).replace(',','||'))
                if regexs:
                    fav_params += "&regexs="+regexs
                contextMenu.append(('Add to FireTV Favorites','XBMC.RunPlugin(%s)' %fav_params))
            liz.addContextMenuItems(contextMenu)
        try:
            if not playlist is None:
                if addon.getSetting('add_playlist') == "false":
                    playlist_name = name.split(') ')[1]
                    contextMenu_ = [
                        ('Play '+playlist_name+' PlayList','XBMC.RunPlugin(%s?mode=13&name=%s&playlist=%s)'
                         %(sys.argv[0], urllib.quote_plus(playlist_name), urllib.quote_plus(str(playlist).replace(',','||'))))
                         ]
                    liz.addContextMenuItems(contextMenu_)
        except: pass
        #print 'adding',name
        
        ok=xbmcplugin.addDirectoryItem(handle=int(sys.argv[1]),url=u,listitem=liz,totalItems=total,isFolder=isFolder)

        #print 'added',name
        return ok

def playsetresolved(url,name,iconimage,setresolved=True,reg=None):
    #print 'playsetresolved',url,name,setresolved
    print 'playsetresolved'
    if url==None: 
        xbmcplugin.endOfDirectory(int(sys.argv[1]))
        return

    if '&mode=22' in url:
        setresolved=False
        url=url.replace('&mode=22','')
        u=sys.argv[0]+"?"
        u += "url="+urllib.quote_plus(url)+"&name="+urllib.quote(name)+"&mode=22"
        url = u

    if setresolved:
        setres=True
        if '$$LSDirect$$' in url:
            url=url.replace('$$LSDirect$$','')
            setres=False
        if reg and 'notplayable' in reg:
            setres=False

        liz = xbmcgui.ListItem(name, iconImage=iconimage, thumbnailImage=iconimage)
        liz.setInfo(type='Video', infoLabels={'Title':name,'mediatype':'video'})
        liz.setProperty("IsPlayable","true")
        if '&mode=19' in url:
            url=urlsolver(url.replace('&mode=19','').replace(';',''))
        elif '&mode=20' in url:
            url=url.replace('&mode=20','')
            if '|' in url:
                url,strhdr = url.split('|')
                liz.setProperty('inputstream.adaptive.stream_headers', strhdr)
				
            if '.m3u8' in url:
                liz.setProperty('inputstreamaddon', 'inputstream.adaptive')
                liz.setProperty('inputstream.adaptive.manifest_type', 'hls')
                liz.setMimeType('application/vnd.apple.mpegstream_url')
                liz.setContentLookup(False)

            
            elif '.mpd' in url:
                liz.setProperty('inputstreamaddon', 'inputstream.adaptive')
                liz.setProperty('inputstream.adaptive.manifest_type', 'mpd')
                liz.setMimeType('application/dash+xml')
                liz.setContentLookup(False)
            
            elif '.ism' in url:
                liz.setProperty('inputstreamaddon', 'inputstream.adaptive')
                liz.setProperty('inputstream.adaptive.manifest_type', 'ism')
                liz.setMimeType('application/vnd.ms-sstr+xml')
                liz.setContentLookup(False)
        
        # elif '&mode=22' in url:
        #     print "slproxy"
        #     url=url.replace('&mode=22','')
        #     try:
        #         from dsp import streamlink_proxy
        #         slProxy = streamlink_proxy.SLProxy_Helper()
        #         try:
        #             q =  re.findall(r'\$\$QUALITY=([^\$\$]+)\$\$', url)[0]
        #         except:
        #             q = 'best'
        #         url = re.sub(r'\$\$QUALITY=.*?\$\$', '', url)
        #         url = urllib.quote(url)+'&amp;q=%s'%q
        #         liz.setPath(url)
        #         liz.setProperty("IsPlayable","false")
        #         slProxy.playSLink(url, liz)
        #         return
        #    except:
        #        pass

        liz.setPath(url)
        if not setres:
            xbmc.Player().play(url)
        else:
            xbmcplugin.setResolvedUrl(int(sys.argv[1]), True, liz)
           
    else:
        xbmc.executebuiltin('XBMC.RunPlugin('+url+')')

## Thanks to daschacka, an epg scraper for http://i.teleboy.ch/programm/station_select.php
##  http://forum.xbmc.org/post.php?p=936228&postcount=1076
def getepg(link):
        url=urllib.urlopen(link)
        source=url.read()
        url.close()
        source2 = source.split("Jetzt")
        source3 = source2[1].split('programm/detail.php?const_id=')
        sourceuhrzeit = source3[1].split('<br /><a href="/')
        nowtime = sourceuhrzeit[0][40:len(sourceuhrzeit[0])]
        sourcetitle = source3[2].split("</a></p></div>")
        nowtitle = sourcetitle[0][17:len(sourcetitle[0])]
        nowtitle = nowtitle.encode('utf-8')
        return "  - "+nowtitle+" - "+nowtime

def get_epg(url, regex):
        data = makeRequest(url)
        try:
            item = re.findall(regex, data)[0]
            return item
        except:
            addon_log('regex failed')
            addon_log(regex)
            return
			
def make_request(url):
##ESTA FUNCION lee las url declaradas donde estan los videos. ||
	try:
		req = urllib2.Request(url)
		req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0')
		response = urllib2.urlopen(req)	  
		link = response.read()
		response.close()  
		return link
	except urllib2.URLError, e:
		print 'We failed to open "%s".' % url
		if hasattr(e, 'code'):
			print 'We failed with error code - %s.' % e.code	
		if hasattr(e, 'reason'):
			print 'We failed to reach a server.'
			print 'Reason: ', e.reason
			
def OPEN_URL(url):
        req = urllib2.Request(url)
        req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.85 Safari/537.36')
        req.add_header('Referer', '%s'%url)
        req.add_header('Connection', 'keep-alive')
        response = urllib2.urlopen(req)
        link=response.read()
        response.close()
        return link

##not a generic implemenation as it needs to convert            
def d2x(d, root="root",nested=0):

    op = lambda tag: '<' + tag + '>'
    cl = lambda tag: '</' + tag + '>\n'

    ml = lambda v,xml: xml + op(key) + str(v) + cl(key)
    xml = op(root) + '\n' if root else ""

    for key,vl in d.iteritems():
        vtype = type(vl)
        if nested==0: key='regex' #enforcing all top level tags to be named as regex
        if vtype is list: 
            for v in vl:
                v=escape(v)
                xml = ml(v,xml)         
        
        if vtype is dict: 
            xml = ml('\n' + d2x(vl,None,nested+1),xml)         
        if vtype is not list and vtype is not dict: 
            if not vl is None: vl=escape(vl)
            #print repr(vl)
            if vl is None:
                xml = ml(vl,xml)
            else:
                #xml = ml(escape(vl.encode("utf-8")),xml)
                xml = ml(vl.encode("utf-8"),xml)

    xml += cl(root) if root else ""

    return xml

xbmcplugin.setContent(int(sys.argv[1]), 'movies')

try:
    xbmcplugin.addSortMethod(int(sys.argv[1]), xbmcplugin.SORT_METHOD_UNSORTED)
except:
    pass
try:
    xbmcplugin.addSortMethod(int(sys.argv[1]), xbmcplugin.SORT_METHOD_LABEL)
except:
    pass
try:
    xbmcplugin.addSortMethod(int(sys.argv[1]), xbmcplugin.SORT_METHOD_DATE)
except:
    pass
try:
    xbmcplugin.addSortMethod(int(sys.argv[1]), xbmcplugin.SORT_METHOD_GENRE)
except:
    pass

params=get_params()
#print 'params ', repr(params)

url=None
name=None
mode=None
playlist=None
iconimage=None
fanart=FANART
playlist=None
fav_mode=None
regexs=None

try:
    url=urllib.unquote_plus(params["url"]).decode('utf-8')
except:
    pass
try:
    name=urllib.unquote_plus(params["name"])
except:
    pass
try:
    iconimage=urllib.unquote_plus(params["iconimage"])
except:
    pass
try:
    fanart=urllib.unquote_plus(params["fanart"])
except:
    pass
try:
    mode=int(params["mode"])
except:
    pass
try:
    playlist=eval(urllib.unquote_plus(params["playlist"]).replace('||',','))
except:
    pass
try:
    fav_mode=int(params["fav_mode"])
except:
    pass
try:
    regexs=params["regexs"]
except:
    pass
playitem=''
try:
    playitem=urllib.unquote_plus(params["playitem"])
except:
    pass
   
addon_log("Mode: "+str(mode))



if not url is None:
    addon_log("URL: "+str(url.encode('utf-8')))
addon_log("Name: "+str(name))

if not playitem =='':
    s=getSoup('',data=playitem)
    name,url,regexs=getItems(s,None,dontLink=True)
    mode=117

if mode==None:
    
	addon_log("getSources")
	addon_log("cargando mensaje remoto de bienvenida ... ")
	
    getSources()
	mensaje()
	
    xbmcplugin.endOfDirectory(int(sys.argv[1]))


elif mode==1:
    addon_log("getData")
    data=None
    
    if regexs and len(regexs)>0:
        data,setresolved=getRegexParsed(regexs, url)
        #print data
        #url=''
        if data.startswith('http') or data.startswith('smb') or data.startswith('nfs') or data.startswith('/'):
            url=data
            data=None
        #create xml here
    
    getData(url,fanart,data)
    xbmcplugin.endOfDirectory(int(sys.argv[1]))

elif mode==2:
    addon_log("getChannelItems")
    getChannelItems(name,url,fanart)
    xbmcplugin.endOfDirectory(int(sys.argv[1]))

elif mode==3:
    addon_log("getSubChannelItems")
    getSubChannelItems(name,url,fanart)
    xbmcplugin.endOfDirectory(int(sys.argv[1]))

elif mode==4:
    addon_log("getFavorites")
    getFavorites()
    xbmcplugin.endOfDirectory(int(sys.argv[1]))

elif mode==5:
    addon_log("addFavorite")
    try:
        name = name.split('\\ ')[1]
    except:
        pass
    try:
        name = name.split('  - ')[0]
    except:
        pass
    addFavorite(name,url,iconimage,fanart,fav_mode)

elif mode==6:
    addon_log("rmFavorite")
    try:
        name = name.split('\\ ')[1]
    except:
        pass
    try:
        name = name.split('  - ')[0]
    except:
        pass
    rmFavorite(name)

elif mode==7:
    addon_log("addSource")
    addSource(url)

elif mode==8:
    addon_log("rmSource")
    rmSource(name)

elif mode==9:
    addon_log("download_file")
    download_file(name, url)

elif mode==10:
    addon_log("getCommunitySources")
    getCommunitySources()

elif mode==11:
    addon_log("addSource")
    addSource(url)

elif mode==12:
    addon_log("setResolvedUrl")
    if not url.startswith("plugin://plugin") or not any(x in url for x in g_ignoreSetResolved):#not url.startswith("plugin://plugin.video.f4mTester") :
        setres=True
        if '$$LSDirect$$' in url:
            url=url.replace('$$LSDirect$$','')
            setres=False
        if '$PLAYERPROXY$=' in url:
            url,proxy=url.split('$PLAYERPROXY$=')
            print 'proxy',proxy
            #Jairox mod for proxy auth
            proxyuser = None
            proxypass = None
            if len(proxy) > 0 and '@' in proxy:
                proxy = proxy.split(':')
                proxyuser = proxy[0]
                proxypass = proxy[1].split('@')[0]
                proxyip = proxy[1].split('@')[1]
                port = proxy[2]
            else:
                proxyip,port=proxy.split(':')
            playmediawithproxy(url,name,iconimage,proxyip,port, proxyuser,proxypass) #jairox
            
        item = xbmcgui.ListItem(path=url)        
        if not setres:
            xbmc.Player().play(url)
        else: 
            xbmcplugin.setResolvedUrl(int(sys.argv[1]), True, item)
    else:
#        print 'Not setting setResolvedUrl'
        xbmc.executebuiltin('XBMC.RunPlugin('+url+')')

elif mode==13:
    addon_log("play_playlist")
    play_playlist(name, playlist)

elif mode==14:
    addon_log("get_xml_database")
    get_xml_database(url)
    xbmcplugin.endOfDirectory(int(sys.argv[1]))

elif mode==15:
    addon_log("browse_xml_database")
    get_xml_database(url, True)
    xbmcplugin.endOfDirectory(int(sys.argv[1]))

elif mode==16:
    addon_log("browse_community")
    getCommunitySources(url,browse=True)
    xbmcplugin.endOfDirectory(int(sys.argv[1]))

elif mode==17 or mode==117:
    addon_log("getRegexParsed")
    #print 'getRegexParsed'
    data=None
    if regexs and 'listrepeat' in urllib.unquote_plus(regexs):
        listrepeat,ret,m,regexs, cookieJar =getRegexParsed(regexs, url)
        #print listrepeat,ret,m,regexs
        d=''
#        print 'm is' , m
#        print 'regexs',regexs
        regexname=m['name']
        existing_list=regexs.pop(regexname)
 #       print 'final regexs',regexs,regexname
        url=''
        import copy
        ln=''
        rnumber=0
        for obj in ret:
            #print 'obj',obj
            try:
                rnumber+=1
                newcopy=copy.deepcopy(regexs)
    #            print 'newcopy',newcopy, len(newcopy)
                listrepeatT=listrepeat
                i=0
                for i in range(len(obj)):
    #                print 'i is ',i, len(obj), len(newcopy)
                    if len(newcopy)>0:
                        for the_keyO, the_valueO in newcopy.iteritems():
                            if the_valueO is not None:
                                for the_key, the_value in the_valueO.iteritems():
                                    if the_value is not None:                                
        #                                print  'key and val',the_key, the_value
        #                                print 'aa'
        #                                print '[' + regexname+'.param'+str(i+1) + ']'
        #                                print repr(obj[i])
                                        if type(the_value) is dict:
                                            for the_keyl, the_valuel in the_value.iteritems():
                                                if the_valuel is not None:
                                                    val=None
                                                    if isinstance(obj,tuple):                                                    
                                                        try:
                                                           val= obj[i].decode('utf-8') 
                                                        except: 
                                                            val= obj[i] 
                                                    else:
                                                        try:
                                                            val= obj.decode('utf-8') 
                                                        except:
                                                            val= obj
                                                    
                                                    if '[' + regexname+'.param'+str(i+1) + '][DE]' in the_valuel:
                                                        the_valuel=the_valuel.replace('[' + regexname+'.param'+str(i+1) + '][DE]', unescape(val))
                                                    the_value[the_keyl]=the_valuel.replace('[' + regexname+'.param'+str(i+1) + ']', val)
                                                    #print 'first sec',the_value[the_keyl]
                                                    
                                        else:
                                            val=None
                                            if isinstance(obj,tuple):
                                                try:
                                                     val=obj[i].decode('utf-8') 
                                                except:
                                                    val=obj[i] 
                                            else:
                                                try:
                                                    val= obj.decode('utf-8') 
                                                except:
                                                    val= obj
                                            if '[' + regexname+'.param'+str(i+1) + '][DE]' in the_value:
                                                #print 'found DE',the_value.replace('[' + regexname+'.param'+str(i+1) + '][DE]', unescape(val))
                                                the_value=the_value.replace('[' + regexname+'.param'+str(i+1) + '][DE]', unescape(val))

                                            the_valueO[the_key]=the_value.replace('[' + regexname+'.param'+str(i+1) + ']', val)
                                            #print 'second sec val',the_valueO[the_key]

                    val=None
                    if isinstance(obj,tuple):
                        try:
                            val=obj[i].decode('utf-8')
                        except:
                            val=obj[i]
                    else:
                        try:
                            val=obj.decode('utf-8')
                        except: 
                            val=obj
                    if '[' + regexname+'.param'+str(i+1) + '][DE]' in listrepeatT:
                        listrepeatT=listrepeatT.replace('[' + regexname+'.param'+str(i+1) + '][DE]',val)
                    listrepeatT=listrepeatT.replace('[' + regexname+'.param'+str(i+1) + ']',escape(val))
#                    print listrepeatT
                listrepeatT=listrepeatT.replace('[' + regexname+'.param'+str(0) + ']',str(rnumber)) 
                
                try:
                    if cookieJar and '[' + regexname+'.cookies]' in listrepeatT:
                        listrepeatT=listrepeatT.replace('[' + regexname+'.cookies]',getCookiesString(cookieJar)) 
                except: pass
                
                #newcopy = urllib.quote(repr(newcopy))
    #            print 'new regex list', repr(newcopy), repr(listrepeatT)
    #            addLink(listlinkT,listtitleT.encode('utf-8', 'ignore'),listthumbnailT,'','','','',True,None,newcopy, len(ret))
                regex_xml=''
#                print 'newcopy',newcopy
                if len(newcopy)>0:
                    regex_xml=d2x(newcopy,'lsproroot')
                    regex_xml=regex_xml.split('<lsproroot>')[1].split('</lsproroot')[0]
              
                #ln+='\n<item>%s\n%s</item>'%(listrepeatT.encode("utf-8"),regex_xml)   
                try:
                    ln+='\n<item>%s\n%s</item>'%(listrepeatT,regex_xml)
                except: ln+='\n<item>%s\n%s</item>'%(listrepeatT.encode("utf-8"),regex_xml)
            except: traceback.print_exc(file=sys.stdout)
#            print repr(ln)
#            print newcopy
                
#            ln+='</item>'
        
        addon_log(repr(ln))
        getData('','',ln)
        xbmcplugin.endOfDirectory(int(sys.argv[1]))
    else:
        url,setresolved = getRegexParsed(regexs, url)
        #print 'imhere', repr(url),setresolved,name
        #print 'imhere'
        if not (regexs and 'notplayable' in regexs and not url):        
            if url:
                if '$PLAYERPROXY$=' in url:
                    url,proxy=url.split('$PLAYERPROXY$=')
                    print 'proxy',proxy
                    #Jairox mod for proxy auth
                    proxyuser = None
                    proxypass = None
                    if len(proxy) > 0 and '@' in proxy:
                        proxy = proxy.split(':')
                        proxyuser = proxy[0]
                        proxypass = proxy[1].split('@')[0]
                        proxyip = proxy[1].split('@')[1]
                        port = proxy[2]
                    else:
                        proxyip,port=proxy.split(':')

                    playmediawithproxy(url,name,iconimage,proxyip,port, proxyuser,proxypass) #jairox
                else:
                    playsetresolved(url,name,iconimage,setresolved,regexs)
            else:
                xbmc.executebuiltin("XBMC.Notification(FireTV,Failed to extract regex. - "+"this"+",4000,"+icon+")")

elif mode==18:
    addon_log("youtubedl")
    try:
        import youtubedl
    except Exception:
        xbmc.executebuiltin("XBMC.Notification(FireTV,Please [COLOR yellow]install Youtube-dl[/COLOR] module ,10000,"")")
    stream_url=youtubedl.single_YD(url)
    playsetresolved(stream_url,name,iconimage)

elif mode==19:
    addon_log("Genesiscommonresolvers")
    playsetresolved (urlsolver(url),name,iconimage,True)

elif mode==20:
    addon_log("setResolvedUrl")
    item = xbmcgui.ListItem(path=url)
    if '|' in url:
        url,strhdr = url.split('|')
        item.setProperty('inputstream.adaptive.stream_headers', strhdr)
        item.setPath(url)
    if '.m3u8' in url:
        item.setProperty('inputstreamaddon', 'inputstream.adaptive')
        item.setProperty('inputstream.adaptive.manifest_type', 'hls')
        item.setMimeType('application/vnd.apple.mpegstream_url')
        item.setContentLookup(False)
   
    elif '.mpd' in url:
        item.setProperty('inputstreamaddon', 'inputstream.adaptive')
        item.setProperty('inputstream.adaptive.manifest_type', 'mpd')
        item.setMimeType('application/dash+xml')
        item.setContentLookup(False)
    
    elif '.ism' in url:
        item.setProperty('inputstreamaddon', 'inputstream.adaptive')
        item.setProperty('inputstream.adaptive.manifest_type', 'ism')
        item.setMimeType('application/vnd.ms-sstr+xml')
        item.setContentLookup(False)

    xbmcplugin.setResolvedUrl(int(sys.argv[1]), True, item)

elif mode==21:
    addon_log("download current file using youtube-dl service")
    mtype='video'
    if '[mp3]' in name:
        mtype='audio'
        name=name.replace('[mp3]','')
    ytdl_download('',name, mtype)

elif mode==22:
    print "slproxy"
    try:
        from dsp import streamlink_proxy
        try:
            q =  re.findall(r'\$\$QUALITY=([^\$\$]+)\$\$', url)[0]
        except:
            q = '' if re.search(r'\$\$RESOLVEONLY\$\$', url) else 'best'
        url = re.sub(r'\$\$QUALITY=.*?\$\$', '', url)
        
        try:
            prxy =  re.findall(r'\$\$HTTPPROXY=([^\$\$]+)\$\$', url)[0]
        except:
            prxy = ''
        url = re.sub(r'\$\$HTTPPROXY=.*?\$\$', '', url)
        prxy = '' if prxy == '' else '&amp;p=%s'%prxy

        if re.search(r'\$\$RESOLVEONLY\$\$', url):
            url = re.sub(r'\$\$RESOLVEONLY\$\$', '', url)
            slProxy = streamlink_proxy.SLProxy_Helper()
            q = '' if q == '' else '&amp;q=%s'%q
            url = slProxy.resolve_url(urllib.quote(url)+q+prxy)
            addon_log("setResolvedUrl")
            listitem = xbmcgui.ListItem(str(name))
            listitem.setInfo('video', {'Title': str(name)})
            listitem.setPath(url)
            xbmcplugin.setResolvedUrl(int(sys.argv[1]), True, listitem)

        else:
            slProxy = streamlink_proxy.SLProxy_Helper()            
            url = urllib.quote(url)+'&amp;q=%s'%q + prxy
            listitem = xbmcgui.ListItem(str(name))
            listitem.setInfo('video', {'Title': str(name)})
            listitem.setPath(url)         
            slProxy.playSLink(url, listitem)
    except:
        import sys
        traceback.print_exc(file=sys.stdout)
        pass

elif mode==23:
    addon_log("get info then download")
    mtype='video'
    if '[mp3]' in name:
        mtype='audio'
        name=name.replace('[mp3]','')
    ytdl_download(url,name,mtype)

elif mode==24:
    addon_log("Audio only youtube download")
    ytdl_download(url,name,'audio')

elif mode==25:
    addon_log("Searchin Other plugins")
    _search(url,name)
    xbmcplugin.endOfDirectory(int(sys.argv[1]))

elif mode==55:
    addon_log("enabled lock")
    parentalblockedpin = addon.getSetting('parentalblockedpin')
    keyboard = xbmc.Keyboard('','Enter Pin')
    keyboard.doModal()
    if not (keyboard.isConfirmed() == False):
        newStr = keyboard.getText()
        if newStr==parentalblockedpin:
            addon.setSetting('parentalblocked', "false")
            xbmc.executebuiltin("XBMC.Notification(FireTV, zona premium desactivada,5000,"+icon+")")
        else:
            xbmc.executebuiltin("XBMC.Notification(FireTV, Codigo de activacion?,5000,"+icon+")")
    xbmcplugin.endOfDirectory(int(sys.argv[1]))
    
elif mode==56:
    addon_log("disable lock")
    addon.setSetting('parentalblocked', "true")
    xbmc.executebuiltin("XBMC.Notification(FireTV,Zona premium activada,5000,"+icon+")")
    xbmcplugin.endOfDirectory(int(sys.argv[1]))

elif mode==53:
    addon_log("Requesting JSON-RPC Items")
    pluginquerybyJSON(url)
    #xbmcplugin.endOfDirectory(int(sys.argv[1]))

if not viewmode==None:
   print 'setting view mode'
   xbmc.executebuiltin("Container.SetViewMode(%s)"%viewmode)